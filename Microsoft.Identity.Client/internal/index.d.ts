// Generated by tsbindgen - Architecture
// Namespace: Microsoft.Identity.Client
// Assembly: Microsoft.Identity.Client

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { ManagedIdentityId, PoPAuthenticationConfiguration } from "../../Microsoft.Identity.Client.AppConfig/internal/index.js";
import type { CacheLevel } from "../../Microsoft.Identity.Client.Cache/internal/index.js";
import type { KerberosTicketContainer } from "../../Microsoft.Identity.Client.Kerberos/internal/index.js";
import type { ManagedIdentitySource } from "../../Microsoft.Identity.Client.ManagedIdentity/internal/index.js";
import type { RegionOutcome } from "../../Microsoft.Identity.Client.Region/internal/index.js";
import type { TelemetryData } from "../../Microsoft.Identity.Client.TelemetryCore.TelemetryClient/internal/index.js";
import type { IIdentityLogger, ITelemetryClient } from "../../Microsoft.IdentityModel.Abstractions/internal/index.js";
import type { Dictionary, IDictionary, IEnumerable, IReadOnlyCollection, IReadOnlyDictionary, IReadOnlyList } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Action, AsyncCallback, Boolean as ClrBoolean, Byte, DateTimeOffset, Enum, Exception, Func, Guid, IAsyncResult, ICloneable, IComparable, IConvertible, IFormattable, Int32, Int64, IntPtr, ISpanFormattable, MulticastDelegate, Nullable, Object as ClrObject, String as ClrString, Uri, ValueType, Void } from "@tsonic/dotnet/System.js";
import type { HttpResponseHeaders } from "@tsonic/dotnet/System.Net.Http.Headers.js";
import type { HttpClient, HttpMethod, HttpRequestMessage } from "@tsonic/dotnet/System.Net.Http.js";
import type { SslPolicyErrors } from "@tsonic/dotnet/System.Net.Security.js";
import * as System_Runtime_Serialization_Internal from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { ISerializable } from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { ClaimsPrincipal } from "@tsonic/dotnet/System.Security.Claims.js";
import type { X509Certificate2, X509Chain } from "@tsonic/dotnet/System.Security.Cryptography.X509Certificates.js";
import type { SecureString } from "@tsonic/dotnet/System.Security.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading.js";
import type { Task } from "@tsonic/dotnet/System.Threading.Tasks.js";

export enum AadAuthorityAudience {
    none = 0,
    azureAdMyOrg = 1,
    azureAdAndPersonalMicrosoftAccount = 2,
    azureAdMultipleOrgs = 3,
    personalMicrosoftAccount = 4
}


export enum AzureCloudInstance {
    none = 0,
    azurePublic = 1,
    azureChina = 2,
    azureGermany = 3,
    azureUsGovernment = 4
}


export enum BrokerOptions_OperatingSystems {
    none = 0,
    windows = 1,
    linux = 2,
    OSX = 4
}


export enum CacheRefreshReason {
    notApplicable = 0,
    forceRefreshOrClaims = 1,
    noCachedAccessToken = 2,
    expired = 3,
    proactivelyRefreshed = 4
}


export enum LogLevel {
    always = -1,
    error = 0,
    warning = 1,
    info = 2,
    verbose = 3
}


export enum TelemetryAudienceType {
    preProduction = 0,
    production = 1
}


export enum TokenSource {
    identityProvider = 0,
    cache = 1,
    broker = 2
}


export enum UiRequiredExceptionClassification {
    none = 0,
    messageOnly = 1,
    basicAction = 2,
    additionalAction = 3,
    consentRequired = 4,
    userPasswordExpired = 5,
    promptNeverFailed = 6,
    acquireTokenSilentFailed = 7
}


export type LogCallback = (level: LogLevel, message: string, containsPii: boolean) => void;


export type TokenCacheCallback = (args: TokenCacheNotificationArgs) => void;


export interface IAccount$instance {
    readonly username: string;
    readonly environment: string;
    readonly homeAccountId: AccountId;
}


export type IAccount = IAccount$instance;

export interface IAppConfig$instance {
    readonly clientId: string;
    readonly enablePiiLogging: boolean;
    readonly httpClientFactory: IMsalHttpClientFactory;
    readonly logLevel: LogLevel;
    readonly isDefaultPlatformLoggingEnabled: boolean;
    readonly redirectUri: string;
    readonly tenantId: string;
    readonly loggingCallback: LogCallback;
    readonly extraQueryParameters: IDictionary<System_Internal.String, System_Internal.String>;
    readonly isBrokerEnabled: boolean;
    readonly clientName: string;
    readonly clientVersion: string;
    readonly telemetryConfig: ITelemetryConfig;
    readonly experimentalFeaturesEnabled: boolean;
    readonly clientCapabilities: IEnumerable<System_Internal.String>;
    readonly legacyCacheCompatibilityEnabled: boolean;
    readonly clientSecret: string;
    readonly clientCredentialCertificate: X509Certificate2;
    readonly parentActivityOrWindowFunc: Func<unknown>;
}


export type IAppConfig = IAppConfig$instance;

export interface IApplicationBase$instance {
}


export type IApplicationBase = IApplicationBase$instance;

export interface IByRefreshToken$instance {
    acquireTokenByRefreshToken(scopes: IEnumerable<System_Internal.String>, refreshToken: string): AcquireTokenByRefreshTokenParameterBuilder;
}


export type IByRefreshToken = IByRefreshToken$instance;

export interface IByUsernameAndPassword$instance {
    acquireTokenByUsernamePassword(scopes: IEnumerable<System_Internal.String>, username: string, password: string): AcquireTokenByUsernameAndPasswordConfidentialParameterBuilder;
}


export type IByUsernameAndPassword = IByUsernameAndPassword$instance;

export interface IClientApplicationBase$instance extends IApplicationBase {
    readonly appConfig: IAppConfig;
    readonly userTokenCache: ITokenCache;
    readonly authority: string;
    acquireTokenSilent(scopes: IEnumerable<System_Internal.String>, account: IAccount): AcquireTokenSilentParameterBuilder;
    acquireTokenSilent(scopes: IEnumerable<System_Internal.String>, loginHint: string): AcquireTokenSilentParameterBuilder;
    getAccountAsync(identifier: string): Task<IAccount>;
    getAccountsAsync(): Task<IEnumerable<IAccount>>;
    removeAsync(account: IAccount): Task;
}


export interface IClientApplicationBase$instance extends IApplicationBase$instance {}

export type IClientApplicationBase = IClientApplicationBase$instance;

export interface IConfidentialClientApplication$instance extends IClientApplicationBase, IApplicationBase {
    readonly appTokenCache: ITokenCache;
    readonly appConfig: IAppConfig;
    readonly userTokenCache: ITokenCache;
    readonly authority: string;
    acquireTokenByAuthorizationCode(scopes: IEnumerable<System_Internal.String>, authorizationCode: string): AcquireTokenByAuthorizationCodeParameterBuilder;
    acquireTokenForClient(scopes: IEnumerable<System_Internal.String>): AcquireTokenForClientParameterBuilder;
    acquireTokenOnBehalfOf(scopes: IEnumerable<System_Internal.String>, userAssertion: UserAssertion): AcquireTokenOnBehalfOfParameterBuilder;
    acquireTokenSilent(scopes: IEnumerable<System_Internal.String>, account: IAccount): AcquireTokenSilentParameterBuilder;
    acquireTokenSilent(scopes: IEnumerable<System_Internal.String>, loginHint: string): AcquireTokenSilentParameterBuilder;
    getAccountAsync(identifier: string): Task<IAccount>;
    getAccountsAsync(): Task<IEnumerable<IAccount>>;
    getAuthorizationRequestUrl(scopes: IEnumerable<System_Internal.String>): GetAuthorizationRequestUrlParameterBuilder;
    removeAsync(account: IAccount): Task;
}


export type IConfidentialClientApplication = IConfidentialClientApplication$instance;

export interface ILongRunningWebApi$instance {
    acquireTokenInLongRunningProcess(scopes: IEnumerable<System_Internal.String>, longRunningProcessSessionKey: string): AcquireTokenOnBehalfOfParameterBuilder;
    initiateLongRunningProcessInWebApi(scopes: IEnumerable<System_Internal.String>, userToken: string, longRunningProcessSessionKey: string): AcquireTokenOnBehalfOfParameterBuilder;
}


export type ILongRunningWebApi = ILongRunningWebApi$instance;

export interface IManagedIdentityApplication$instance extends IApplicationBase {
    acquireTokenForManagedIdentity(resource: string): AcquireTokenForManagedIdentityParameterBuilder;
}


export interface IManagedIdentityApplication$instance extends IApplicationBase$instance {}

export type IManagedIdentityApplication = IManagedIdentityApplication$instance;

export interface IMsalHttpClientFactory$instance {
    getHttpClient(): HttpClient;
}


export type IMsalHttpClientFactory = IMsalHttpClientFactory$instance;

export interface IMsalSFHttpClientFactory$instance extends IMsalHttpClientFactory {
    getHttpClient(): HttpClient;
    getHttpClient(validateServerCert: Func<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, System_Internal.Boolean>): HttpClient;
}


export type IMsalSFHttpClientFactory = IMsalSFHttpClientFactory$instance;

export interface IPublicClientApplication$instance extends IClientApplicationBase, IApplicationBase {
    readonly isSystemWebViewAvailable: boolean;
    readonly appConfig: IAppConfig;
    readonly userTokenCache: ITokenCache;
    readonly authority: string;
    acquireTokenByIntegratedWindowsAuth(scopes: IEnumerable<System_Internal.String>): AcquireTokenByIntegratedWindowsAuthParameterBuilder;
    acquireTokenByUsernamePassword(scopes: IEnumerable<System_Internal.String>, username: string, password: SecureString): AcquireTokenByUsernamePasswordParameterBuilder;
    acquireTokenByUsernamePassword(scopes: IEnumerable<System_Internal.String>, username: string, password: string): AcquireTokenByUsernamePasswordParameterBuilder;
    acquireTokenInteractive(scopes: IEnumerable<System_Internal.String>): AcquireTokenInteractiveParameterBuilder;
    acquireTokenSilent(scopes: IEnumerable<System_Internal.String>, account: IAccount): AcquireTokenSilentParameterBuilder;
    acquireTokenSilent(scopes: IEnumerable<System_Internal.String>, loginHint: string): AcquireTokenSilentParameterBuilder;
    acquireTokenWithDeviceCode(scopes: IEnumerable<System_Internal.String>, deviceCodeResultCallback: Func<DeviceCodeResult, Task>): AcquireTokenWithDeviceCodeParameterBuilder;
    getAccountAsync(identifier: string): Task<IAccount>;
    getAccountsAsync(): Task<IEnumerable<IAccount>>;
    removeAsync(account: IAccount): Task;
}


export type IPublicClientApplication = IPublicClientApplication$instance;

export interface ITelemetryConfig$instance {
    readonly audienceType: TelemetryAudienceType;
    readonly sessionId: string;
    readonly dispatchAction: Action<ITelemetryEventPayload>;
}


export type ITelemetryConfig = ITelemetryConfig$instance;

export interface ITelemetryEventPayload$instance {
    readonly name: string;
    readonly boolValues: IReadOnlyDictionary<System_Internal.String, System_Internal.Boolean>;
    readonly int64Values: IReadOnlyDictionary<System_Internal.String, System_Internal.Int64>;
    readonly intValues: IReadOnlyDictionary<System_Internal.String, System_Internal.Int32>;
    readonly stringValues: IReadOnlyDictionary<System_Internal.String, System_Internal.String>;
    toJsonString(): string;
}


export type ITelemetryEventPayload = ITelemetryEventPayload$instance;

export interface ITokenCache$instance {
    setBeforeAccess(beforeAccess: TokenCacheCallback): void;
    setBeforeAccessAsync(beforeAccess: Func<TokenCacheNotificationArgs, Task>): void;
}


export type ITokenCache = ITokenCache$instance;

export interface ITokenCacheSerializer$instance {
    deserializeAdalV3(adalV3State: byte[]): void;
    deserializeMsalV3(msalV3State: byte[], shouldClearExistingCache?: boolean): void;
    serializeMsalV3(): byte[];
}


export type ITokenCacheSerializer = ITokenCacheSerializer$instance;

export interface Prompt$instance {
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const Prompt: {
    new(): Prompt;
    readonly selectAccount: Prompt;
    readonly forceLogin: Prompt;
    readonly consent: Prompt;
    readonly noPrompt: Prompt;
    readonly create: Prompt;
};


export type Prompt = Prompt$instance;

export interface AbstractAcquireTokenParameterBuilder_1$instance<T extends BaseAbstractAcquireTokenParameterBuilder_1<T>> extends BaseAbstractAcquireTokenParameterBuilder_1<T> {
    withAdfsAuthority(authorityUri: string, validateAuthority?: boolean): T;
    withAuthority(authorityUri: string, validateAuthority?: boolean): T;
    withAuthority(cloudInstanceUri: string, tenantId: Guid, validateAuthority?: boolean): T;
    withAuthority(cloudInstanceUri: string, tenant: string, validateAuthority?: boolean): T;
    withAuthority(azureCloudInstance: AzureCloudInstance, tenantId: Guid, validateAuthority?: boolean): T;
    withAuthority(azureCloudInstance: AzureCloudInstance, tenant: string, validateAuthority?: boolean): T;
    withAuthority(azureCloudInstance: AzureCloudInstance, authorityAudience: AadAuthorityAudience, validateAuthority?: boolean): T;
    withAuthority(authorityAudience: AadAuthorityAudience, validateAuthority?: boolean): T;
    withB2CAuthority(authorityUri: string): T;
    withClaims(claims: string): T;
    withExtraQueryParameters(extraQueryParameters: string): T;
    withExtraQueryParameters(extraQueryParameters: Dictionary<System_Internal.String, System_Internal.String>): T;
    withTenantId(tenantId: string): T;
    withTenantIdFromAuthority(authorityUri: Uri): T;
}


export const AbstractAcquireTokenParameterBuilder_1: {
};


export type AbstractAcquireTokenParameterBuilder_1<T extends BaseAbstractAcquireTokenParameterBuilder_1<T>> = AbstractAcquireTokenParameterBuilder_1$instance<T>;

export interface AbstractApplicationBuilder_1$instance<T extends BaseAbstractApplicationBuilder_1<T>> extends BaseAbstractApplicationBuilder_1<T> {
    withAdfsAuthority(authorityUri: string, validateAuthority?: boolean): T;
    withAuthority(authorityUri: Uri, validateAuthority?: boolean): T;
    withAuthority(authorityUri: string, validateAuthority?: boolean): T;
    withAuthority(cloudInstanceUri: string, tenantId: Guid, validateAuthority?: boolean): T;
    withAuthority(cloudInstanceUri: string, tenant: string, validateAuthority?: boolean): T;
    withAuthority(azureCloudInstance: AzureCloudInstance, tenantId: Guid, validateAuthority?: boolean): T;
    withAuthority(azureCloudInstance: AzureCloudInstance, tenant: string, validateAuthority?: boolean): T;
    withAuthority(azureCloudInstance: AzureCloudInstance, authorityAudience: AadAuthorityAudience, validateAuthority?: boolean): T;
    withAuthority(authorityAudience: AadAuthorityAudience, validateAuthority?: boolean): T;
    withB2CAuthority(authorityUri: string): T;
    withCacheOptions(options: CacheOptions): T;
    withClientCapabilities(clientCapabilities: IEnumerable<System_Internal.String>): T;
    withClientId(clientId: string): T;
    withExtraQueryParameters(extraQueryParameters: IDictionary<System_Internal.String, System_Internal.String>): T;
    withExtraQueryParameters(extraQueryParameters: string): T;
    withInstanceDicoveryMetadata(instanceDiscoveryJson: string): T;
    withInstanceDicoveryMetadata(instanceDiscoveryUri: Uri): T;
    withInstanceDiscovery(enableInstanceDiscovery: boolean): T;
    withInstanceDiscoveryMetadata(instanceDiscoveryJson: string): T;
    withInstanceDiscoveryMetadata(instanceDiscoveryUri: Uri): T;
    withLegacyCacheCompatibility(enableLegacyCacheCompatibility?: boolean): T;
    withRedirectUri(redirectUri: string): T;
    withTelemetry(telemetryConfig: ITelemetryConfig): T;
    withTenantId(tenantId: string): T;
}


export const AbstractApplicationBuilder_1: {
};


export type AbstractApplicationBuilder_1<T extends BaseAbstractApplicationBuilder_1<T>> = AbstractApplicationBuilder_1$instance<T>;

export interface AbstractClientAppBaseAcquireTokenParameterBuilder_1$instance<T extends AbstractAcquireTokenParameterBuilder_1<T>> extends AbstractAcquireTokenParameterBuilder_1<T> {
    executeAsync(cancellationToken: CancellationToken): Task<AuthenticationResult>;
    executeAsync(cancellationToken: CancellationToken): Task<AuthenticationResult>;
    executeAsync(): Task<AuthenticationResult>;
}


export const AbstractClientAppBaseAcquireTokenParameterBuilder_1: {
};


export type AbstractClientAppBaseAcquireTokenParameterBuilder_1<T extends AbstractAcquireTokenParameterBuilder_1<T>> = AbstractClientAppBaseAcquireTokenParameterBuilder_1$instance<T>;

export interface AbstractConfidentialClientAcquireTokenParameterBuilder_1$instance<T extends AbstractAcquireTokenParameterBuilder_1<T>> extends AbstractAcquireTokenParameterBuilder_1<T> {
    executeAsync(cancellationToken: CancellationToken): Task<AuthenticationResult>;
    executeAsync(cancellationToken: CancellationToken): Task<AuthenticationResult>;
    executeAsync(): Task<AuthenticationResult>;
    withProofOfPossession(popAuthenticationConfiguration: PoPAuthenticationConfiguration): T;
    withSignedHttpRequestProofOfPossession(popAuthenticationConfiguration: PoPAuthenticationConfiguration): T;
}


export const AbstractConfidentialClientAcquireTokenParameterBuilder_1: {
};


export type AbstractConfidentialClientAcquireTokenParameterBuilder_1<T extends AbstractAcquireTokenParameterBuilder_1<T>> = AbstractConfidentialClientAcquireTokenParameterBuilder_1$instance<T>;

export interface AbstractManagedIdentityAcquireTokenParameterBuilder_1$instance<T extends BaseAbstractAcquireTokenParameterBuilder_1<T>> extends BaseAbstractAcquireTokenParameterBuilder_1<T> {
    executeAsync(cancellationToken: CancellationToken): Task<AuthenticationResult>;
    executeAsync(cancellationToken: CancellationToken): Task<AuthenticationResult>;
    executeAsync(): Task<AuthenticationResult>;
}


export const AbstractManagedIdentityAcquireTokenParameterBuilder_1: {
};


export type AbstractManagedIdentityAcquireTokenParameterBuilder_1<T extends BaseAbstractAcquireTokenParameterBuilder_1<T>> = AbstractManagedIdentityAcquireTokenParameterBuilder_1$instance<T>;

export interface AbstractPublicClientAcquireTokenParameterBuilder_1$instance<T extends AbstractAcquireTokenParameterBuilder_1<T>> extends AbstractAcquireTokenParameterBuilder_1<T> {
    executeAsync(cancellationToken: CancellationToken): Task<AuthenticationResult>;
    executeAsync(cancellationToken: CancellationToken): Task<AuthenticationResult>;
    executeAsync(): Task<AuthenticationResult>;
}


export const AbstractPublicClientAcquireTokenParameterBuilder_1: {
};


export type AbstractPublicClientAcquireTokenParameterBuilder_1<T extends AbstractAcquireTokenParameterBuilder_1<T>> = AbstractPublicClientAcquireTokenParameterBuilder_1$instance<T>;

export interface AccountId$instance {
    readonly identifier: string;
    readonly objectId: string;
    readonly tenantId: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string | undefined;
}


export const AccountId: {
    new(identifier: string, objectId: string, tenantId: string): AccountId;
    new(adfsIdentifier: string): AccountId;
};


export type AccountId = AccountId$instance;

export interface AcquireTokenByAuthorizationCodeParameterBuilder$instance extends AbstractConfidentialClientAcquireTokenParameterBuilder_1<AcquireTokenByAuthorizationCodeParameterBuilder> {
    withCcsRoutingHint(userObjectIdentifier: string, tenantIdentifier: string): AcquireTokenByAuthorizationCodeParameterBuilder;
    withCcsRoutingHint(userName: string): AcquireTokenByAuthorizationCodeParameterBuilder;
    withPkceCodeVerifier(pkceCodeVerifier: string): AcquireTokenByAuthorizationCodeParameterBuilder;
    withSendX5C(withSendX5C: boolean): AcquireTokenByAuthorizationCodeParameterBuilder;
    withSpaAuthorizationCode(requestSpaAuthorizationCode?: boolean): AcquireTokenByAuthorizationCodeParameterBuilder;
}


export const AcquireTokenByAuthorizationCodeParameterBuilder: {
    new(): AcquireTokenByAuthorizationCodeParameterBuilder;
};


export type AcquireTokenByAuthorizationCodeParameterBuilder = AcquireTokenByAuthorizationCodeParameterBuilder$instance;

export interface AcquireTokenByIntegratedWindowsAuthParameterBuilder$instance extends AbstractPublicClientAcquireTokenParameterBuilder_1<AcquireTokenByIntegratedWindowsAuthParameterBuilder> {
    withFederationMetadata(federationMetadata: string): AcquireTokenByIntegratedWindowsAuthParameterBuilder;
    withUsername(username: string): AcquireTokenByIntegratedWindowsAuthParameterBuilder;
}


export const AcquireTokenByIntegratedWindowsAuthParameterBuilder: {
    new(): AcquireTokenByIntegratedWindowsAuthParameterBuilder;
};


export type AcquireTokenByIntegratedWindowsAuthParameterBuilder = AcquireTokenByIntegratedWindowsAuthParameterBuilder$instance;

export interface AcquireTokenByRefreshTokenParameterBuilder$instance extends AbstractClientAppBaseAcquireTokenParameterBuilder_1<AcquireTokenByRefreshTokenParameterBuilder> {
    withSendX5C(withSendX5C: boolean): AcquireTokenByRefreshTokenParameterBuilder;
}


export const AcquireTokenByRefreshTokenParameterBuilder: {
    new(): AcquireTokenByRefreshTokenParameterBuilder;
};


export type AcquireTokenByRefreshTokenParameterBuilder = AcquireTokenByRefreshTokenParameterBuilder$instance;

export interface AcquireTokenByUsernameAndPasswordConfidentialParameterBuilder$instance extends AbstractConfidentialClientAcquireTokenParameterBuilder_1<AcquireTokenByUsernameAndPasswordConfidentialParameterBuilder> {
}


export const AcquireTokenByUsernameAndPasswordConfidentialParameterBuilder: {
    new(): AcquireTokenByUsernameAndPasswordConfidentialParameterBuilder;
};


export type AcquireTokenByUsernameAndPasswordConfidentialParameterBuilder = AcquireTokenByUsernameAndPasswordConfidentialParameterBuilder$instance;

export interface AcquireTokenByUsernamePasswordParameterBuilder$instance extends AbstractPublicClientAcquireTokenParameterBuilder_1<AcquireTokenByUsernamePasswordParameterBuilder> {
    withFederationMetadata(federationMetadata: string): AcquireTokenByUsernamePasswordParameterBuilder;
    withProofOfPossession(nonce: string, httpMethod: HttpMethod, requestUri: Uri): AcquireTokenByUsernamePasswordParameterBuilder;
}


export const AcquireTokenByUsernamePasswordParameterBuilder: {
    new(): AcquireTokenByUsernamePasswordParameterBuilder;
};


export type AcquireTokenByUsernamePasswordParameterBuilder = AcquireTokenByUsernamePasswordParameterBuilder$instance;

export interface AcquireTokenForClientParameterBuilder$instance extends AbstractConfidentialClientAcquireTokenParameterBuilder_1<AcquireTokenForClientParameterBuilder> {
    withAzureRegion(useAzureRegion: boolean): AcquireTokenForClientParameterBuilder;
    withFmiPath(pathSuffix: string): AcquireTokenForClientParameterBuilder;
    withForceRefresh(forceRefresh: boolean): AcquireTokenForClientParameterBuilder;
    withMtlsProofOfPossession(): AcquireTokenForClientParameterBuilder;
    withPreferredAzureRegion(useAzureRegion?: boolean, regionUsedIfAutoDetectFails?: string, fallbackToGlobal?: boolean): AcquireTokenForClientParameterBuilder;
    withSendX5C(withSendX5C: boolean): AcquireTokenForClientParameterBuilder;
}


export const AcquireTokenForClientParameterBuilder: {
    new(): AcquireTokenForClientParameterBuilder;
};


export type AcquireTokenForClientParameterBuilder = AcquireTokenForClientParameterBuilder$instance;

export interface AcquireTokenForManagedIdentityParameterBuilder$instance extends AbstractManagedIdentityAcquireTokenParameterBuilder_1<AcquireTokenForManagedIdentityParameterBuilder> {
    withClaims(claims: string): AcquireTokenForManagedIdentityParameterBuilder;
    withForceRefresh(forceRefresh: boolean): AcquireTokenForManagedIdentityParameterBuilder;
}


export const AcquireTokenForManagedIdentityParameterBuilder: {
    new(): AcquireTokenForManagedIdentityParameterBuilder;
};


export type AcquireTokenForManagedIdentityParameterBuilder = AcquireTokenForManagedIdentityParameterBuilder$instance;

export interface AcquireTokenInteractiveParameterBuilder$instance extends AbstractPublicClientAcquireTokenParameterBuilder_1<AcquireTokenInteractiveParameterBuilder> {
    withAccount(account: IAccount): AcquireTokenInteractiveParameterBuilder;
    withEmbeddedWebViewOptions(options: EmbeddedWebViewOptions): AcquireTokenInteractiveParameterBuilder;
    withExtraScopesToConsent(extraScopesToConsent: IEnumerable<System_Internal.String>): AcquireTokenInteractiveParameterBuilder;
    withLoginHint(loginHint: string): AcquireTokenInteractiveParameterBuilder;
    withParentActivityOrWindow(parent: unknown): AcquireTokenInteractiveParameterBuilder;
    withParentActivityOrWindow(window: nint): AcquireTokenInteractiveParameterBuilder;
    withPrompt(prompt: Prompt): AcquireTokenInteractiveParameterBuilder;
    withProofOfPossession(nonce: string, httpMethod: HttpMethod, requestUri: Uri): AcquireTokenInteractiveParameterBuilder;
    withSystemWebViewOptions(options: SystemWebViewOptions): AcquireTokenInteractiveParameterBuilder;
    withUseEmbeddedWebView(useEmbeddedWebView: boolean): AcquireTokenInteractiveParameterBuilder;
}


export const AcquireTokenInteractiveParameterBuilder: {
    new(): AcquireTokenInteractiveParameterBuilder;
};


export type AcquireTokenInteractiveParameterBuilder = AcquireTokenInteractiveParameterBuilder$instance;

export interface AcquireTokenOnBehalfOfParameterBuilder$instance extends AbstractConfidentialClientAcquireTokenParameterBuilder_1<AcquireTokenOnBehalfOfParameterBuilder> {
    withCcsRoutingHint(userObjectIdentifier: string, tenantIdentifier: string): AcquireTokenOnBehalfOfParameterBuilder;
    withCcsRoutingHint(userName: string): AcquireTokenOnBehalfOfParameterBuilder;
    withForceRefresh(forceRefresh: boolean): AcquireTokenOnBehalfOfParameterBuilder;
    withSendX5C(withSendX5C: boolean): AcquireTokenOnBehalfOfParameterBuilder;
}


export const AcquireTokenOnBehalfOfParameterBuilder: {
    new(): AcquireTokenOnBehalfOfParameterBuilder;
};


export type AcquireTokenOnBehalfOfParameterBuilder = AcquireTokenOnBehalfOfParameterBuilder$instance;

export interface AcquireTokenSilentParameterBuilder$instance extends AbstractClientAppBaseAcquireTokenParameterBuilder_1<AcquireTokenSilentParameterBuilder> {
    withForceRefresh(forceRefresh: boolean): AcquireTokenSilentParameterBuilder;
    withProofOfPossession(popAuthenticationConfiguration: PoPAuthenticationConfiguration): AcquireTokenSilentParameterBuilder;
    withProofOfPossession(nonce: string, httpMethod: HttpMethod, requestUri: Uri): AcquireTokenSilentParameterBuilder;
    withSendX5C(withSendX5C: boolean): AcquireTokenSilentParameterBuilder;
}


export const AcquireTokenSilentParameterBuilder: {
    new(): AcquireTokenSilentParameterBuilder;
};


export type AcquireTokenSilentParameterBuilder = AcquireTokenSilentParameterBuilder$instance;

export interface AcquireTokenWithDeviceCodeParameterBuilder$instance extends AbstractPublicClientAcquireTokenParameterBuilder_1<AcquireTokenWithDeviceCodeParameterBuilder> {
    withDeviceCodeResultCallback(deviceCodeResultCallback: Func<DeviceCodeResult, Task>): AcquireTokenWithDeviceCodeParameterBuilder;
}


export const AcquireTokenWithDeviceCodeParameterBuilder: {
    new(): AcquireTokenWithDeviceCodeParameterBuilder;
};


export type AcquireTokenWithDeviceCodeParameterBuilder = AcquireTokenWithDeviceCodeParameterBuilder$instance;

export interface ApplicationBase$instance extends IApplicationBase {
}


export const ApplicationBase: {
};


export type ApplicationBase = ApplicationBase$instance;

export interface ApplicationOptions$instance extends BaseApplicationOptions {
    aadAuthorityAudience: AadAuthorityAudience;
    azureCloudInstance: AzureCloudInstance;
    clientCapabilities: IEnumerable<System_Internal.String>;
    clientId: string;
    clientName: string;
    clientVersion: string;
    instance: string;
    kerberosServicePrincipalName: string;
    legacyCacheCompatibilityEnabled: boolean;
    redirectUri: string;
    tenantId: string;
    ticketContainer: KerberosTicketContainer;
}


export const ApplicationOptions: {
};


export type ApplicationOptions = ApplicationOptions$instance;

export interface AssertionRequestOptions$instance {
    cancellationToken: CancellationToken;
    claims: string;
    clientAssertionFmiPath: string;
    clientCapabilities: IEnumerable<System_Internal.String>;
    clientID: string;
    tokenEndpoint: string;
}


export const AssertionRequestOptions: {
    new(): AssertionRequestOptions;
};


export type AssertionRequestOptions = AssertionRequestOptions$instance;

export interface AuthenticationHeaderParser$instance {
    readonly authenticationInfoParameters: AuthenticationInfoParameters;
    readonly popNonce: string;
    readonly wwwAuthenticateParameters: IReadOnlyList<WwwAuthenticateParameters>;
}


export const AuthenticationHeaderParser: {
    new(): AuthenticationHeaderParser;
    parseAuthenticationHeaders(httpResponseHeaders: HttpResponseHeaders): AuthenticationHeaderParser;
    parseAuthenticationHeadersAsync(resourceUri: string, httpClient: HttpClient, cancellationToken?: CancellationToken): Task<AuthenticationHeaderParser>;
    parseAuthenticationHeadersAsync(resourceUri: string, cancellationToken?: CancellationToken): Task<AuthenticationHeaderParser>;
};


export type AuthenticationHeaderParser = AuthenticationHeaderParser$instance;

export interface AuthenticationInfoParameters$instance {
    readonly item: string;
    readonly nextNonce: string;
}


export const AuthenticationInfoParameters: {
    new(): AuthenticationInfoParameters;
    createFromResponseHeaders(httpResponseHeaders: HttpResponseHeaders): AuthenticationInfoParameters;
};


export type AuthenticationInfoParameters = AuthenticationInfoParameters$instance;

export interface AuthenticationResult$instance {
    accessToken: string;
    readonly account: IAccount;
    readonly additionalResponseParameters: IReadOnlyDictionary<System_Internal.String, System_Internal.String>;
    readonly authenticationResultMetadata: AuthenticationResultMetadata;
    readonly claimsPrincipal: ClaimsPrincipal;
    readonly correlationId: Guid;
    readonly expiresOn: DateTimeOffset;
    readonly extendedExpiresOn: DateTimeOffset;
    readonly idToken: string;
    readonly isExtendedLifeTimeToken: boolean;
    readonly scopes: IEnumerable<System_Internal.String>;
    readonly spaAuthCode: string;
    readonly tenantId: string;
    readonly tokenType: string;
    readonly uniqueId: string;
    createAuthorizationHeader(): string;
}


export const AuthenticationResult: {
    new(accessToken: string, isExtendedLifeTimeToken: boolean, uniqueId: string, expiresOn: DateTimeOffset, extendedExpiresOn: DateTimeOffset, tenantId: string, account: IAccount, idToken: string, scopes: IEnumerable<System_Internal.String>, correlationId: Guid, tokenType: string, authenticationResultMetadata: AuthenticationResultMetadata, claimsPrincipal: ClaimsPrincipal, spaAuthCode: string, additionalResponseParameters: IReadOnlyDictionary<System_Internal.String, System_Internal.String>): AuthenticationResult;
    new(accessToken: string, isExtendedLifeTimeToken: boolean, uniqueId: string, expiresOn: DateTimeOffset, extendedExpiresOn: DateTimeOffset, tenantId: string, account: IAccount, idToken: string, scopes: IEnumerable<System_Internal.String>, correlationId: Guid, authenticationResultMetadata: AuthenticationResultMetadata, tokenType: string): AuthenticationResult;
};


export type AuthenticationResult = AuthenticationResult$instance;

export interface AuthenticationResultMetadata$instance {
    cachedAccessTokenCount: int;
    cacheLevel: CacheLevel;
    cacheRefreshReason: CacheRefreshReason;
    durationCreatingExtendedTokenInUs: long;
    durationInCacheInMs: long;
    durationInHttpInMs: long;
    durationTotalInMs: long;
    refreshOn: Nullable<DateTimeOffset>;
    regionDetails: RegionDetails;
    telemetry: string;
    tokenEndpoint: string;
    readonly tokenSource: TokenSource;
}


export const AuthenticationResultMetadata: {
    new(tokenSource: TokenSource): AuthenticationResultMetadata;
};


export type AuthenticationResultMetadata = AuthenticationResultMetadata$instance;

export interface BaseAbstractAcquireTokenParameterBuilder_1$instance<T extends BaseAbstractAcquireTokenParameterBuilder_1<T>> {
    executeAsync(cancellationToken: CancellationToken): Task<AuthenticationResult>;
    executeAsync(): Task<AuthenticationResult>;
    withCorrelationId(correlationId: Guid): T;
    withExtraQueryParameters(extraQueryParameters: Dictionary<System_Internal.String, System_Internal.String>): T;
}


export const BaseAbstractAcquireTokenParameterBuilder_1: {
};


export type BaseAbstractAcquireTokenParameterBuilder_1<T extends BaseAbstractAcquireTokenParameterBuilder_1<T>> = BaseAbstractAcquireTokenParameterBuilder_1$instance<T>;

export interface BaseAbstractApplicationBuilder_1$instance<T extends BaseAbstractApplicationBuilder_1<T>> {
    withClientName(clientName: string): T;
    withClientVersion(clientVersion: string): T;
    withDebugLoggingCallback(logLevel?: LogLevel, enablePiiLogging?: boolean, withDefaultPlatformLoggingEnabled?: boolean): T;
    withExperimentalFeatures(enableExperimentalFeatures?: boolean): T;
    withHttpClientFactory(httpClientFactory: IMsalHttpClientFactory): T;
    withHttpClientFactory(httpClientFactory: IMsalHttpClientFactory, retryOnceOn5xx: boolean): T;
    withLogging(loggingCallback: LogCallback, logLevel?: Nullable<LogLevel>, enablePiiLogging?: Nullable<System_Internal.Boolean>, enableDefaultPlatformLogging?: Nullable<System_Internal.Boolean>): T;
    withLogging(identityLogger: IIdentityLogger, enablePiiLogging?: boolean): T;
}


export const BaseAbstractApplicationBuilder_1: {
};


export type BaseAbstractApplicationBuilder_1<T extends BaseAbstractApplicationBuilder_1<T>> = BaseAbstractApplicationBuilder_1$instance<T>;

export interface BaseApplicationOptions$instance {
    enablePiiLogging: boolean;
    isDefaultPlatformLoggingEnabled: boolean;
    logLevel: LogLevel;
}


export const BaseApplicationOptions: {
};


export type BaseApplicationOptions = BaseApplicationOptions$instance;

export interface BrokerOptions$instance {
    readonly enabledOn: BrokerOptions_OperatingSystems;
    listOperatingSystemAccounts: boolean;
    msaPassthrough: boolean;
    title: string;
}


export const BrokerOptions: {
    new(enabledOn: BrokerOptions_OperatingSystems): BrokerOptions;
};


export type BrokerOptions = BrokerOptions$instance;

export interface CacheOptions$instance {
    useSharedCache: boolean;
}


export const CacheOptions: {
    new(): CacheOptions;
    new(useSharedCache: boolean): CacheOptions;
    readonly enableSharedCacheOptions: CacheOptions;
};


export type CacheOptions = CacheOptions$instance;

export interface ClientApplicationBase$instance extends ApplicationBase, IApplicationBase {
    readonly appConfig: IAppConfig;
    readonly authority: string;
    readonly userTokenCache: ITokenCache;
    acquireTokenSilent(scopes: IEnumerable<System_Internal.String>, account: IAccount): AcquireTokenSilentParameterBuilder;
    acquireTokenSilent(scopes: IEnumerable<System_Internal.String>, loginHint: string): AcquireTokenSilentParameterBuilder;
    getAccountAsync(accountId: string, cancellationToken?: CancellationToken): Task<IAccount>;
    getAccountAsync(accountId: string): Task<IAccount>;
    getAccountsAsync(): Task<IEnumerable<IAccount>>;
    getAccountsAsync(cancellationToken?: CancellationToken): Task<IEnumerable<IAccount>>;
    getAccountsAsync(userFlow: string): Task<IEnumerable<IAccount>>;
    getAccountsAsync(userFlow: string, cancellationToken?: CancellationToken): Task<IEnumerable<IAccount>>;
    removeAsync(account: IAccount): Task;
    removeAsync(account: IAccount, cancellationToken?: CancellationToken): Task;
}


export const ClientApplicationBase: {
};


export interface __ClientApplicationBase$views {
    As_IClientApplicationBase(): IClientApplicationBase$instance;
}

export type ClientApplicationBase = ClientApplicationBase$instance & __ClientApplicationBase$views;


export interface ConfidentialClientApplication$instance extends ClientApplicationBase$instance, IApplicationBase {
    readonly appTokenCache: ITokenCache;
    readonly certificate: X509Certificate2 | undefined;
    acquireTokenByAuthorizationCode(scopes: IEnumerable<System_Internal.String>, authorizationCode: string): AcquireTokenByAuthorizationCodeParameterBuilder;
    acquireTokenForClient(scopes: IEnumerable<System_Internal.String>): AcquireTokenForClientParameterBuilder;
    acquireTokenInLongRunningProcess(scopes: IEnumerable<System_Internal.String>, longRunningProcessSessionKey: string): AcquireTokenOnBehalfOfParameterBuilder;
    acquireTokenOnBehalfOf(scopes: IEnumerable<System_Internal.String>, userAssertion: UserAssertion): AcquireTokenOnBehalfOfParameterBuilder;
    acquireTokenSilent(scopes: IEnumerable<System_Internal.String>, account: IAccount): AcquireTokenSilentParameterBuilder;
    acquireTokenSilent(scopes: IEnumerable<System_Internal.String>, loginHint: string): AcquireTokenSilentParameterBuilder;
    getAccountAsync(accountId: string, cancellationToken?: CancellationToken): Task<IAccount>;
    getAccountAsync(accountId: string): Task<IAccount>;
    getAccountsAsync(): Task<IEnumerable<IAccount>>;
    getAccountsAsync(cancellationToken?: CancellationToken): Task<IEnumerable<IAccount>>;
    getAccountsAsync(userFlow: string): Task<IEnumerable<IAccount>>;
    getAccountsAsync(userFlow: string, cancellationToken?: CancellationToken): Task<IEnumerable<IAccount>>;
    getAuthorizationRequestUrl(scopes: IEnumerable<System_Internal.String>): GetAuthorizationRequestUrlParameterBuilder;
    initiateLongRunningProcessInWebApi(scopes: IEnumerable<System_Internal.String>, userToken: string, longRunningProcessSessionKey: string): AcquireTokenOnBehalfOfParameterBuilder;
    removeAsync(account: IAccount): Task;
    removeAsync(account: IAccount, cancellationToken?: CancellationToken): Task;
    stopLongRunningProcessInWebApiAsync(longRunningProcessSessionKey: string, cancellationToken?: CancellationToken): Task<System_Internal.Boolean>;
}


export const ConfidentialClientApplication: {
    new(): ConfidentialClientApplication;
    readonly attemptRegionDiscovery: string;
};


export interface __ConfidentialClientApplication$views {
    As_IByRefreshToken(): IByRefreshToken$instance;
    As_IByUsernameAndPassword(): IByUsernameAndPassword$instance;
    As_IClientApplicationBase(): IClientApplicationBase$instance;
    As_IConfidentialClientApplication(): IConfidentialClientApplication$instance;
    As_ILongRunningWebApi(): ILongRunningWebApi$instance;
}

export interface ConfidentialClientApplication$instance extends IByRefreshToken$instance, IByUsernameAndPassword$instance, ILongRunningWebApi$instance {}

export type ConfidentialClientApplication = ConfidentialClientApplication$instance & __ConfidentialClientApplication$views;


export interface ConfidentialClientApplicationBuilder$instance extends AbstractApplicationBuilder_1<ConfidentialClientApplicationBuilder> {
    build(): IConfidentialClientApplication;
    withAzureRegion(azureRegion?: string): ConfidentialClientApplicationBuilder;
    withCacheSynchronization(enableCacheSynchronization: boolean): ConfidentialClientApplicationBuilder;
    withCertificate(certificate: X509Certificate2): ConfidentialClientApplicationBuilder;
    withCertificate(certificate: X509Certificate2, sendX5C: boolean): ConfidentialClientApplicationBuilder;
    withClientAssertion(signedClientAssertion: string): ConfidentialClientApplicationBuilder;
    withClientAssertion(clientAssertionDelegate: Func<System_Internal.String>): ConfidentialClientApplicationBuilder;
    withClientAssertion(clientAssertionAsyncDelegate: Func<CancellationToken, Task<System_Internal.String>>): ConfidentialClientApplicationBuilder;
    withClientAssertion(clientAssertionAsyncDelegate: Func<AssertionRequestOptions, Task<System_Internal.String>>): ConfidentialClientApplicationBuilder;
    withClientClaims(certificate: X509Certificate2, claimsToSign: IDictionary<System_Internal.String, System_Internal.String>, mergeWithDefaultClaims: boolean): ConfidentialClientApplicationBuilder;
    withClientClaims(certificate: X509Certificate2, claimsToSign: IDictionary<System_Internal.String, System_Internal.String>, mergeWithDefaultClaims?: boolean, sendX5C?: boolean): ConfidentialClientApplicationBuilder;
    withClientSecret(clientSecret: string): ConfidentialClientApplicationBuilder;
    withGenericAuthority(authorityUri: string): ConfidentialClientApplicationBuilder;
    withOidcAuthority(authorityUri: string): ConfidentialClientApplicationBuilder;
    withTelemetryClient(...telemetryClients: ITelemetryClient[]): ConfidentialClientApplicationBuilder;
}


export const ConfidentialClientApplicationBuilder: {
    new(): ConfidentialClientApplicationBuilder;
    create(clientId: string): ConfidentialClientApplicationBuilder;
    createWithApplicationOptions(options: ConfidentialClientApplicationOptions): ConfidentialClientApplicationBuilder;
};


export type ConfidentialClientApplicationBuilder = ConfidentialClientApplicationBuilder$instance;

export interface ConfidentialClientApplicationOptions$instance extends ApplicationOptions {
    azureRegion: string;
    clientSecret: string;
    enableCacheSynchronization: boolean;
}


export const ConfidentialClientApplicationOptions: {
    new(): ConfidentialClientApplicationOptions;
};


export type ConfidentialClientApplicationOptions = ConfidentialClientApplicationOptions$instance;

export interface DeviceCodeResult$instance {
    readonly clientId: string;
    readonly deviceCode: string;
    readonly expiresOn: DateTimeOffset;
    readonly interval: long;
    readonly message: string | undefined;
    readonly scopes: IReadOnlyCollection<System_Internal.String>;
    readonly userCode: string;
    readonly verificationUrl: string;
}


export const DeviceCodeResult: {
    new(): DeviceCodeResult;
};


export type DeviceCodeResult = DeviceCodeResult$instance;

export interface EmbeddedWebViewOptions$instance {
    title: string;
    webView2BrowserExecutableFolder: string;
}


export const EmbeddedWebViewOptions: {
    new(): EmbeddedWebViewOptions;
};


export type EmbeddedWebViewOptions = EmbeddedWebViewOptions$instance;

export interface GetAuthorizationRequestUrlParameterBuilder$instance extends AbstractConfidentialClientAcquireTokenParameterBuilder_1<GetAuthorizationRequestUrlParameterBuilder> {
    executeAsync(cancellationToken: CancellationToken): Task<Uri>;
    executeAsync(): Task<Uri>;
    executeAsync(cancellationToken: CancellationToken): Task<AuthenticationResult>;
    executeAsync(): Task<AuthenticationResult>;
    withAccount(account: IAccount): GetAuthorizationRequestUrlParameterBuilder;
    withCcsRoutingHint(userObjectIdentifier: string, tenantIdentifier: string): GetAuthorizationRequestUrlParameterBuilder;
    withExtraScopesToConsent(extraScopesToConsent: IEnumerable<System_Internal.String>): GetAuthorizationRequestUrlParameterBuilder;
    withLoginHint(loginHint: string): GetAuthorizationRequestUrlParameterBuilder;
    withPkce(codeVerifier: string): GetAuthorizationRequestUrlParameterBuilder;
    withPrompt(prompt: Prompt): GetAuthorizationRequestUrlParameterBuilder;
    withRedirectUri(redirectUri: string): GetAuthorizationRequestUrlParameterBuilder;
}


export const GetAuthorizationRequestUrlParameterBuilder: {
    new(): GetAuthorizationRequestUrlParameterBuilder;
};


export type GetAuthorizationRequestUrlParameterBuilder = GetAuthorizationRequestUrlParameterBuilder$instance;

export interface IntuneAppProtectionPolicyRequiredException$instance extends MsalServiceException {
    accountUserId: string;
    authorityUrl: string;
    tenantId: string;
    upn: string;
}


export const IntuneAppProtectionPolicyRequiredException: {
    new(errorCode: string, errorMessage: string): IntuneAppProtectionPolicyRequiredException;
};


export type IntuneAppProtectionPolicyRequiredException = IntuneAppProtectionPolicyRequiredException$instance;

export interface ManagedIdentityApplication$instance extends ApplicationBase, IApplicationBase {
    acquireTokenForManagedIdentity(resource: string): AcquireTokenForManagedIdentityParameterBuilder;
}


export const ManagedIdentityApplication: {
    new(): ManagedIdentityApplication;
    getManagedIdentitySource(): ManagedIdentitySource;
};


export interface __ManagedIdentityApplication$views {
    As_IManagedIdentityApplication(): IManagedIdentityApplication$instance;
}

export interface ManagedIdentityApplication$instance extends IManagedIdentityApplication$instance {}

export type ManagedIdentityApplication = ManagedIdentityApplication$instance & __ManagedIdentityApplication$views;


export interface ManagedIdentityApplicationBuilder$instance extends BaseAbstractApplicationBuilder_1<ManagedIdentityApplicationBuilder> {
    build(): IManagedIdentityApplication;
    withClientCapabilities(clientCapabilities: IEnumerable<System_Internal.String>): ManagedIdentityApplicationBuilder;
    withTelemetryClient(...telemetryClients: ITelemetryClient[]): ManagedIdentityApplicationBuilder;
}


export const ManagedIdentityApplicationBuilder: {
    new(): ManagedIdentityApplicationBuilder;
    create(managedIdentityId: ManagedIdentityId): ManagedIdentityApplicationBuilder;
};


export type ManagedIdentityApplicationBuilder = ManagedIdentityApplicationBuilder$instance;

export interface Metrics$instance {
}


export const Metrics: {
    new(): Metrics;
    readonly totalAccessTokensFromIdP: long;
    readonly totalAccessTokensFromCache: long;
    readonly totalAccessTokensFromBroker: long;
    readonly totalDurationInMs: long;
};


export type Metrics = Metrics$instance;

export interface MsalClaimsChallengeException$instance extends MsalUiRequiredException {
}


export const MsalClaimsChallengeException: {
    new(errorCode: string, errorMessage: string): MsalClaimsChallengeException;
    new(errorCode: string, errorMessage: string, innerException: Exception): MsalClaimsChallengeException;
    new(errorCode: string, errorMessage: string, innerException: Exception, classification: UiRequiredExceptionClassification): MsalClaimsChallengeException;
};


export type MsalClaimsChallengeException = MsalClaimsChallengeException$instance;

export interface MsalClientException$instance extends MsalException {
}


export const MsalClientException: {
    new(errorCode: string): MsalClientException;
    new(errorCode: string, errorMessage: string): MsalClientException;
    new(errorCode: string, errorMessage: string, innerException: Exception): MsalClientException;
};


export type MsalClientException = MsalClientException$instance;

export interface MsalException$instance extends Exception {
    additionalExceptionData: IReadOnlyDictionary<System_Internal.String, System_Internal.String>;
    correlationId: string;
    readonly errorCode: string | undefined;
    isRetryable: boolean;
    toJsonString(): string;
    toString(): string;
}


export const MsalException: {
    new(): MsalException;
    new(errorCode: string): MsalException;
    new(errorCode: string, errorMessage: string): MsalException;
    new(errorCode: string, errorMessage: string, innerException: Exception): MsalException;
    readonly brokerErrorContext: string;
    readonly brokerErrorTag: string;
    readonly brokerErrorStatus: string;
    readonly brokerErrorCode: string;
    readonly brokerTelemetry: string;
    readonly managedIdentitySource: string;
    fromJsonString(json: string): MsalException;
};


export type MsalException = MsalException$instance;

export interface MsalManagedIdentityException$instance extends MsalServiceException {
    readonly managedIdentitySource: ManagedIdentitySource;
}


export const MsalManagedIdentityException: {
    new(errorCode: string, errorMessage: string, source: ManagedIdentitySource): MsalManagedIdentityException;
    new(errorCode: string, errorMessage: string, source: ManagedIdentitySource, statusCode: int): MsalManagedIdentityException;
    new(errorCode: string, errorMessage: string, innerException: Exception, source: ManagedIdentitySource, statusCode: int): MsalManagedIdentityException;
    new(errorCode: string, errorMessage: string, innerException: Exception, source: ManagedIdentitySource): MsalManagedIdentityException;
};


export type MsalManagedIdentityException = MsalManagedIdentityException$instance;

export interface MsalServiceException$instance extends MsalException {
    readonly claims: string;
    headers: HttpResponseHeaders;
    responseBody: string;
    readonly statusCode: int;
    toString(): string;
}


export const MsalServiceException: {
    new(errorCode: string, errorMessage: string): MsalServiceException;
    new(errorCode: string, errorMessage: string, statusCode: int): MsalServiceException;
    new(errorCode: string, errorMessage: string, innerException: Exception): MsalServiceException;
    new(errorCode: string, errorMessage: string, statusCode: int, innerException: Exception): MsalServiceException;
    new(errorCode: string, errorMessage: string, statusCode: int, claims: string, innerException: Exception): MsalServiceException;
};


export type MsalServiceException = MsalServiceException$instance;

export interface MsalThrottledServiceException$instance extends MsalServiceException {
    readonly originalServiceException: MsalServiceException;
}


export const MsalThrottledServiceException: {
    new(originalException: MsalServiceException): MsalThrottledServiceException;
};


export type MsalThrottledServiceException = MsalThrottledServiceException$instance;

export interface MsalThrottledUiRequiredException$instance extends MsalUiRequiredException {
    readonly originalServiceException: MsalUiRequiredException;
}


export const MsalThrottledUiRequiredException: {
    new(originalException: MsalUiRequiredException): MsalThrottledUiRequiredException;
};


export type MsalThrottledUiRequiredException = MsalThrottledUiRequiredException$instance;

export interface MsalUiRequiredException$instance extends MsalServiceException {
    readonly classification: UiRequiredExceptionClassification;
}


export const MsalUiRequiredException: {
    new(errorCode: string, errorMessage: string): MsalUiRequiredException;
    new(errorCode: string, errorMessage: string, innerException: Exception): MsalUiRequiredException;
    new(errorCode: string, errorMessage: string, innerException: Exception, classification: UiRequiredExceptionClassification): MsalUiRequiredException;
};


export type MsalUiRequiredException = MsalUiRequiredException$instance;

export interface PublicClientApplication$instance extends ClientApplicationBase$instance, IApplicationBase {
    readonly isSystemWebViewAvailable: boolean;
    acquireTokenByIntegratedWindowsAuth(scopes: IEnumerable<System_Internal.String>): AcquireTokenByIntegratedWindowsAuthParameterBuilder;
    acquireTokenByUsernamePassword(scopes: IEnumerable<System_Internal.String>, username: string, password: SecureString): AcquireTokenByUsernamePasswordParameterBuilder;
    acquireTokenByUsernamePassword(scopes: IEnumerable<System_Internal.String>, username: string, password: string): AcquireTokenByUsernamePasswordParameterBuilder;
    acquireTokenInteractive(scopes: IEnumerable<System_Internal.String>): AcquireTokenInteractiveParameterBuilder;
    acquireTokenSilent(scopes: IEnumerable<System_Internal.String>, account: IAccount): AcquireTokenSilentParameterBuilder;
    acquireTokenSilent(scopes: IEnumerable<System_Internal.String>, loginHint: string): AcquireTokenSilentParameterBuilder;
    acquireTokenWithDeviceCode(scopes: IEnumerable<System_Internal.String>, deviceCodeResultCallback: Func<DeviceCodeResult, Task>): AcquireTokenWithDeviceCodeParameterBuilder;
    getAccountAsync(accountId: string, cancellationToken?: CancellationToken): Task<IAccount>;
    getAccountAsync(accountId: string): Task<IAccount>;
    getAccountsAsync(): Task<IEnumerable<IAccount>>;
    getAccountsAsync(cancellationToken?: CancellationToken): Task<IEnumerable<IAccount>>;
    getAccountsAsync(userFlow: string): Task<IEnumerable<IAccount>>;
    getAccountsAsync(userFlow: string, cancellationToken?: CancellationToken): Task<IEnumerable<IAccount>>;
    isBrokerAvailable(): boolean;
    isEmbeddedWebViewAvailable(): boolean;
    isProofOfPossessionSupportedByClient(): boolean;
    isUserInteractive(): boolean;
    removeAsync(account: IAccount): Task;
    removeAsync(account: IAccount, cancellationToken?: CancellationToken): Task;
}


export const PublicClientApplication: {
    new(): PublicClientApplication;
    readonly operatingSystemAccount: IAccount;
};


export interface __PublicClientApplication$views {
    As_IByRefreshToken(): IByRefreshToken$instance;
    As_IClientApplicationBase(): IClientApplicationBase$instance;
    As_IPublicClientApplication(): IPublicClientApplication$instance;
}

export interface PublicClientApplication$instance extends IByRefreshToken$instance {}

export type PublicClientApplication = PublicClientApplication$instance & __PublicClientApplication$views;


export interface PublicClientApplicationBuilder$instance extends AbstractApplicationBuilder_1<PublicClientApplicationBuilder> {
    build(): IPublicClientApplication;
    isBrokerAvailable(): boolean;
    withBroker(enableBroker?: boolean): PublicClientApplicationBuilder;
    withDefaultRedirectUri(): PublicClientApplicationBuilder;
    withIosKeychainSecurityGroup(keychainSecurityGroup: string): PublicClientApplicationBuilder;
    withKerberosTicketClaim(servicePrincipalName: string, ticketContainer: KerberosTicketContainer): PublicClientApplicationBuilder;
    withMultiCloudSupport(enableMultiCloudSupport: boolean): PublicClientApplicationBuilder;
    withOidcAuthority(authorityUri: string): PublicClientApplicationBuilder;
    withParentActivityOrWindow(parentActivityOrWindowFunc: Func<unknown>): PublicClientApplicationBuilder;
    withParentActivityOrWindow(windowFunc: Func<System_Internal.IntPtr>): PublicClientApplicationBuilder;
    withWindowsBrokerOptions(options: WindowsBrokerOptions): PublicClientApplicationBuilder;
}


export const PublicClientApplicationBuilder: {
    new(): PublicClientApplicationBuilder;
    create(clientId: string): PublicClientApplicationBuilder;
    createWithApplicationOptions(options: PublicClientApplicationOptions): PublicClientApplicationBuilder;
};


export type PublicClientApplicationBuilder = PublicClientApplicationBuilder$instance;

export interface PublicClientApplicationOptions$instance extends ApplicationOptions {
}


export const PublicClientApplicationOptions: {
    new(): PublicClientApplicationOptions;
};


export type PublicClientApplicationOptions = PublicClientApplicationOptions$instance;

export interface RegionDetails$instance {
    readonly autoDetectionError: string;
    readonly regionOutcome: RegionOutcome;
    readonly regionUsed: string;
}


export const RegionDetails: {
    new(regionOutcome: RegionOutcome, regionUsed: string, autoDetectionError: string): RegionDetails;
};


export type RegionDetails = RegionDetails$instance;

export interface SystemWebViewOptions$instance {
    browserRedirectError: Uri;
    browserRedirectSuccess: Uri;
    htmlMessageError: string;
    htmlMessageSuccess: string;
    iOSHidePrivacyPrompt: boolean;
    openBrowserAsync: Func<Uri, Task>;
}


export const SystemWebViewOptions: {
    new(): SystemWebViewOptions;
    openWithChromeEdgeBrowserAsync(uri: Uri): Task;
    openWithEdgeBrowserAsync(uri: Uri): Task;
};


export type SystemWebViewOptions = SystemWebViewOptions$instance;

export interface TenantProfile$instance {
    readonly claimsPrincipal: ClaimsPrincipal;
    readonly isHomeTenant: boolean;
    readonly oid: string;
    readonly tenantId: string;
}


export const TenantProfile: {
    new(): TenantProfile;
};


export type TenantProfile = TenantProfile$instance;

export interface TokenCache$instance {
    setAfterAccess(afterAccess: TokenCacheCallback): void;
    setAfterAccessAsync(afterAccess: Func<TokenCacheNotificationArgs, Task>): void;
    setBeforeAccess(beforeAccess: TokenCacheCallback): void;
    setBeforeAccessAsync(beforeAccess: Func<TokenCacheNotificationArgs, Task>): void;
    setBeforeWrite(beforeWrite: TokenCacheCallback): void;
    setBeforeWriteAsync(beforeWrite: Func<TokenCacheNotificationArgs, Task>): void;
    setIosKeychainSecurityGroup(securityGroup: string): void;
}


export const TokenCache: {
    new(): TokenCache;
};


export interface __TokenCache$views {
    As_ITokenCache(): ITokenCache$instance;
    As_ITokenCacheSerializer(): ITokenCacheSerializer$instance;
}

export interface TokenCache$instance extends ITokenCache$instance, ITokenCacheSerializer$instance {}

export type TokenCache = TokenCache$instance & __TokenCache$views;


export interface TokenCacheNotificationArgs$instance {
    readonly account: IAccount;
    readonly cancellationToken: CancellationToken;
    readonly clientId: string;
    readonly correlationId: Guid;
    readonly hasStateChanged: boolean;
    readonly hasTokens: boolean;
    readonly identityLogger: IIdentityLogger;
    readonly isApplicationCache: boolean;
    readonly noDistributedCacheUseReason: string;
    readonly piiLoggingEnabled: boolean;
    readonly requestScopes: IEnumerable<System_Internal.String>;
    readonly requestTenantId: string;
    readonly suggestedCacheExpiry: Nullable<DateTimeOffset>;
    readonly suggestedCacheKey: string;
    readonly telemetryData: TelemetryData;
    readonly tokenCache: ITokenCacheSerializer;
}


export const TokenCacheNotificationArgs: {
    new(tokenCache: ITokenCacheSerializer, clientId: string, account: IAccount, hasStateChanged: boolean, isApplicationCache: boolean, suggestedCacheKey: string, hasTokens: boolean, suggestedCacheExpiry: Nullable<DateTimeOffset>, cancellationToken: CancellationToken): TokenCacheNotificationArgs;
    new(tokenCache: ITokenCacheSerializer, clientId: string, account: IAccount, hasStateChanged: boolean, isApplicationCache: boolean, suggestedCacheKey: string, hasTokens: boolean, suggestedCacheExpiry: Nullable<DateTimeOffset>, cancellationToken: CancellationToken, correlationId: Guid): TokenCacheNotificationArgs;
    new(tokenCache: ITokenCacheSerializer, clientId: string, account: IAccount, hasStateChanged: boolean, isApplicationCache: boolean, suggestedCacheKey: string, hasTokens: boolean, suggestedCacheExpiry: Nullable<DateTimeOffset>, cancellationToken: CancellationToken, correlationId: Guid, requestScopes: IEnumerable<System_Internal.String>, requestTenantId: string): TokenCacheNotificationArgs;
    new(tokenCache: ITokenCacheSerializer, clientId: string, account: IAccount, hasStateChanged: boolean, isApplicationCache: boolean, suggestedCacheKey: string, hasTokens: boolean, suggestedCacheExpiry: Nullable<DateTimeOffset>, cancellationToken: CancellationToken, correlationId: Guid, requestScopes: IEnumerable<System_Internal.String>, requestTenantId: string, identityLogger: IIdentityLogger, piiLoggingEnabled: boolean, telemetryData: TelemetryData): TokenCacheNotificationArgs;
};


export type TokenCacheNotificationArgs = TokenCacheNotificationArgs$instance;

export interface TraceTelemetryConfig$instance {
    readonly allowedScopes: IEnumerable<System_Internal.String>;
    readonly audienceType: TelemetryAudienceType;
    readonly dispatchAction: Action<ITelemetryEventPayload>;
    readonly sessionId: string;
}


export const TraceTelemetryConfig: {
    new(): TraceTelemetryConfig;
};


export interface __TraceTelemetryConfig$views {
    As_ITelemetryConfig(): ITelemetryConfig$instance;
}

export interface TraceTelemetryConfig$instance extends ITelemetryConfig$instance {}

export type TraceTelemetryConfig = TraceTelemetryConfig$instance & __TraceTelemetryConfig$views;


export interface UserAssertion$instance {
    readonly assertion: string;
    readonly assertionType: string;
}


export const UserAssertion: {
    new(jwtBearerToken: string): UserAssertion;
    new(assertion: string, assertionType: string): UserAssertion;
};


export type UserAssertion = UserAssertion$instance;

export interface WindowsBrokerOptions$instance {
    headerText: string;
    listWindowsWorkAndSchoolAccounts: boolean;
    msaPassthrough: boolean;
}


export const WindowsBrokerOptions: {
    new(): WindowsBrokerOptions;
};


export type WindowsBrokerOptions = WindowsBrokerOptions$instance;

export interface WwwAuthenticateParameters$instance {
    readonly authenticationScheme: string;
    authority: string;
    claims: string;
    error: string;
    readonly item: string;
    readonly nonce: string;
    resource: string;
    scopes: IEnumerable<System_Internal.String>;
    getTenantId(): string;
}


export const WwwAuthenticateParameters: {
    new(): WwwAuthenticateParameters;
    createFromAuthenticationHeaders(httpResponseHeaders: HttpResponseHeaders, scheme: string): WwwAuthenticateParameters;
    createFromAuthenticationHeaders(httpResponseHeaders: HttpResponseHeaders): IReadOnlyList<WwwAuthenticateParameters>;
    createFromAuthenticationResponseAsync(resourceUri: string, httpClient: HttpClient, cancellationToken?: CancellationToken): Task<IReadOnlyList<WwwAuthenticateParameters>>;
    createFromAuthenticationResponseAsync(resourceUri: string, scheme: string, httpClient: HttpClient, cancellationToken?: CancellationToken): Task<WwwAuthenticateParameters>;
    createFromAuthenticationResponseAsync(resourceUri: string, scheme: string, cancellationToken?: CancellationToken): Task<WwwAuthenticateParameters>;
    createFromAuthenticationResponseAsync(resourceUri: string, cancellationToken?: CancellationToken): Task<IReadOnlyList<WwwAuthenticateParameters>>;
    createFromResourceResponseAsync(httpClient: HttpClient, resourceUri: string, cancellationToken?: CancellationToken): Task<WwwAuthenticateParameters>;
    createFromResourceResponseAsync(resourceUri: string, cancellationToken?: CancellationToken): Task<WwwAuthenticateParameters>;
    createFromResourceResponseAsync(resourceUri: string): Task<WwwAuthenticateParameters>;
    createFromResponseHeaders(httpResponseHeaders: HttpResponseHeaders, scheme?: string): WwwAuthenticateParameters;
    createFromWwwAuthenticateHeaderValue(wwwAuthenticateValue: string): WwwAuthenticateParameters;
    getClaimChallengeFromResponseHeaders(httpResponseHeaders: HttpResponseHeaders, scheme?: string): string;
};


export type WwwAuthenticateParameters = WwwAuthenticateParameters$instance;

export abstract class AccountExtensions$instance {
    static getTenantProfiles(account: IAccount): IEnumerable<TenantProfile>;
}


export type AccountExtensions = AccountExtensions$instance;

export abstract class MsalError$instance {
    static readonly invalidGrantError: string;
    static readonly interactionRequired: string;
    static readonly noTokensFoundError: string;
    static readonly userNullError: string;
    static readonly userAssertionNullError: string;
    static readonly currentBrokerAccount: string;
    static readonly noAccountForLoginHint: string;
    static readonly multipleAccountsForLoginHint: string;
    static readonly tokenCacheNullError: string;
    static readonly noPromptFailedError: string;
    static readonly serviceNotAvailable: string;
    static readonly requestTimeout: string;
    static readonly requestThrottled: string;
    static readonly upnRequired: string;
    static readonly missingPassiveAuthEndpoint: string;
    static readonly invalidAuthority: string;
    static readonly invalidAuthorityType: string;
    static readonly missingTenantedAuthority: string;
    static readonly unauthorizedClient: string;
    static readonly unknownError: string;
    static readonly unknownBrokerError: string;
    static readonly wamFailedToSignout: string;
    static readonly authenticationFailed: string;
    static readonly authorityValidationFailed: string;
    static readonly invalidOwnerWindowType: string;
    static readonly encodedTokenTooLong: string;
    static readonly userMismatch: string;
    static readonly failedToRefreshToken: string;
    static readonly failedToAcquireTokenSilentlyFromBroker: string;
    static readonly redirectUriValidationFailed: string;
    static readonly authenticationUiFailed: string;
    static readonly internalError: string;
    static readonly accessingWsMetadataExchangeFailed: string;
    static readonly federatedServiceReturnedError: string;
    static readonly userRealmDiscoveryFailed: string;
    static readonly ropcDoesNotSupportMsaAccounts: string;
    static readonly missingFederationMetadataUrl: string;
    static readonly parsingWsMetadataExchangeFailed: string;
    static readonly wsTrustEndpointNotFoundInMetadataDocument: string;
    static readonly parsingWsTrustResponseFailed: string;
    static readonly integratedWindowsAuthenticationFailed: string;
    static readonly unknownUserType: string;
    static readonly unknownUser: string;
    static readonly getUserNameFailed: string;
    static readonly passwordRequiredForManagedUserError: string;
    static readonly invalidRequest: string;
    static readonly uapCannotFindDomainUser: string;
    static readonly uapCannotFindUpn: string;
    static readonly nonParsableOAuthError: string;
    static readonly codeExpired: string;
    static readonly integratedWindowsAuthNotSupportedForManagedUser: string;
    static readonly activityRequired: string;
    static readonly brokerResponseHashMismatch: string;
    static readonly brokerResponseReturnedError: string;
    static readonly brokerNonceMismatch: string;
    static readonly cannotInvokeBroker: string;
    static readonly noAndroidBrokerAccountFound: string;
    static readonly noAndroidBrokerInstalledOnDevice: string;
    static readonly nullIntentReturnedFromAndroidBroker: string;
    static readonly androidBrokerSignatureVerificationFailed: string;
    static readonly androidBrokerOperationFailed: string;
    static readonly noUsernameOrAccountIDProvidedForSilentAndroidBrokerAuthentication: string;
    static readonly httpStatusNotFound: string;
    static readonly httpStatusCodeNotOk: string;
    static readonly customWebUiReturnedInvalidUri: string;
    static readonly customWebUiRedirectUriMismatch: string;
    static readonly accessDenied: string;
    static readonly cannotAccessUserInformationOrUserNotDomainJoined: string;
    static readonly defaultRedirectUriIsInvalid: string;
    static readonly noRedirectUri: string;
    static readonly multipleTokensMatchedError: string;
    static readonly nonHttpsRedirectNotSupported: string;
    static readonly networkNotAvailableError: string;
    static readonly b2CAuthorityHostMismatch: string;
    static readonly authorityHostMismatch: string;
    static readonly duplicateQueryParameterError: string;
    static readonly authenticationUiFailedError: string;
    static readonly authenticationCanceledError: string;
    static readonly jsonParseError: string;
    static readonly invalidJwtError: string;
    static readonly stateMismatchError: string;
    static readonly tenantDiscoveryFailedError: string;
    static readonly platformNotSupported: string;
    static readonly invalidAuthorizationUri: string;
    static readonly loopbackRedirectUri: string;
    static readonly loopbackResponseUriMismatch: string;
    static readonly linuxXdgOpen: string;
    static readonly webviewUnavailable: string;
    static readonly systemWebviewOptionsNotApplicable: string;
    static readonly clientCredentialAuthenticationTypesAreMutuallyExclusive: string;
    static readonly clientCredentialAuthenticationTypeMustBeDefined: string;
    static readonly invalidInstance: string;
    static readonly invalidUserInstanceMetadata: string;
    static readonly validateAuthorityOrCustomMetadata: string;
    static readonly noClientId: string;
    static readonly telemetryConfigOrTelemetryCallback: string;
    static readonly invalidClient: string;
    static readonly sshCertUsedAsHttpHeader: string;
    static readonly wabError: string;
    static readonly tokenTypeMismatch: string;
    static readonly accessTokenTypeMissing: string;
    static readonly experimentalFeature: string;
    static readonly brokerApplicationRequired: string;
    static readonly failedToGetBrokerResponse: string;
    static readonly invalidJsonClaimsFormat: string;
    static readonly authorityTypeMismatch: string;
    static readonly authorityTenantSpecifiedTwice: string;
    static readonly customMetadataInstanceOrUri: string;
    static readonly scopesRequired: string;
    static readonly certWithoutPrivateKey: string;
    static readonly certificateNotRsa: string;
    static readonly deviceCertificateNotFound: string;
    static readonly invalidAdalCacheMultipleRTs: string;
    static readonly regionDiscoveryFailed: string;
    static readonly regionDiscoveryNotEnabled: string;
    static readonly brokerDoesNotSupportPop: string;
    static readonly brokerRequiredForPop: string;
    static readonly adfsNotSupportedWithBroker: string;
    static readonly nonceRequiredForPopOnPCA: string;
    static readonly wamUiThread: string;
    static readonly wamNoB2C: string;
    static readonly wamInteractiveError: string;
    static readonly wamPickerError: string;
    static readonly wamScopesRequired: string;
    static readonly webView2NotInstalled: string;
    static readonly webView2LoaderNotFound: string;
    static readonly regionalAuthorityValidation: string;
    static readonly regionDiscoveryWithCustomInstanceMetadata: string;
    static readonly httpListenerError: string;
    static readonly initializeProcessSecurityError: string;
    static readonly staticCacheWithExternalSerialization: string;
    static readonly tenantOverrideNonAad: string;
    static readonly regionalAndAuthorityOverride: string;
    static readonly oboCacheKeyNotInCacheError: string;
    static readonly invalidTokenProviderResponseValue: string;
    static readonly unableToParseAuthenticationHeader: string;
    static readonly invalidManagedIdentityResponse: string;
    static readonly managedIdentityRequestFailed: string;
    static readonly managedIdentityResponseParseFailure: string;
    static readonly managedIdentityUnreachableNetwork: string;
    static readonly unknownManagedIdentityError: string;
    static readonly invalidManagedIdentityEndpoint: string;
    static readonly exactlyOneScopeExpected: string;
    static readonly userAssignedManagedIdentityNotSupported: string;
    static readonly userAssignedManagedIdentityNotConfigurableAtRuntime: string;
    static readonly combinedUserAppCacheNotSupported: string;
    static readonly setCiamAuthorityAtRequestLevelNotSupported: string;
    static readonly cryptographicError: string;
    static readonly mtlsPopWithoutRegion: string;
    static readonly mtlsCertificateNotProvided: string;
    static readonly regionRequiredForMtlsPop: string;
    static readonly forceRefreshNotCompatibleWithTokenHash: string;
}


export type MsalError = MsalError$instance;

export abstract class OsCapabilitiesExtensions$instance {
    static getCertificate(confidentialClientApplication: IConfidentialClientApplication): X509Certificate2;
    static isEmbeddedWebViewAvailable(publicClientApplication: IPublicClientApplication): boolean;
    static isSystemWebViewAvailable(publicClientApplication: IPublicClientApplication): boolean;
    static isUserInteractive(publicClientApplication: IPublicClientApplication): boolean;
}


export type OsCapabilitiesExtensions = OsCapabilitiesExtensions$instance;

export abstract class PublicClientApplicationExtensions$instance {
    static isProofOfPossessionSupportedByClient(app: IPublicClientApplication): boolean;
}


export type PublicClientApplicationExtensions = PublicClientApplicationExtensions$instance;

export abstract class TokenCacheExtensions$instance {
    static setCacheOptions(tokenCache: ITokenCache, options: CacheOptions): void;
}


export type TokenCacheExtensions = TokenCacheExtensions$instance;


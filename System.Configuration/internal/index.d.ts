// Generated by tsbindgen - Architecture
// Namespace: System.Configuration
// Assembly: System.Configuration.ConfigurationManager

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import * as System_Configuration_Internal_Internal from "../../System.Configuration.Internal/internal/index.js";
import type { IConfigErrorInfo } from "../../System.Configuration.Internal/internal/index.js";
import * as System_Configuration_Provider_Internal from "../../System.Configuration.Provider/internal/index.js";
import type { ProviderBase, ProviderCollection } from "../../System.Configuration.Provider/internal/index.js";
import type { UriIdnScope } from "../../System/internal/index.js";
import * as System_Collections_Internal from "@tsonic/dotnet/System.Collections.js";
import type { Hashtable, ICollection, IDictionary, IEnumerable, IEnumerator, IList, ReadOnlyCollectionBase } from "@tsonic/dotnet/System.Collections.js";
import * as System_Collections_Specialized_Internal from "@tsonic/dotnet/System.Collections.Specialized.js";
import type { NameObjectCollectionBase, NameValueCollection, StringCollection } from "@tsonic/dotnet/System.Collections.Specialized.js";
import * as System_ComponentModel_Internal from "@tsonic/dotnet/System.ComponentModel.js";
import type { CancelEventArgs, INotifyPropertyChanged, ITypeDescriptorContext, PropertyChangedEventHandler, TypeConverter } from "@tsonic/dotnet/System.ComponentModel.js";
import type { CultureInfo } from "@tsonic/dotnet/System.Globalization.js";
import * as System_Lib from "@tsonic/dotnet/System.js";
import type { Array as ClrArray, AsyncCallback, Attribute, Boolean as ClrBoolean, Enum, EventArgs, Exception, Func, GenericUriParserOptions, IAsyncResult, ICloneable, IComparable, IConvertible, IFormattable, Int32, Int64, IntPtr, ISpanFormattable, MulticastDelegate, Object as ClrObject, String as ClrString, SystemException, TimeSpan, Type, Void } from "@tsonic/dotnet/System.js";
import * as System_Runtime_Serialization_Internal from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { IDeserializationCallback, ISerializable, SerializationInfo, StreamingContext } from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { FrameworkName } from "@tsonic/dotnet/System.Runtime.Versioning.js";
import type { RSAParameters } from "@tsonic/dotnet/System.Security.Cryptography.js";
import * as System_Xml_Internal from "@tsonic/dotnet/System.Xml.js";
import type { XmlAttribute, XmlCDataSection, XmlComment, XmlDocument, XmlElement, XmlNode, XmlReader, XmlSignificantWhitespace, XmlText, XmlTextReader, XmlWhitespace } from "@tsonic/dotnet/System.Xml.js";
import * as System_Xml_XPath_Internal from "@tsonic/dotnet/System.Xml.XPath.js";
import type { IXPathNavigable } from "@tsonic/dotnet/System.Xml.XPath.js";

export enum ConfigurationAllowDefinition {
    machineOnly = 0,
    machineToWebRoot = 100,
    machineToApplication = 200,
    everywhere = 300
}


export enum ConfigurationAllowExeDefinition {
    machineOnly = 0,
    machineToApplication = 100,
    machineToRoamingUser = 200,
    machineToLocalUser = 300
}


export enum ConfigurationElementCollectionType {
    basicMap = 0,
    addRemoveClearMap = 1,
    basicMapAlternate = 2,
    addRemoveClearMapAlternate = 3
}


export enum ConfigurationPropertyOptions {
    none = 0,
    isDefaultCollection = 1,
    isRequired = 2,
    isKey = 4,
    isTypeStringTransformationRequired = 8,
    isAssemblyStringTransformationRequired = 16,
    isVersionCheckRequired = 32
}


export enum ConfigurationSaveMode {
    modified = 0,
    minimal = 1,
    full = 2
}


export enum ConfigurationUserLevel {
    none = 0,
    perUserRoaming = 10,
    perUserRoamingAndLocal = 20
}


export enum OverrideMode {
    inherit = 0,
    allow = 1,
    deny = 2
}


export enum PropertyValueOrigin {
    default = 0,
    inherited = 1,
    setHere = 2
}


export enum SettingsManageability {
    roaming = 0
}


export enum SettingsSerializeAs {
    string = 0,
    xml = 1,
    binary = 2,
    providerSpecific = 3
}


export enum SpecialSetting {
    connectionString = 0,
    webServiceUrl = 1
}


export type SettingChangingEventHandler = (sender: unknown, e: SettingChangingEventArgs) => void;


export type SettingsLoadedEventHandler = (sender: unknown, e: SettingsLoadedEventArgs) => void;


export type SettingsSavingEventHandler = (sender: unknown, e: CancelEventArgs) => void;


export type ValidatorCallback = (value: unknown) => void;


export interface IApplicationSettingsProvider$instance {
    getPreviousVersion(context: SettingsContext, property: SettingsProperty): SettingsPropertyValue;
    reset(context: SettingsContext): void;
    upgrade(context: SettingsContext, properties: SettingsPropertyCollection): void;
}


export type IApplicationSettingsProvider = IApplicationSettingsProvider$instance;

export interface IConfigurationSectionHandler$instance {
    create(parent: unknown, configContext: unknown, section: XmlNode): unknown;
}


export type IConfigurationSectionHandler = IConfigurationSectionHandler$instance;

export interface IConfigurationSystem$instance {
    getConfig(configKey: string): unknown;
    init(): void;
}


export type IConfigurationSystem = IConfigurationSystem$instance;

export interface IPersistComponentSettings$instance {
    saveSettings: boolean;
    settingsKey: string;
    loadComponentSettings(): void;
}


export type IPersistComponentSettings = IPersistComponentSettings$instance;

export interface ISettingsProviderService$instance {
    getSettingsProvider(property: SettingsProperty): SettingsProvider;
}


export type ISettingsProviderService = ISettingsProviderService$instance;

export interface ApplicationScopedSettingAttribute$instance extends SettingAttribute {
}


export const ApplicationScopedSettingAttribute: {
    new(): ApplicationScopedSettingAttribute;
};


export type ApplicationScopedSettingAttribute = ApplicationScopedSettingAttribute$instance;

export interface ApplicationSettingsBase$instance extends SettingsBase {
    readonly context: SettingsContext;
    item: unknown;
    readonly properties: SettingsPropertyCollection;
    readonly propertyValues: SettingsPropertyValueCollection;
    readonly providers: SettingsProviderCollection;
    settingsKey: string;
    getPreviousVersion(propertyName: string): unknown;
    reload(): void;
    reset(): void;
    save(): void;
    upgrade(): void;
}


export const ApplicationSettingsBase: {
};


export type ApplicationSettingsBase = ApplicationSettingsBase$instance;

export interface ApplicationSettingsGroup$instance extends ConfigurationSectionGroup {
}


export const ApplicationSettingsGroup: {
    new(): ApplicationSettingsGroup;
};


export type ApplicationSettingsGroup = ApplicationSettingsGroup$instance;

export interface AppSettingsReader$instance {
    getValue(key: string, type: Type): unknown;
}


export const AppSettingsReader: {
    new(): AppSettingsReader;
};


export type AppSettingsReader = AppSettingsReader$instance;

export interface AppSettingsSection$instance extends ConfigurationSection {
    file: string;
    readonly settings: KeyValueConfigurationCollection;
}


export const AppSettingsSection: {
    new(): AppSettingsSection;
};


export type AppSettingsSection = AppSettingsSection$instance;

export interface CallbackValidator$instance extends ConfigurationValidatorBase {
    canValidate(type: Type): boolean;
    validate(value: unknown): void;
}


export const CallbackValidator: {
    new(type: Type, callback: ValidatorCallback): CallbackValidator;
};


export type CallbackValidator = CallbackValidator$instance;

export interface CallbackValidatorAttribute$instance extends ConfigurationValidatorAttribute {
    callbackMethodName: string;
    type: Type;
    readonly validatorInstance: ConfigurationValidatorBase;
}


export const CallbackValidatorAttribute: {
    new(): CallbackValidatorAttribute;
};


export type CallbackValidatorAttribute = CallbackValidatorAttribute$instance;

export interface ClientSettingsSection$instance extends ConfigurationSection {
    readonly settings: SettingElementCollection;
}


export const ClientSettingsSection: {
    new(): ClientSettingsSection;
};


export type ClientSettingsSection = ClientSettingsSection$instance;

export interface CommaDelimitedStringCollection$instance extends StringCollection {
    readonly isModified: boolean;
    readonly isReadOnly: boolean;
    item: string;
    add(value: string): void;
    addRange(range: string[]): void;
    clear(): void;
    clone(): CommaDelimitedStringCollection;
    insert(index: int, value: string): void;
    remove(value: string): void;
    setReadOnly(): void;
    toString(): string | undefined;
}


export const CommaDelimitedStringCollection: {
    new(): CommaDelimitedStringCollection;
};


export type CommaDelimitedStringCollection = CommaDelimitedStringCollection$instance;

export interface CommaDelimitedStringCollectionConverter$instance extends ConfigurationConverterBase {
    convertFrom(ctx: ITypeDescriptorContext, ci: CultureInfo, data: unknown): unknown;
    convertTo(ctx: ITypeDescriptorContext, ci: CultureInfo, value: unknown, type: Type): unknown;
}


export const CommaDelimitedStringCollectionConverter: {
    new(): CommaDelimitedStringCollectionConverter;
};


export type CommaDelimitedStringCollectionConverter = CommaDelimitedStringCollectionConverter$instance;

export interface Configuration$instance {
    readonly appSettings: AppSettingsSection;
    assemblyStringTransformer: Func<System_Internal.String, System_Internal.String>;
    readonly connectionStrings: ConnectionStringsSection;
    readonly evaluationContext: ContextInformation;
    readonly filePath: string;
    readonly hasFile: boolean;
    readonly locations: ConfigurationLocationCollection;
    namespaceDeclared: boolean;
    readonly rootSectionGroup: ConfigurationSectionGroup;
    readonly sectionGroups: ConfigurationSectionGroupCollection;
    readonly sections: ConfigurationSectionCollection;
    targetFramework: FrameworkName;
    typeStringTransformer: Func<System_Internal.String, System_Internal.String>;
    getSection(sectionName: string): ConfigurationSection;
    getSectionGroup(sectionGroupName: string): ConfigurationSectionGroup;
    save(): void;
    save(saveMode: ConfigurationSaveMode): void;
    save(saveMode: ConfigurationSaveMode, forceSaveAll: boolean): void;
    saveAs(filename: string): void;
    saveAs(filename: string, saveMode: ConfigurationSaveMode): void;
    saveAs(filename: string, saveMode: ConfigurationSaveMode, forceSaveAll: boolean): void;
}


export const Configuration: {
    new(): Configuration;
};


export type Configuration = Configuration$instance;

export interface ConfigurationCollectionAttribute$instance extends Attribute {
    addItemName: string;
    clearItemsName: string;
    collectionType: ConfigurationElementCollectionType;
    readonly itemType: Type;
    removeItemName: string;
}


export const ConfigurationCollectionAttribute: {
    new(itemType: Type): ConfigurationCollectionAttribute;
};


export type ConfigurationCollectionAttribute = ConfigurationCollectionAttribute$instance;

export interface ConfigurationConverterBase$instance extends TypeConverter {
    canConvertFrom(ctx: ITypeDescriptorContext, type: Type): boolean;
    canConvertTo(ctx: ITypeDescriptorContext, type: Type): boolean;
}


export const ConfigurationConverterBase: {
};


export type ConfigurationConverterBase = ConfigurationConverterBase$instance;

export interface ConfigurationElement$instance {
    readonly currentConfiguration: Configuration;
    readonly elementInformation: ElementInformation;
    readonly lockAllAttributesExcept: ConfigurationLockCollection;
    readonly lockAllElementsExcept: ConfigurationLockCollection;
    readonly lockAttributes: ConfigurationLockCollection;
    readonly lockElements: ConfigurationLockCollection;
    lockItem: boolean;
    equals(compareTo: unknown): boolean;
    getHashCode(): int;
    isReadOnly(): boolean;
}


export const ConfigurationElement: {
};


export type ConfigurationElement = ConfigurationElement$instance;

export interface ConfigurationElementCollection$instance extends ConfigurationElement {
    readonly collectionType: ConfigurationElementCollectionType;
    readonly count: int;
    emitClear: boolean;
    readonly isSynchronized: boolean;
    readonly syncRoot: unknown;
    copyTo(array: ConfigurationElement[], index: int): void;
    equals(compareTo: unknown): boolean;
    getEnumerator(): IEnumerator;
    getHashCode(): int;
    isReadOnly(): boolean;
}


export const ConfigurationElementCollection: {
};


export type ConfigurationElementCollection = ConfigurationElementCollection$instance;

export interface ConfigurationElementProperty$instance {
    readonly validator: ConfigurationValidatorBase;
}


export const ConfigurationElementProperty: {
    new(validator: ConfigurationValidatorBase): ConfigurationElementProperty;
};


export type ConfigurationElementProperty = ConfigurationElementProperty$instance;

export interface ConfigurationErrorsException$instance extends ConfigurationException {
    readonly errors: ICollection;
    readonly filename: string;
    readonly line: int;
    readonly message: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const ConfigurationErrorsException: {
    new(message: string, inner: Exception, filename: string, line: int): ConfigurationErrorsException;
    new(): ConfigurationErrorsException;
    new(message: string): ConfigurationErrorsException;
    new(message: string, inner: Exception): ConfigurationErrorsException;
    new(message: string, filename: string, line: int): ConfigurationErrorsException;
    new(message: string, node: XmlNode): ConfigurationErrorsException;
    new(message: string, inner: Exception, node: XmlNode): ConfigurationErrorsException;
    new(message: string, reader: XmlReader): ConfigurationErrorsException;
    new(message: string, inner: Exception, reader: XmlReader): ConfigurationErrorsException;
    getFilename(node: XmlNode): string;
    getFilename(reader: XmlReader): string;
    getLineNumber(node: XmlNode): int;
    getLineNumber(reader: XmlReader): int;
};


export type ConfigurationErrorsException = ConfigurationErrorsException$instance;

export interface ConfigurationException$instance extends SystemException {
    readonly bareMessage: string;
    readonly filename: string;
    readonly line: int;
    readonly message: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const ConfigurationException: {
    new(): ConfigurationException;
    new(message: string): ConfigurationException;
    new(message: string, inner: Exception): ConfigurationException;
    new(message: string, node: XmlNode): ConfigurationException;
    new(message: string, inner: Exception, node: XmlNode): ConfigurationException;
    new(message: string, filename: string, line: int): ConfigurationException;
    new(message: string, inner: Exception, filename: string, line: int): ConfigurationException;
    getXmlNodeFilename(node: XmlNode): string;
    getXmlNodeLineNumber(node: XmlNode): int;
};


export type ConfigurationException = ConfigurationException$instance;

export interface ConfigurationFileMap$instance {
    machineConfigFilename: string;
    clone(): unknown;
}


export const ConfigurationFileMap: {
    new(): ConfigurationFileMap;
    new(machineConfigFilename: string): ConfigurationFileMap;
};


export type ConfigurationFileMap = ConfigurationFileMap$instance;

export interface ConfigurationLocation$instance {
    readonly path: string;
    openConfiguration(): Configuration;
}


export const ConfigurationLocation: {
    new(): ConfigurationLocation;
};


export type ConfigurationLocation = ConfigurationLocation$instance;

export interface ConfigurationLocationCollection$instance extends ReadOnlyCollectionBase {
    readonly item: ConfigurationLocation;
}


export const ConfigurationLocationCollection: {
    new(): ConfigurationLocationCollection;
};


export type ConfigurationLocationCollection = ConfigurationLocationCollection$instance;

export interface ConfigurationLockCollection$instance {
    readonly attributeList: string;
    readonly count: int;
    readonly hasParentElements: boolean;
    readonly isModified: boolean;
    readonly isSynchronized: boolean;
    readonly syncRoot: unknown;
    add(name: string): void;
    clear(): void;
    contains(name: string): boolean;
    copyTo(array: string[], index: int): void;
    getEnumerator(): IEnumerator;
    isReadOnly(name: string): boolean;
    remove(name: string): void;
    setFromList(attributeList: string): void;
}


export const ConfigurationLockCollection: {
    new(): ConfigurationLockCollection;
};


export type ConfigurationLockCollection = ConfigurationLockCollection$instance;

export interface ConfigurationProperty$instance {
    readonly converter: TypeConverter;
    readonly defaultValue: unknown;
    readonly description: string;
    readonly isAssemblyStringTransformationRequired: boolean;
    readonly isDefaultCollection: boolean;
    readonly isKey: boolean;
    readonly isRequired: boolean;
    readonly isTypeStringTransformationRequired: boolean;
    readonly isVersionCheckRequired: boolean;
    readonly name: string;
    readonly type: Type;
    readonly validator: ConfigurationValidatorBase;
}


export const ConfigurationProperty: {
    new(name: string, type: Type): ConfigurationProperty;
    new(name: string, type: Type, defaultValue: unknown): ConfigurationProperty;
    new(name: string, type: Type, defaultValue: unknown, options: ConfigurationPropertyOptions): ConfigurationProperty;
    new(name: string, type: Type, defaultValue: unknown, typeConverter: TypeConverter, validator: ConfigurationValidatorBase, options: ConfigurationPropertyOptions): ConfigurationProperty;
    new(name: string, type: Type, defaultValue: unknown, typeConverter: TypeConverter, validator: ConfigurationValidatorBase, options: ConfigurationPropertyOptions, description: string): ConfigurationProperty;
};


export type ConfigurationProperty = ConfigurationProperty$instance;

export interface ConfigurationPropertyAttribute$instance extends Attribute {
    defaultValue: unknown;
    isDefaultCollection: boolean;
    isKey: boolean;
    isRequired: boolean;
    readonly name: string;
    options: ConfigurationPropertyOptions;
}


export const ConfigurationPropertyAttribute: {
    new(name: string): ConfigurationPropertyAttribute;
};


export type ConfigurationPropertyAttribute = ConfigurationPropertyAttribute$instance;

export interface ConfigurationPropertyCollection$instance {
    readonly count: int;
    readonly isSynchronized: boolean;
    readonly item: ConfigurationProperty;
    readonly syncRoot: unknown;
    add(property: ConfigurationProperty): void;
    clear(): void;
    contains(name: string): boolean;
    copyTo(array: ConfigurationProperty[], index: int): void;
    getEnumerator(): IEnumerator;
    remove(name: string): boolean;
}


export const ConfigurationPropertyCollection: {
    new(): ConfigurationPropertyCollection;
};


export type ConfigurationPropertyCollection = ConfigurationPropertyCollection$instance;

export interface ConfigurationSection$instance extends ConfigurationElement {
    readonly sectionInformation: SectionInformation;
}


export const ConfigurationSection: {
};


export type ConfigurationSection = ConfigurationSection$instance;

export interface ConfigurationSectionCollection$instance extends NameObjectCollectionBase {
    add(name: string, section: ConfigurationSection): void;
    clear(): void;
    copyTo(array: ConfigurationSection[], index: int): void;
    get(index: int): ConfigurationSection;
    get(name: string): ConfigurationSection;
    get_Item(name: string): ConfigurationSection;
    get_Item(index: int): ConfigurationSection;
    getEnumerator(): IEnumerator;
    getKey(index: int): string;
    remove(name: string): void;
    removeAt(index: int): void;
}


export const ConfigurationSectionCollection: {
    new(): ConfigurationSectionCollection;
};


export type ConfigurationSectionCollection = ConfigurationSectionCollection$instance;

export interface ConfigurationSectionGroup$instance {
    readonly isDeclarationRequired: boolean;
    readonly isDeclared: boolean;
    readonly name: string;
    readonly sectionGroupName: string;
    readonly sectionGroups: ConfigurationSectionGroupCollection;
    readonly sections: ConfigurationSectionCollection;
    type: string;
    forceDeclaration(): void;
    forceDeclaration(force: boolean): void;
}


export const ConfigurationSectionGroup: {
    new(): ConfigurationSectionGroup;
};


export type ConfigurationSectionGroup = ConfigurationSectionGroup$instance;

export interface ConfigurationSectionGroupCollection$instance extends NameObjectCollectionBase {
    add(name: string, sectionGroup: ConfigurationSectionGroup): void;
    clear(): void;
    copyTo(array: ConfigurationSectionGroup[], index: int): void;
    get(index: int): ConfigurationSectionGroup;
    get(name: string): ConfigurationSectionGroup;
    get_Item(name: string): ConfigurationSectionGroup;
    get_Item(index: int): ConfigurationSectionGroup;
    getEnumerator(): IEnumerator;
    getKey(index: int): string;
    remove(name: string): void;
    removeAt(index: int): void;
}


export const ConfigurationSectionGroupCollection: {
    new(): ConfigurationSectionGroupCollection;
};


export type ConfigurationSectionGroupCollection = ConfigurationSectionGroupCollection$instance;

export interface ConfigurationSettings$instance {
}


export const ConfigurationSettings: {
    new(): ConfigurationSettings;
    readonly appSettings: NameValueCollection;
    getConfig(sectionName: string): unknown;
};


export type ConfigurationSettings = ConfigurationSettings$instance;

export interface ConfigurationValidatorAttribute$instance extends Attribute {
    readonly validatorInstance: ConfigurationValidatorBase;
    readonly validatorType: Type;
}


export const ConfigurationValidatorAttribute: {
    new(validator: Type): ConfigurationValidatorAttribute;
};


export type ConfigurationValidatorAttribute = ConfigurationValidatorAttribute$instance;

export interface ConfigurationValidatorBase$instance {
    canValidate(type: Type): boolean;
    validate(value: unknown): void;
}


export const ConfigurationValidatorBase: {
};


export type ConfigurationValidatorBase = ConfigurationValidatorBase$instance;

export interface ConfigXmlDocument$instance extends XmlDocument {
    readonly filename: string;
    readonly lineNumber: int;
    createAttribute(prefix: string, localName: string, namespaceUri: string): XmlAttribute;
    createCDataSection(data: string): XmlCDataSection;
    createComment(data: string): XmlComment;
    createElement(prefix: string, localName: string, namespaceUri: string): XmlElement;
    createSignificantWhitespace(data: string): XmlSignificantWhitespace;
    createTextNode(text: string): XmlText;
    createWhitespace(data: string): XmlWhitespace;
    load(filename: string): void;
    loadSingleElement(filename: string, sourceReader: XmlTextReader): void;
}


export const ConfigXmlDocument: {
    new(): ConfigXmlDocument;
};


export interface __ConfigXmlDocument$views {
    As_IConfigErrorInfo(): System_Configuration_Internal_Internal.IConfigErrorInfo$instance;
}

export interface ConfigXmlDocument$instance extends System_Configuration_Internal_Internal.IConfigErrorInfo$instance {}

export type ConfigXmlDocument = ConfigXmlDocument$instance & __ConfigXmlDocument$views;


export interface ConnectionStringSettings$instance extends ConfigurationElement {
    connectionString: string;
    name: string;
    providerName: string;
    toString(): string | undefined;
}


export const ConnectionStringSettings: {
    new(): ConnectionStringSettings;
    new(name: string, connectionString: string): ConnectionStringSettings;
    new(name: string, connectionString: string, providerName: string): ConnectionStringSettings;
};


export type ConnectionStringSettings = ConnectionStringSettings$instance;

export interface ConnectionStringSettingsCollection$instance extends ConfigurationElementCollection {
    add(settings: ConnectionStringSettings): void;
    clear(): void;
    get_Item(index: int): ConnectionStringSettings;
    get_Item(name: string): ConnectionStringSettings;
    indexOf(settings: ConnectionStringSettings): int;
    remove(settings: ConnectionStringSettings): void;
    remove(name: string): void;
    removeAt(index: int): void;
    set_Item(index: int, value: ConnectionStringSettings): void;
}


export const ConnectionStringSettingsCollection: {
    new(): ConnectionStringSettingsCollection;
};


export type ConnectionStringSettingsCollection = ConnectionStringSettingsCollection$instance;

export interface ConnectionStringsSection$instance extends ConfigurationSection {
    readonly connectionStrings: ConnectionStringSettingsCollection;
}


export const ConnectionStringsSection: {
    new(): ConnectionStringsSection;
};


export type ConnectionStringsSection = ConnectionStringsSection$instance;

export interface ContextInformation$instance {
    readonly hostingContext: unknown;
    readonly isMachineLevel: boolean;
    getSection(sectionName: string): unknown;
}


export const ContextInformation: {
    new(): ContextInformation;
};


export type ContextInformation = ContextInformation$instance;

export interface DefaultSection$instance extends ConfigurationSection {
}


export const DefaultSection: {
    new(): DefaultSection;
};


export type DefaultSection = DefaultSection$instance;

export interface DefaultSettingValueAttribute$instance extends Attribute {
    readonly value: string;
}


export const DefaultSettingValueAttribute: {
    new(value: string): DefaultSettingValueAttribute;
};


export type DefaultSettingValueAttribute = DefaultSettingValueAttribute$instance;

export interface DefaultValidator$instance extends ConfigurationValidatorBase {
    canValidate(type: Type): boolean;
    validate(value: unknown): void;
}


export const DefaultValidator: {
    new(): DefaultValidator;
};


export type DefaultValidator = DefaultValidator$instance;

export interface DictionarySectionHandler$instance {
    create(parent: unknown, context: unknown, section: XmlNode): unknown;
}


export const DictionarySectionHandler: {
    new(): DictionarySectionHandler;
};


export interface __DictionarySectionHandler$views {
    As_IConfigurationSectionHandler(): IConfigurationSectionHandler$instance;
}

export interface DictionarySectionHandler$instance extends IConfigurationSectionHandler$instance {}

export type DictionarySectionHandler = DictionarySectionHandler$instance & __DictionarySectionHandler$views;


export interface DpapiProtectedConfigurationProvider$instance extends ProtectedConfigurationProvider {
    readonly useMachineProtection: boolean;
    decrypt(encryptedNode: XmlNode): XmlNode;
    encrypt(node: XmlNode): XmlNode;
    initialize(name: string, configurationValues: NameValueCollection): void;
}


export const DpapiProtectedConfigurationProvider: {
    new(): DpapiProtectedConfigurationProvider;
};


export type DpapiProtectedConfigurationProvider = DpapiProtectedConfigurationProvider$instance;

export interface ElementInformation$instance {
    readonly errors: ICollection;
    readonly isCollection: boolean;
    readonly isLocked: boolean;
    readonly isPresent: boolean;
    readonly lineNumber: int;
    readonly properties: PropertyInformationCollection;
    readonly source: string;
    readonly type: Type;
    readonly validator: ConfigurationValidatorBase;
}


export const ElementInformation: {
    new(): ElementInformation;
};


export type ElementInformation = ElementInformation$instance;

export interface ExeConfigurationFileMap$instance extends ConfigurationFileMap {
    exeConfigFilename: string;
    localUserConfigFilename: string;
    roamingUserConfigFilename: string;
    clone(): unknown;
}


export const ExeConfigurationFileMap: {
    new(): ExeConfigurationFileMap;
    new(machineConfigFileName: string): ExeConfigurationFileMap;
};


export type ExeConfigurationFileMap = ExeConfigurationFileMap$instance;

export interface ExeContext$instance {
    readonly exePath: string;
    readonly userLevel: ConfigurationUserLevel;
}


export const ExeContext: {
    new(): ExeContext;
};


export type ExeContext = ExeContext$instance;

export interface GenericEnumConverter$instance extends ConfigurationConverterBase {
    convertFrom(ctx: ITypeDescriptorContext, ci: CultureInfo, data: unknown): unknown;
    convertTo(ctx: ITypeDescriptorContext, ci: CultureInfo, value: unknown, type: Type): unknown;
}


export const GenericEnumConverter: {
    new(typeEnum: Type): GenericEnumConverter;
};


export type GenericEnumConverter = GenericEnumConverter$instance;

export interface IdnElement$instance extends ConfigurationElement {
    enabled: UriIdnScope;
}


export const IdnElement: {
    new(): IdnElement;
};


export type IdnElement = IdnElement$instance;

export interface IgnoreSection$instance extends ConfigurationSection {
}


export const IgnoreSection: {
    new(): IgnoreSection;
};


export type IgnoreSection = IgnoreSection$instance;

export interface IgnoreSectionHandler$instance {
    create(parent: unknown, configContext: unknown, section: XmlNode): unknown;
}


export const IgnoreSectionHandler: {
    new(): IgnoreSectionHandler;
};


export interface __IgnoreSectionHandler$views {
    As_IConfigurationSectionHandler(): IConfigurationSectionHandler$instance;
}

export interface IgnoreSectionHandler$instance extends IConfigurationSectionHandler$instance {}

export type IgnoreSectionHandler = IgnoreSectionHandler$instance & __IgnoreSectionHandler$views;


export interface InfiniteIntConverter$instance extends ConfigurationConverterBase {
    convertFrom(ctx: ITypeDescriptorContext, ci: CultureInfo, data: unknown): unknown;
    convertTo(ctx: ITypeDescriptorContext, ci: CultureInfo, value: unknown, type: Type): unknown;
}


export const InfiniteIntConverter: {
    new(): InfiniteIntConverter;
};


export type InfiniteIntConverter = InfiniteIntConverter$instance;

export interface InfiniteTimeSpanConverter$instance extends ConfigurationConverterBase {
    convertFrom(ctx: ITypeDescriptorContext, ci: CultureInfo, data: unknown): unknown;
    convertTo(ctx: ITypeDescriptorContext, ci: CultureInfo, value: unknown, type: Type): unknown;
}


export const InfiniteTimeSpanConverter: {
    new(): InfiniteTimeSpanConverter;
};


export type InfiniteTimeSpanConverter = InfiniteTimeSpanConverter$instance;

export interface IntegerValidator$instance extends ConfigurationValidatorBase {
    canValidate(type: Type): boolean;
    validate(value: unknown): void;
}


export const IntegerValidator: {
    new(minValue: int, maxValue: int): IntegerValidator;
    new(minValue: int, maxValue: int, rangeIsExclusive: boolean): IntegerValidator;
    new(minValue: int, maxValue: int, rangeIsExclusive: boolean, resolution: int): IntegerValidator;
};


export type IntegerValidator = IntegerValidator$instance;

export interface IntegerValidatorAttribute$instance extends ConfigurationValidatorAttribute {
    excludeRange: boolean;
    maxValue: int;
    minValue: int;
    readonly validatorInstance: ConfigurationValidatorBase;
}


export const IntegerValidatorAttribute: {
    new(): IntegerValidatorAttribute;
};


export type IntegerValidatorAttribute = IntegerValidatorAttribute$instance;

export interface IriParsingElement$instance extends ConfigurationElement {
    enabled: boolean;
}


export const IriParsingElement: {
    new(): IriParsingElement;
};


export type IriParsingElement = IriParsingElement$instance;

export interface KeyValueConfigurationCollection$instance extends ConfigurationElementCollection {
    readonly allKeys: string[];
    readonly item: KeyValueConfigurationElement;
    add(keyValue: KeyValueConfigurationElement): void;
    add(key: string, value: string): void;
    clear(): void;
    remove(key: string): void;
}


export const KeyValueConfigurationCollection: {
    new(): KeyValueConfigurationCollection;
};


export type KeyValueConfigurationCollection = KeyValueConfigurationCollection$instance;

export interface KeyValueConfigurationElement$instance extends ConfigurationElement {
    readonly key: string;
    value: string;
}


export const KeyValueConfigurationElement: {
    new(key: string, value: string): KeyValueConfigurationElement;
};


export type KeyValueConfigurationElement = KeyValueConfigurationElement$instance;

export interface LocalFileSettingsProvider$instance extends SettingsProvider {
    applicationName: string;
    getPreviousVersion(context: SettingsContext, property: SettingsProperty): SettingsPropertyValue;
    getPropertyValues(context: SettingsContext, properties: SettingsPropertyCollection): SettingsPropertyValueCollection;
    initialize(name: string, values: NameValueCollection): void;
    reset(context: SettingsContext): void;
    setPropertyValues(context: SettingsContext, values: SettingsPropertyValueCollection): void;
    upgrade(context: SettingsContext, properties: SettingsPropertyCollection): void;
}


export const LocalFileSettingsProvider: {
    new(): LocalFileSettingsProvider;
};


export interface __LocalFileSettingsProvider$views {
    As_IApplicationSettingsProvider(): IApplicationSettingsProvider$instance;
}

export interface LocalFileSettingsProvider$instance extends IApplicationSettingsProvider$instance {}

export type LocalFileSettingsProvider = LocalFileSettingsProvider$instance & __LocalFileSettingsProvider$views;


export interface LongValidator$instance extends ConfigurationValidatorBase {
    canValidate(type: Type): boolean;
    validate(value: unknown): void;
}


export const LongValidator: {
    new(minValue: long, maxValue: long): LongValidator;
    new(minValue: long, maxValue: long, rangeIsExclusive: boolean): LongValidator;
    new(minValue: long, maxValue: long, rangeIsExclusive: boolean, resolution: long): LongValidator;
};


export type LongValidator = LongValidator$instance;

export interface LongValidatorAttribute$instance extends ConfigurationValidatorAttribute {
    excludeRange: boolean;
    maxValue: long;
    minValue: long;
    readonly validatorInstance: ConfigurationValidatorBase;
}


export const LongValidatorAttribute: {
    new(): LongValidatorAttribute;
};


export type LongValidatorAttribute = LongValidatorAttribute$instance;

export interface NameValueConfigurationCollection$instance extends ConfigurationElementCollection {
    readonly allKeys: string[];
    item: NameValueConfigurationElement;
    add(nameValue: NameValueConfigurationElement): void;
    clear(): void;
    remove(nameValue: NameValueConfigurationElement): void;
    remove(name: string): void;
}


export const NameValueConfigurationCollection: {
    new(): NameValueConfigurationCollection;
};


export type NameValueConfigurationCollection = NameValueConfigurationCollection$instance;

export interface NameValueConfigurationElement$instance extends ConfigurationElement {
    readonly name: string;
    value: string;
}


export const NameValueConfigurationElement: {
    new(name: string, value: string): NameValueConfigurationElement;
};


export type NameValueConfigurationElement = NameValueConfigurationElement$instance;

export interface NameValueFileSectionHandler$instance {
    create(parent: unknown, configContext: unknown, section: XmlNode): unknown;
}


export const NameValueFileSectionHandler: {
    new(): NameValueFileSectionHandler;
};


export interface __NameValueFileSectionHandler$views {
    As_IConfigurationSectionHandler(): IConfigurationSectionHandler$instance;
}

export interface NameValueFileSectionHandler$instance extends IConfigurationSectionHandler$instance {}

export type NameValueFileSectionHandler = NameValueFileSectionHandler$instance & __NameValueFileSectionHandler$views;


export interface NameValueSectionHandler$instance {
    create(parent: unknown, context: unknown, section: XmlNode): unknown;
}


export const NameValueSectionHandler: {
    new(): NameValueSectionHandler;
};


export interface __NameValueSectionHandler$views {
    As_IConfigurationSectionHandler(): IConfigurationSectionHandler$instance;
}

export interface NameValueSectionHandler$instance extends IConfigurationSectionHandler$instance {}

export type NameValueSectionHandler = NameValueSectionHandler$instance & __NameValueSectionHandler$views;


export interface NoSettingsVersionUpgradeAttribute$instance extends Attribute {
}


export const NoSettingsVersionUpgradeAttribute: {
    new(): NoSettingsVersionUpgradeAttribute;
};


export type NoSettingsVersionUpgradeAttribute = NoSettingsVersionUpgradeAttribute$instance;

export interface PositiveTimeSpanValidator$instance extends ConfigurationValidatorBase {
    canValidate(type: Type): boolean;
    validate(value: unknown): void;
}


export const PositiveTimeSpanValidator: {
    new(): PositiveTimeSpanValidator;
};


export type PositiveTimeSpanValidator = PositiveTimeSpanValidator$instance;

export interface PositiveTimeSpanValidatorAttribute$instance extends ConfigurationValidatorAttribute {
    readonly validatorInstance: ConfigurationValidatorBase;
}


export const PositiveTimeSpanValidatorAttribute: {
    new(): PositiveTimeSpanValidatorAttribute;
};


export type PositiveTimeSpanValidatorAttribute = PositiveTimeSpanValidatorAttribute$instance;

export interface PropertyInformation$instance {
    readonly converter: TypeConverter;
    readonly defaultValue: unknown;
    readonly description: string;
    readonly isKey: boolean;
    readonly isLocked: boolean;
    readonly isModified: boolean;
    readonly isRequired: boolean;
    readonly lineNumber: int;
    readonly name: string;
    readonly source: string;
    readonly type: Type;
    readonly validator: ConfigurationValidatorBase;
    value: unknown;
    readonly valueOrigin: PropertyValueOrigin;
}


export const PropertyInformation: {
    new(): PropertyInformation;
};


export type PropertyInformation = PropertyInformation$instance;

export interface PropertyInformationCollection$instance extends NameObjectCollectionBase {
    readonly item: PropertyInformation;
    copyTo(array: PropertyInformation[], index: int): void;
    getEnumerator(): IEnumerator;
}


export const PropertyInformationCollection: {
    new(): PropertyInformationCollection;
};


export type PropertyInformationCollection = PropertyInformationCollection$instance;

export interface ProtectedConfigurationProvider$instance extends ProviderBase {
    decrypt(encryptedNode: XmlNode): XmlNode;
    encrypt(node: XmlNode): XmlNode;
}


export const ProtectedConfigurationProvider: {
};


export type ProtectedConfigurationProvider = ProtectedConfigurationProvider$instance;

export interface ProtectedConfigurationProviderCollection$instance extends ProviderCollection {
    readonly item: ProtectedConfigurationProvider | ProviderBase;
    add(provider: ProviderBase): void;
}


export const ProtectedConfigurationProviderCollection: {
    new(): ProtectedConfigurationProviderCollection;
};


export type ProtectedConfigurationProviderCollection = ProtectedConfigurationProviderCollection$instance;

export interface ProtectedConfigurationSection$instance extends ConfigurationSection {
    defaultProvider: string;
    readonly providers: ProviderSettingsCollection;
}


export const ProtectedConfigurationSection: {
    new(): ProtectedConfigurationSection;
};


export type ProtectedConfigurationSection = ProtectedConfigurationSection$instance;

export interface ProtectedProviderSettings$instance extends ConfigurationElement {
    readonly providers: ProviderSettingsCollection;
}


export const ProtectedProviderSettings: {
    new(): ProtectedProviderSettings;
};


export type ProtectedProviderSettings = ProtectedProviderSettings$instance;

export interface ProviderSettings$instance extends ConfigurationElement {
    name: string;
    readonly parameters: NameValueCollection;
    type: string;
}


export const ProviderSettings: {
    new(): ProviderSettings;
    new(name: string, type: string): ProviderSettings;
};


export type ProviderSettings = ProviderSettings$instance;

export interface ProviderSettingsCollection$instance extends ConfigurationElementCollection {
    add(provider: ProviderSettings): void;
    clear(): void;
    get_Item(key: string): ProviderSettings;
    get_Item(index: int): ProviderSettings;
    remove(name: string): void;
    set_Item(index: int, value: ProviderSettings): void;
}


export const ProviderSettingsCollection: {
    new(): ProviderSettingsCollection;
};


export type ProviderSettingsCollection = ProviderSettingsCollection$instance;

export interface RegexStringValidator$instance extends ConfigurationValidatorBase {
    canValidate(type: Type): boolean;
    validate(value: unknown): void;
}


export const RegexStringValidator: {
    new(regex: string): RegexStringValidator;
};


export type RegexStringValidator = RegexStringValidator$instance;

export interface RegexStringValidatorAttribute$instance extends ConfigurationValidatorAttribute {
    readonly regex: string;
    readonly validatorInstance: ConfigurationValidatorBase;
}


export const RegexStringValidatorAttribute: {
    new(regex: string): RegexStringValidatorAttribute;
};


export type RegexStringValidatorAttribute = RegexStringValidatorAttribute$instance;

export interface RsaProtectedConfigurationProvider$instance extends ProtectedConfigurationProvider {
    readonly cspProviderName: string;
    readonly keyContainerName: string;
    readonly rsaPublicKey: RSAParameters;
    readonly useFIPS: boolean;
    readonly useMachineContainer: boolean;
    readonly useOAEP: boolean;
    addKey(keySize: int, exportable: boolean): void;
    decrypt(encryptedNode: XmlNode): XmlNode;
    deleteKey(): void;
    encrypt(node: XmlNode): XmlNode;
    exportKey(xmlFileName: string, includePrivateParameters: boolean): void;
    importKey(xmlFileName: string, exportable: boolean): void;
}


export const RsaProtectedConfigurationProvider: {
    new(): RsaProtectedConfigurationProvider;
};


export type RsaProtectedConfigurationProvider = RsaProtectedConfigurationProvider$instance;

export interface SchemeSettingElement$instance extends ConfigurationElement {
    readonly genericUriParserOptions: GenericUriParserOptions;
    readonly name: string;
}


export const SchemeSettingElement: {
    new(): SchemeSettingElement;
};


export type SchemeSettingElement = SchemeSettingElement$instance;

export interface SchemeSettingElementCollection$instance extends ConfigurationElementCollection {
    readonly collectionType: ConfigurationElementCollectionType;
    get_Item(index: int): SchemeSettingElement;
    get_Item(name: string): SchemeSettingElement;
    indexOf(element: SchemeSettingElement): int;
}


export const SchemeSettingElementCollection: {
    new(): SchemeSettingElementCollection;
};


export type SchemeSettingElementCollection = SchemeSettingElementCollection$instance;

export interface SectionInformation$instance {
    allowDefinition: ConfigurationAllowDefinition;
    allowExeDefinition: ConfigurationAllowExeDefinition;
    allowLocation: boolean;
    allowOverride: boolean;
    configSource: string;
    forceSave: boolean;
    inheritInChildApplications: boolean;
    readonly isDeclarationRequired: boolean;
    readonly isDeclared: boolean;
    readonly isLocked: boolean;
    readonly isProtected: boolean;
    readonly name: string;
    overrideMode: OverrideMode;
    overrideModeDefault: OverrideMode;
    readonly overrideModeEffective: OverrideMode;
    readonly protectionProvider: ProtectedConfigurationProvider;
    requirePermission: boolean;
    restartOnExternalChanges: boolean;
    readonly sectionName: string;
    type: string;
    forceDeclaration(): void;
    forceDeclaration(force: boolean): void;
    getParentSection(): ConfigurationSection;
    getRawXml(): string;
    protectSection(protectionProvider: string): void;
    revertToParent(): void;
    setRawXml(rawXml: string): void;
    unprotectSection(): void;
}


export const SectionInformation: {
    new(): SectionInformation;
};


export type SectionInformation = SectionInformation$instance;

export interface SettingAttribute$instance extends Attribute {
}


export const SettingAttribute: {
    new(): SettingAttribute;
};


export type SettingAttribute = SettingAttribute$instance;

export interface SettingChangingEventArgs$instance extends CancelEventArgs {
    readonly newValue: unknown;
    readonly settingClass: string;
    readonly settingKey: string;
    readonly settingName: string;
}


export const SettingChangingEventArgs: {
    new(settingName: string, settingClass: string, settingKey: string, newValue: unknown, cancel: boolean): SettingChangingEventArgs;
};


export type SettingChangingEventArgs = SettingChangingEventArgs$instance;

export interface SettingElement$instance extends ConfigurationElement {
    name: string;
    serializeAs: SettingsSerializeAs;
    value: SettingValueElement;
    equals(settings: unknown): boolean;
    getHashCode(): int;
}


export const SettingElement: {
    new(): SettingElement;
    new(name: string, serializeAs: SettingsSerializeAs): SettingElement;
};


export type SettingElement = SettingElement$instance;

export interface SettingElementCollection$instance extends ConfigurationElementCollection {
    readonly collectionType: ConfigurationElementCollectionType;
    add(element: SettingElement): void;
    clear(): void;
    get(elementKey: string): SettingElement;
    remove(element: SettingElement): void;
}


export const SettingElementCollection: {
    new(): SettingElementCollection;
};


export type SettingElementCollection = SettingElementCollection$instance;

export interface SettingsAttributeDictionary$instance extends Hashtable {
}


export const SettingsAttributeDictionary: {
    new(): SettingsAttributeDictionary;
    new(attributes: SettingsAttributeDictionary): SettingsAttributeDictionary;
};


export type SettingsAttributeDictionary = SettingsAttributeDictionary$instance;

export interface SettingsBase$instance {
    readonly context: SettingsContext;
    readonly isSynchronized: boolean;
    item: unknown;
    readonly properties: SettingsPropertyCollection;
    readonly propertyValues: SettingsPropertyValueCollection;
    readonly providers: SettingsProviderCollection;
    initialize(context: SettingsContext, properties: SettingsPropertyCollection, providers: SettingsProviderCollection): void;
    save(): void;
}


export const SettingsBase: {
    synchronized(settingsBase: SettingsBase): SettingsBase;
};


export type SettingsBase = SettingsBase$instance;

export interface SettingsContext$instance extends Hashtable {
}


export const SettingsContext: {
    new(): SettingsContext;
};


export type SettingsContext = SettingsContext$instance;

export interface SettingsDescriptionAttribute$instance extends Attribute {
    readonly description: string;
}


export const SettingsDescriptionAttribute: {
    new(description: string): SettingsDescriptionAttribute;
};


export type SettingsDescriptionAttribute = SettingsDescriptionAttribute$instance;

export interface SettingsGroupDescriptionAttribute$instance extends Attribute {
    readonly description: string;
}


export const SettingsGroupDescriptionAttribute: {
    new(description: string): SettingsGroupDescriptionAttribute;
};


export type SettingsGroupDescriptionAttribute = SettingsGroupDescriptionAttribute$instance;

export interface SettingsGroupNameAttribute$instance extends Attribute {
    readonly groupName: string;
}


export const SettingsGroupNameAttribute: {
    new(groupName: string): SettingsGroupNameAttribute;
};


export type SettingsGroupNameAttribute = SettingsGroupNameAttribute$instance;

export interface SettingsLoadedEventArgs$instance extends EventArgs {
    readonly provider: SettingsProvider;
}


export const SettingsLoadedEventArgs: {
    new(provider: SettingsProvider): SettingsLoadedEventArgs;
};


export type SettingsLoadedEventArgs = SettingsLoadedEventArgs$instance;

export interface SettingsManageabilityAttribute$instance extends Attribute {
    readonly manageability: SettingsManageability;
}


export const SettingsManageabilityAttribute: {
    new(manageability: SettingsManageability): SettingsManageabilityAttribute;
};


export type SettingsManageabilityAttribute = SettingsManageabilityAttribute$instance;

export interface SettingsProperty$instance {
    readonly attributes: SettingsAttributeDictionary;
    defaultValue: unknown;
    isReadOnly: boolean;
    name: string;
    propertyType: Type;
    get provider(): SettingsProvider | undefined;
    set provider(value: SettingsProvider);
    serializeAs: SettingsSerializeAs;
    throwOnErrorDeserializing: boolean;
    throwOnErrorSerializing: boolean;
}


export const SettingsProperty: {
    new(name: string): SettingsProperty;
    new(name: string, propertyType: Type, provider: SettingsProvider, isReadOnly: boolean, defaultValue: unknown, serializeAs: SettingsSerializeAs, attributes: SettingsAttributeDictionary, throwOnErrorDeserializing: boolean, throwOnErrorSerializing: boolean): SettingsProperty;
    new(propertyToCopy: SettingsProperty): SettingsProperty;
};


export type SettingsProperty = SettingsProperty$instance;

export interface SettingsPropertyCollection$instance {
    readonly count: int;
    readonly isSynchronized: boolean;
    readonly item: SettingsProperty;
    readonly syncRoot: unknown;
    add(property: SettingsProperty): void;
    clear(): void;
    clone(): unknown;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator;
    remove(name: string): void;
    setReadOnly(): void;
}


export const SettingsPropertyCollection: {
    new(): SettingsPropertyCollection;
};


export type SettingsPropertyCollection = SettingsPropertyCollection$instance;

export interface SettingsPropertyIsReadOnlyException$instance extends Exception {
}


export const SettingsPropertyIsReadOnlyException: {
    new(message: string): SettingsPropertyIsReadOnlyException;
    new(message: string, innerException: Exception): SettingsPropertyIsReadOnlyException;
    new(): SettingsPropertyIsReadOnlyException;
};


export type SettingsPropertyIsReadOnlyException = SettingsPropertyIsReadOnlyException$instance;

export interface SettingsPropertyNotFoundException$instance extends Exception {
}


export const SettingsPropertyNotFoundException: {
    new(message: string): SettingsPropertyNotFoundException;
    new(message: string, innerException: Exception): SettingsPropertyNotFoundException;
    new(): SettingsPropertyNotFoundException;
};


export type SettingsPropertyNotFoundException = SettingsPropertyNotFoundException$instance;

export interface SettingsPropertyValue$instance {
    deserialized: boolean;
    isDirty: boolean;
    readonly name: string;
    readonly property: SettingsProperty;
    propertyValue: unknown;
    serializedValue: unknown;
    readonly usingDefaultValue: boolean;
}


export const SettingsPropertyValue: {
    new(property: SettingsProperty): SettingsPropertyValue;
};


export type SettingsPropertyValue = SettingsPropertyValue$instance;

export interface SettingsPropertyValueCollection$instance {
    readonly count: int;
    readonly isSynchronized: boolean;
    readonly item: SettingsPropertyValue;
    readonly syncRoot: unknown;
    add(property: SettingsPropertyValue): void;
    clear(): void;
    clone(): unknown;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator;
    remove(name: string): void;
    setReadOnly(): void;
}


export const SettingsPropertyValueCollection: {
    new(): SettingsPropertyValueCollection;
};


export type SettingsPropertyValueCollection = SettingsPropertyValueCollection$instance;

export interface SettingsPropertyWrongTypeException$instance extends Exception {
}


export const SettingsPropertyWrongTypeException: {
    new(message: string): SettingsPropertyWrongTypeException;
    new(message: string, innerException: Exception): SettingsPropertyWrongTypeException;
    new(): SettingsPropertyWrongTypeException;
};


export type SettingsPropertyWrongTypeException = SettingsPropertyWrongTypeException$instance;

export interface SettingsProvider$instance extends ProviderBase {
    applicationName: string;
    getPropertyValues(context: SettingsContext, collection: SettingsPropertyCollection): SettingsPropertyValueCollection;
    setPropertyValues(context: SettingsContext, collection: SettingsPropertyValueCollection): void;
}


export const SettingsProvider: {
};


export type SettingsProvider = SettingsProvider$instance;

export interface SettingsProviderAttribute$instance extends Attribute {
    readonly providerTypeName: string;
}


export const SettingsProviderAttribute: {
    new(providerTypeName: string): SettingsProviderAttribute;
    new(providerType: Type): SettingsProviderAttribute;
};


export type SettingsProviderAttribute = SettingsProviderAttribute$instance;

export interface SettingsProviderCollection$instance extends ProviderCollection {
    readonly item: ProviderBase | SettingsProvider;
    add(provider: ProviderBase): void;
}


export const SettingsProviderCollection: {
    new(): SettingsProviderCollection;
};


export type SettingsProviderCollection = SettingsProviderCollection$instance;

export interface SettingsSerializeAsAttribute$instance extends Attribute {
    readonly serializeAs: SettingsSerializeAs;
}


export const SettingsSerializeAsAttribute: {
    new(serializeAs: SettingsSerializeAs): SettingsSerializeAsAttribute;
};


export type SettingsSerializeAsAttribute = SettingsSerializeAsAttribute$instance;

export interface SettingValueElement$instance extends ConfigurationElement {
    valueXml: XmlNode;
    equals(settingValue: unknown): boolean;
    getHashCode(): int;
}


export const SettingValueElement: {
    new(): SettingValueElement;
};


export type SettingValueElement = SettingValueElement$instance;

export interface SingleTagSectionHandler$instance {
    create(parent: unknown, context: unknown, section: XmlNode): unknown;
}


export const SingleTagSectionHandler: {
    new(): SingleTagSectionHandler;
};


export interface __SingleTagSectionHandler$views {
    As_IConfigurationSectionHandler(): IConfigurationSectionHandler$instance;
}

export interface SingleTagSectionHandler$instance extends IConfigurationSectionHandler$instance {}

export type SingleTagSectionHandler = SingleTagSectionHandler$instance & __SingleTagSectionHandler$views;


export interface SpecialSettingAttribute$instance extends Attribute {
    readonly specialSetting: SpecialSetting;
}


export const SpecialSettingAttribute: {
    new(specialSetting: SpecialSetting): SpecialSettingAttribute;
};


export type SpecialSettingAttribute = SpecialSettingAttribute$instance;

export interface StringValidator$instance extends ConfigurationValidatorBase {
    canValidate(type: Type): boolean;
    validate(value: unknown): void;
}


export const StringValidator: {
    new(minLength: int): StringValidator;
    new(minLength: int, maxLength: int): StringValidator;
    new(minLength: int, maxLength: int, invalidCharacters: string): StringValidator;
};


export type StringValidator = StringValidator$instance;

export interface StringValidatorAttribute$instance extends ConfigurationValidatorAttribute {
    invalidCharacters: string;
    maxLength: int;
    minLength: int;
    readonly validatorInstance: ConfigurationValidatorBase;
}


export const StringValidatorAttribute: {
    new(): StringValidatorAttribute;
};


export type StringValidatorAttribute = StringValidatorAttribute$instance;

export interface SubclassTypeValidator$instance extends ConfigurationValidatorBase {
    canValidate(type: Type): boolean;
    validate(value: unknown): void;
}


export const SubclassTypeValidator: {
    new(baseClass: Type): SubclassTypeValidator;
};


export type SubclassTypeValidator = SubclassTypeValidator$instance;

export interface SubclassTypeValidatorAttribute$instance extends ConfigurationValidatorAttribute {
    readonly baseClass: Type;
    readonly validatorInstance: ConfigurationValidatorBase;
}


export const SubclassTypeValidatorAttribute: {
    new(baseClass: Type): SubclassTypeValidatorAttribute;
};


export type SubclassTypeValidatorAttribute = SubclassTypeValidatorAttribute$instance;

export interface TimeSpanMinutesConverter$instance extends ConfigurationConverterBase {
    convertFrom(ctx: ITypeDescriptorContext, ci: CultureInfo, data: unknown): unknown;
    convertTo(ctx: ITypeDescriptorContext, ci: CultureInfo, value: unknown, type: Type): unknown;
}


export const TimeSpanMinutesConverter: {
    new(): TimeSpanMinutesConverter;
};


export type TimeSpanMinutesConverter = TimeSpanMinutesConverter$instance;

export interface TimeSpanMinutesOrInfiniteConverter$instance extends TimeSpanMinutesConverter {
    convertFrom(ctx: ITypeDescriptorContext, ci: CultureInfo, data: unknown): unknown;
    convertTo(ctx: ITypeDescriptorContext, ci: CultureInfo, value: unknown, type: Type): unknown;
}


export const TimeSpanMinutesOrInfiniteConverter: {
    new(): TimeSpanMinutesOrInfiniteConverter;
};


export type TimeSpanMinutesOrInfiniteConverter = TimeSpanMinutesOrInfiniteConverter$instance;

export interface TimeSpanSecondsConverter$instance extends ConfigurationConverterBase {
    convertFrom(ctx: ITypeDescriptorContext, ci: CultureInfo, data: unknown): unknown;
    convertTo(ctx: ITypeDescriptorContext, ci: CultureInfo, value: unknown, type: Type): unknown;
}


export const TimeSpanSecondsConverter: {
    new(): TimeSpanSecondsConverter;
};


export type TimeSpanSecondsConverter = TimeSpanSecondsConverter$instance;

export interface TimeSpanSecondsOrInfiniteConverter$instance extends TimeSpanSecondsConverter {
    convertFrom(ctx: ITypeDescriptorContext, ci: CultureInfo, data: unknown): unknown;
    convertTo(ctx: ITypeDescriptorContext, ci: CultureInfo, value: unknown, type: Type): unknown;
}


export const TimeSpanSecondsOrInfiniteConverter: {
    new(): TimeSpanSecondsOrInfiniteConverter;
};


export type TimeSpanSecondsOrInfiniteConverter = TimeSpanSecondsOrInfiniteConverter$instance;

export interface TimeSpanValidator$instance extends ConfigurationValidatorBase {
    canValidate(type: Type): boolean;
    validate(value: unknown): void;
}


export const TimeSpanValidator: {
    new(minValue: TimeSpan, maxValue: TimeSpan): TimeSpanValidator;
    new(minValue: TimeSpan, maxValue: TimeSpan, rangeIsExclusive: boolean): TimeSpanValidator;
    new(minValue: TimeSpan, maxValue: TimeSpan, rangeIsExclusive: boolean, resolutionInSeconds: long): TimeSpanValidator;
};


export type TimeSpanValidator = TimeSpanValidator$instance;

export interface TimeSpanValidatorAttribute$instance extends ConfigurationValidatorAttribute {
    excludeRange: boolean;
    readonly maxValue: TimeSpan;
    maxValueString: string;
    readonly minValue: TimeSpan;
    minValueString: string;
    readonly validatorInstance: ConfigurationValidatorBase;
}


export const TimeSpanValidatorAttribute: {
    new(): TimeSpanValidatorAttribute;
    readonly timeSpanMinValue: string;
    readonly timeSpanMaxValue: string;
};


export type TimeSpanValidatorAttribute = TimeSpanValidatorAttribute$instance;

export interface TypeNameConverter$instance extends ConfigurationConverterBase {
    convertFrom(ctx: ITypeDescriptorContext, ci: CultureInfo, data: unknown): unknown;
    convertTo(ctx: ITypeDescriptorContext, ci: CultureInfo, value: unknown, type: Type): unknown;
}


export const TypeNameConverter: {
    new(): TypeNameConverter;
};


export type TypeNameConverter = TypeNameConverter$instance;

export interface UriSection$instance extends ConfigurationSection {
    readonly idn: IdnElement;
    readonly iriParsing: IriParsingElement;
    readonly schemeSettings: SchemeSettingElementCollection;
}


export const UriSection: {
    new(): UriSection;
};


export type UriSection = UriSection$instance;

export interface UserScopedSettingAttribute$instance extends SettingAttribute {
}


export const UserScopedSettingAttribute: {
    new(): UserScopedSettingAttribute;
};


export type UserScopedSettingAttribute = UserScopedSettingAttribute$instance;

export interface UserSettingsGroup$instance extends ConfigurationSectionGroup {
}


export const UserSettingsGroup: {
    new(): UserSettingsGroup;
};


export type UserSettingsGroup = UserSettingsGroup$instance;

export interface WhiteSpaceTrimStringConverter$instance extends ConfigurationConverterBase {
    convertFrom(ctx: ITypeDescriptorContext, ci: CultureInfo, data: unknown): unknown;
    convertTo(ctx: ITypeDescriptorContext, ci: CultureInfo, value: unknown, type: Type): unknown;
}


export const WhiteSpaceTrimStringConverter: {
    new(): WhiteSpaceTrimStringConverter;
};


export type WhiteSpaceTrimStringConverter = WhiteSpaceTrimStringConverter$instance;

export abstract class ConfigurationManager$instance {
    static readonly appSettings: NameValueCollection;
    static readonly connectionStrings: ConnectionStringSettingsCollection;
    static getSection(sectionName: string): unknown;
    static openExeConfiguration(userLevel: ConfigurationUserLevel): Configuration;
    static openExeConfiguration(exePath: string): Configuration;
    static openMachineConfiguration(): Configuration;
    static openMappedExeConfiguration(fileMap: ExeConfigurationFileMap, userLevel: ConfigurationUserLevel, preLoad: boolean): Configuration;
    static openMappedExeConfiguration(fileMap: ExeConfigurationFileMap, userLevel: ConfigurationUserLevel): Configuration;
    static openMappedMachineConfiguration(fileMap: ConfigurationFileMap): Configuration;
    static refreshSection(sectionName: string): void;
}


export type ConfigurationManager = ConfigurationManager$instance;

export abstract class ProtectedConfiguration$instance {
    static readonly rsaProviderName: string;
    static readonly dataProtectionProviderName: string;
    static readonly protectedDataSectionName: string;
    static readonly providers: ProtectedConfigurationProviderCollection;
    static readonly defaultProvider: string;
}


export type ProtectedConfiguration = ProtectedConfiguration$instance;


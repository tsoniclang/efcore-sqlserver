// Generated by tsbindgen - Architecture
// Namespace: Microsoft.Identity.Client.Extensions.Msal
// Assembly: Microsoft.Identity.Client.Extensions.Msal

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import type { ITokenCache } from "../../Microsoft.Identity.Client/internal/index.js";
import type { IEnumerable, KeyValuePair } from "@tsonic/dotnet/System.Collections.Generic.js";
import type { TraceSource } from "@tsonic/dotnet/System.Diagnostics.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Boolean as ClrBoolean, Byte, EventArgs, EventHandler, Exception, IDisposable, Int32, Object as ClrObject, String as ClrString, Void } from "@tsonic/dotnet/System.js";
import * as System_Runtime_Serialization_Internal from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { ISerializable } from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { Task } from "@tsonic/dotnet/System.Threading.Tasks.js";

export interface CacheChangedEventArgs$instance extends EventArgs {
    readonly accountsAdded: IEnumerable<System_Internal.String>;
    readonly accountsRemoved: IEnumerable<System_Internal.String>;
}


export const CacheChangedEventArgs: {
    new(added: IEnumerable<System_Internal.String>, removed: IEnumerable<System_Internal.String>): CacheChangedEventArgs;
};


export type CacheChangedEventArgs = CacheChangedEventArgs$instance;

export interface CrossPlatLock$instance {
    dispose(): void;
}


export const CrossPlatLock: {
    new(lockfilePath: string, lockFileRetryDelay: int, lockFileRetryCount: int): CrossPlatLock;
};


export type CrossPlatLock = CrossPlatLock$instance;

export interface MsalCacheHelper$instance {
    clear(): void;
    loadUnencryptedTokenCache(): byte[];
    registerCache(tokenCache: ITokenCache): void;
    saveUnencryptedTokenCache(tokenCache: byte[]): void;
    unregisterCache(tokenCache: ITokenCache): void;
    verifyPersistence(): void;
}


export const MsalCacheHelper: {
    new(): MsalCacheHelper;
    readonly linuxKeyRingDefaultCollection: string;
    readonly linuxKeyRingSessionCollection: string;
    readonly userRootDirectory: string;
    createAsync(storageCreationProperties: StorageCreationProperties, logger?: TraceSource): Task<MsalCacheHelper>;
};


export type MsalCacheHelper = MsalCacheHelper$instance;

export interface MsalCachePersistenceException$instance extends Exception {
}


export const MsalCachePersistenceException: {
    new(): MsalCachePersistenceException;
    new(message: string): MsalCachePersistenceException;
    new(message: string, innerException: Exception): MsalCachePersistenceException;
};


export type MsalCachePersistenceException = MsalCachePersistenceException$instance;

export interface Storage$instance {
    clear(ignoreExceptions?: boolean): void;
    readData(): byte[];
    verifyPersistence(): void;
    writeData(data: byte[]): void;
}


export const Storage: {
    new(): Storage;
    create(creationProperties: StorageCreationProperties, logger?: TraceSource): Storage;
};


export type Storage = Storage$instance;

export interface StorageCreationProperties$instance {
    readonly cacheFileName: string;
    readonly cacheDirectory: string;
    readonly macKeyChainServiceName: string;
    readonly macKeyChainAccountName: string;
    readonly keyringSchemaName: string;
    readonly keyringCollection: string;
    readonly keyringSecretLabel: string;
    readonly keyringAttribute1: KeyValuePair<System_Internal.String, System_Internal.String>;
    readonly keyringAttribute2: KeyValuePair<System_Internal.String, System_Internal.String>;
    readonly lockRetryDelay: int;
    readonly useLinuxUnencryptedFallback: boolean;
    readonly useUnencryptedFallback: boolean;
    readonly lockRetryCount: int;
    readonly authority: string;
    readonly cacheFilePath: string;
    readonly clientId: string;
}


export const StorageCreationProperties: {
    new(): StorageCreationProperties;
};


export type StorageCreationProperties = StorageCreationProperties$instance;

export interface StorageCreationPropertiesBuilder$instance {
    build(): StorageCreationProperties;
    customizeLockRetry(lockRetryDelay: int, lockRetryCount: int): StorageCreationPropertiesBuilder;
    withCacheChangedEvent(clientId: string, authority?: string): StorageCreationPropertiesBuilder;
    withLinuxKeyring(schemaName: string, collection: string, secretLabel: string, attribute1: KeyValuePair<System_Internal.String, System_Internal.String>, attribute2: KeyValuePair<System_Internal.String, System_Internal.String>): StorageCreationPropertiesBuilder;
    withLinuxUnprotectedFile(): StorageCreationPropertiesBuilder;
    withMacKeyChain(serviceName: string, accountName: string): StorageCreationPropertiesBuilder;
    withUnprotectedFile(): StorageCreationPropertiesBuilder;
}


export const StorageCreationPropertiesBuilder: {
    new(cacheFileName: string, cacheDirectory: string, clientId: string): StorageCreationPropertiesBuilder;
    new(cacheFileName: string, cacheDirectory: string): StorageCreationPropertiesBuilder;
};


export type StorageCreationPropertiesBuilder = StorageCreationPropertiesBuilder$instance;

export interface TraceSourceLogger$instance {
    readonly source: TraceSource;
    logError(message: string): void;
    logInformation(message: string): void;
    logWarning(message: string): void;
}


export const TraceSourceLogger: {
    new(traceSource: TraceSource): TraceSourceLogger;
};


export type TraceSourceLogger = TraceSourceLogger$instance;

export abstract class SharedUtilities$instance {
    static getUserRootDirectory(): string;
    static isLinuxPlatform(): boolean;
    static isMacPlatform(): boolean;
    static isWindowsPlatform(): boolean;
}


export type SharedUtilities = SharedUtilities$instance;


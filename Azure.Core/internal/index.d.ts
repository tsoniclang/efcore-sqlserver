// Generated by tsbindgen - Architecture
// Namespace: Azure.Core
// Assembly: Azure.Core

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { HttpPipelinePolicy, HttpPipelineTransport } from "../../Azure.Core.Pipeline/internal/index.js";
import type { DynamicData, JsonPropertyNames, ObjectSerializer } from "../../Azure.Core.Serialization/internal/index.js";
import type { ETag, Response, ResponseError, SyncAsyncEventArgs } from "../../Azure/internal/index.js";
import * as System_ClientModel_Primitives_Internal from "../../System.ClientModel.Primitives/internal/index.js";
import type { AuthenticationToken, GetTokenOptions, IJsonModel_1, IPersistableModel_1, ModelReaderWriterContext, ModelReaderWriterOptions, ModelReaderWriterTypeBuilder } from "../../System.ClientModel.Primitives/internal/index.js";
import * as System_ClientModel_Internal from "../../System.ClientModel/internal/index.js";
import type { AuthenticationTokenProvider } from "../../System.ClientModel/internal/index.js";
import type { BinaryData } from "../../System/internal/index.js";
import type { ReadOnlySequence } from "@tsonic/dotnet/System.Buffers.js";
import * as System_Collections_Generic_Internal from "@tsonic/dotnet/System.Collections.Generic.js";
import type { IDictionary, IEnumerable as IEnumerable__System_Collections_Generic, IEnumerator, IList, IReadOnlyDictionary } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Collections_Internal from "@tsonic/dotnet/System.Collections.js";
import type { IEnumerable } from "@tsonic/dotnet/System.Collections.js";
import type { Stream } from "@tsonic/dotnet/System.IO.js";
import * as System_Lib from "@tsonic/dotnet/System.js";
import type { AsyncCallback, Boolean as ClrBoolean, Byte, Char, DateTimeOffset, Enum, Exception, Func, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IEquatable, IFormattable, Int32, Int64, IntPtr, ISpanFormattable, MulticastDelegate, Nullable, Object as ClrObject, ReadOnlyMemory, ReadOnlySpan, String as ClrString, TimeSpan, Type, UInt16, Uri, ValueType, Void } from "@tsonic/dotnet/System.js";
import type { Assembly } from "@tsonic/dotnet/System.Reflection.js";
import * as System_Runtime_Serialization_Internal from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { ISerializable } from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { Utf8JsonReader, Utf8JsonWriter } from "@tsonic/dotnet/System.Text.Json.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading.js";
import type { Task, ValueTask } from "@tsonic/dotnet/System.Threading.Tasks.js";

export enum HttpPipelinePosition {
    perCall = 0,
    perRetry = 1,
    beforeTransport = 2
}


export enum RetryMode {
    fixed = 0,
    exponential = 1
}


export type SyncAsyncEventHandler_1<T extends SyncAsyncEventArgs> = (e: T) => Task;


export interface AccessToken$instance {
    readonly expiresOn: DateTimeOffset;
    readonly refreshOn: Nullable<DateTimeOffset>;
    readonly token: string;
    readonly tokenType: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const AccessToken: {
    new(accessToken: string, expiresOn: DateTimeOffset): AccessToken;
    new(accessToken: string, expiresOn: DateTimeOffset, refreshOn: Nullable<DateTimeOffset>): AccessToken;
    new(accessToken: string, expiresOn: DateTimeOffset, refreshOn: Nullable<DateTimeOffset>, tokenType: string): AccessToken;
};


export type AccessToken = AccessToken$instance;

export interface AzureLocation$instance {
    readonly displayName: string | undefined;
    readonly name: string;
    equals(other: AzureLocation): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const AzureLocation: {
    new(location: string): AzureLocation;
    new(name: string, displayName: string): AzureLocation;
    readonly eastAsia: AzureLocation;
    readonly southeastAsia: AzureLocation;
    readonly centralUS: AzureLocation;
    readonly eastUS: AzureLocation;
    readonly eastUS2: AzureLocation;
    readonly westUS: AzureLocation;
    readonly westUS2: AzureLocation;
    readonly westUS3: AzureLocation;
    readonly northCentralUS: AzureLocation;
    readonly southCentralUS: AzureLocation;
    readonly northEurope: AzureLocation;
    readonly westEurope: AzureLocation;
    readonly japanWest: AzureLocation;
    readonly japanEast: AzureLocation;
    readonly brazilSouth: AzureLocation;
    readonly australiaEast: AzureLocation;
    readonly australiaSoutheast: AzureLocation;
    readonly southIndia: AzureLocation;
    readonly centralIndia: AzureLocation;
    readonly westIndia: AzureLocation;
    readonly canadaCentral: AzureLocation;
    readonly canadaEast: AzureLocation;
    readonly ukSouth: AzureLocation;
    readonly ukWest: AzureLocation;
    readonly westCentralUS: AzureLocation;
    readonly koreaCentral: AzureLocation;
    readonly koreaSouth: AzureLocation;
    readonly franceCentral: AzureLocation;
    readonly franceSouth: AzureLocation;
    readonly australiaCentral: AzureLocation;
    readonly australiaCentral2: AzureLocation;
    readonly uaeCentral: AzureLocation;
    readonly uaeNorth: AzureLocation;
    readonly southAfricaNorth: AzureLocation;
    readonly southAfricaWest: AzureLocation;
    readonly swedenCentral: AzureLocation;
    readonly swedenSouth: AzureLocation;
    readonly switzerlandNorth: AzureLocation;
    readonly switzerlandWest: AzureLocation;
    readonly germanyNorth: AzureLocation;
    readonly germanyWestCentral: AzureLocation;
    readonly germanyCentral: AzureLocation;
    readonly germanyNorthEast: AzureLocation;
    readonly norwayWest: AzureLocation;
    readonly norwayEast: AzureLocation;
    readonly brazilSoutheast: AzureLocation;
    readonly chinaNorth: AzureLocation;
    readonly chinaEast: AzureLocation;
    readonly chinaNorth2: AzureLocation;
    readonly chinaNorth3: AzureLocation;
    readonly chinaEast2: AzureLocation;
    readonly chinaEast3: AzureLocation;
    readonly qatarCentral: AzureLocation;
    readonly usDoDCentral: AzureLocation;
    readonly usDoDEast: AzureLocation;
    readonly usGovArizona: AzureLocation;
    readonly usGovTexas: AzureLocation;
    readonly usGovVirginia: AzureLocation;
    readonly usGovIowa: AzureLocation;
    readonly israelCentral: AzureLocation;
    readonly italyNorth: AzureLocation;
    readonly polandCentral: AzureLocation;
    readonly mexicoCentral: AzureLocation;
    readonly spainCentral: AzureLocation;
};


export type AzureLocation = AzureLocation$instance;

export interface ContentType$instance {
    equals(other: ContentType): boolean;
    equals(other: string): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const ContentType: {
    new(contentType: string): ContentType;
    readonly applicationJson: ContentType;
    readonly applicationOctetStream: ContentType;
    readonly textPlain: ContentType;
};


export type ContentType = ContentType$instance;

export interface HttpHeader$instance {
    readonly name: string;
    readonly value: string;
    equals(obj: unknown): boolean;
    equals(other: HttpHeader): boolean;
    getHashCode(): int;
    toString(): string;
}


export const HttpHeader: {
    new(name: string, value: string): HttpHeader;
};


export type HttpHeader = HttpHeader$instance;

export interface MessageProcessingContext$instance {
    retryNumber: int;
    readonly startTime: DateTimeOffset;
}


export const MessageProcessingContext: {
    new(): MessageProcessingContext;
};


export type MessageProcessingContext = MessageProcessingContext$instance;

export interface RehydrationToken$instance {
    readonly id: string;
}


export const RehydrationToken: {
    new(): RehydrationToken;
};


export interface __RehydrationToken$views {
    As_IJsonModel_1(): System_ClientModel_Primitives_Internal.IJsonModel_1$instance<RehydrationToken>;
    As_IPersistableModel_1(): System_ClientModel_Primitives_Internal.IPersistableModel_1$instance<RehydrationToken>;
}

export interface RehydrationToken$instance extends System_ClientModel_Primitives_Internal.IJsonModel_1$instance<RehydrationToken> {}

export type RehydrationToken = RehydrationToken$instance & __RehydrationToken$views;


export interface RequestHeaders$instance {
    add(header: HttpHeader): void;
    add(name: string, value: string): void;
    contains(name: string): boolean;
    getEnumerator(): IEnumerator<HttpHeader>;
    remove(name: string): boolean;
    setValue(name: string, value: string): void;
    tryGetValue(name: string, value: string): boolean;
    tryGetValues(name: string, values: IEnumerable__System_Collections_Generic<System_Internal.String>): boolean;
}


export const RequestHeaders: {
    new(): RequestHeaders;
};


export type RequestHeaders = RequestHeaders$instance;

export interface RequestMethod$instance {
    readonly method: string;
    equals(other: RequestMethod): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RequestMethod: {
    new(method: string): RequestMethod;
    readonly get: RequestMethod;
    readonly post: RequestMethod;
    readonly put: RequestMethod;
    readonly patch: RequestMethod;
    readonly delete: RequestMethod;
    readonly head: RequestMethod;
    readonly options: RequestMethod;
    readonly trace: RequestMethod;
    parse(method: string): RequestMethod;
};


export type RequestMethod = RequestMethod$instance;

export interface ResourceType$instance {
    readonly namespace: string;
    readonly type: string;
    equals(other: ResourceType): boolean;
    equals(other: unknown): boolean;
    getHashCode(): int;
    getLastType(): string;
    toString(): string;
}


export const ResourceType: {
    new(resourceType: string): ResourceType;
};


export type ResourceType = ResourceType$instance;

export interface ResponseHeaders$instance {
    readonly contentLength: Nullable<System_Internal.Int32>;
    readonly contentLengthLong: Nullable<System_Internal.Int64>;
    readonly contentType: string | undefined;
    readonly date: Nullable<DateTimeOffset>;
    readonly eTag: Nullable<ETag>;
    readonly requestId: string | undefined;
    contains(name: string): boolean;
    getEnumerator(): IEnumerator<HttpHeader>;
    tryGetValue(name: string, value: string): boolean;
    tryGetValues(name: string, values: IEnumerable__System_Collections_Generic<System_Internal.String>): boolean;
}


export const ResponseHeaders: {
    new(): ResponseHeaders;
};


export type ResponseHeaders = ResponseHeaders$instance;

export interface TokenRequestContext$instance {
    readonly claims: string | undefined;
    readonly isCaeEnabled: boolean;
    readonly isProofOfPossessionEnabled: boolean;
    readonly parentRequestId: string | undefined;
    readonly proofOfPossessionNonce: string | undefined;
    readonly resourceRequestMethod: string | undefined;
    readonly resourceRequestUri: Uri | undefined;
    readonly scopes: string[];
    readonly tenantId: string | undefined;
}


export const TokenRequestContext: {
    new(scopes: string[], parentRequestId: string): TokenRequestContext;
    new(scopes: string[], parentRequestId: string, claims: string): TokenRequestContext;
    new(scopes: string[], parentRequestId: string, claims: string, tenantId: string): TokenRequestContext;
    new(scopes: string[], parentRequestId: string, claims: string, tenantId: string, isCaeEnabled: boolean): TokenRequestContext;
    new(scopes: string[], parentRequestId: string, claims: string, tenantId: string, isCaeEnabled: boolean, isProofOfPossessionEnabled: boolean, proofOfPossessionNonce: string, requestUri: Uri, requestMethod: string): TokenRequestContext;
};


export type TokenRequestContext = TokenRequestContext$instance;

export interface AzureCoreContext$instance extends ModelReaderWriterContext {
}


export const AzureCoreContext: {
    new(): AzureCoreContext;
    readonly default: AzureCoreContext;
};


export type AzureCoreContext = AzureCoreContext$instance;

export interface ClientOptions$instance {
    readonly diagnostics: DiagnosticsOptions | TokenCredentialDiagnosticsOptions;
    readonly retry: RetryOptions;
    get retryPolicy(): HttpPipelinePolicy | undefined;
    set retryPolicy(value: HttpPipelinePolicy);
    transport: HttpPipelineTransport;
    addPolicy(policy: HttpPipelinePolicy, position: HttpPipelinePosition): void;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string | undefined;
}


export const ClientOptions: {
    readonly default: ClientOptions;
};


export type ClientOptions = ClientOptions$instance;

export interface DelayStrategy$instance {
    getNextDelay(response: Response, retryNumber: int): TimeSpan;
}


export const DelayStrategy: {
    createExponentialDelayStrategy(initialDelay?: Nullable<TimeSpan>, maxDelay?: Nullable<TimeSpan>): DelayStrategy;
    createFixedDelayStrategy(delay?: Nullable<TimeSpan>): DelayStrategy;
};


export type DelayStrategy = DelayStrategy$instance;

export interface DiagnosticsOptions$instance {
    get applicationId(): string | undefined;
    set applicationId(value: string);
    isDistributedTracingEnabled: boolean;
    isLoggingContentEnabled: boolean;
    isLoggingEnabled: boolean;
    isTelemetryEnabled: boolean;
    loggedContentSizeLimit: int;
    readonly loggedHeaderNames: IList<System_Internal.String>;
    readonly loggedQueryParameters: IList<System_Internal.String>;
}


export const DiagnosticsOptions: {
    new(): DiagnosticsOptions;
    get defaultApplicationId(): string | undefined;
    set defaultApplicationId(value: string);
};


export type DiagnosticsOptions = DiagnosticsOptions$instance;

export interface HttpMessage$instance {
    bufferResponse: boolean;
    readonly cancellationToken: CancellationToken;
    readonly hasResponse: boolean;
    networkTimeout: Nullable<TimeSpan>;
    readonly processingContext: MessageProcessingContext;
    readonly request: Request;
    response: Response;
    responseClassifier: ResponseClassifier;
    dispose(): void;
    extractResponseContent(): Stream | undefined;
    setProperty(name: string, value: unknown): void;
    setProperty(type: Type, value: unknown): void;
    tryGetProperty(name: string, value: unknown): boolean;
    tryGetProperty(type: Type, value: unknown): boolean;
}


export const HttpMessage: {
    new(request: Request, responseClassifier: ResponseClassifier): HttpMessage;
};


export type HttpMessage = HttpMessage$instance;

export interface Request$instance {
    clientRequestId: string;
    content: RequestContent;
    readonly headers: RequestHeaders;
    method: RequestMethod;
    uri: RequestUriBuilder;
    dispose(): void;
}


export const Request: {
};


export type Request = Request$instance;

export interface RequestContent$instance {
    dispose(): void;
    tryComputeLength(length: long): boolean;
    writeTo(stream: Stream, cancellation: CancellationToken): void;
    writeToAsync(stream: Stream, cancellation: CancellationToken): Task;
}


export const RequestContent: {
    create(content: DynamicData): RequestContent;
    create(content: BinaryData): RequestContent;
    create(bytes: ReadOnlySequence<System_Internal.Byte>): RequestContent;
    create(bytes: byte[], index: int, length: int): RequestContent;
    create(bytes: byte[]): RequestContent;
    create(stream: Stream): RequestContent;
    create(serializable: unknown, propertyNameFormat: JsonPropertyNames, dateTimeFormat?: string): RequestContent;
    create(serializable: unknown, serializer: ObjectSerializer): RequestContent;
    create(serializable: unknown): RequestContent;
    create(bytes: ReadOnlyMemory<System_Internal.Byte>): RequestContent;
    create(content: string): RequestContent;
    create<T extends IPersistableModel_1<T>>(model: T, options?: ModelReaderWriterOptions): RequestContent;
};


export type RequestContent = RequestContent$instance;

export interface RequestFailedDetailsParser$instance {
    tryParse(response: Response, error: ResponseError, data: IDictionary<System_Internal.String, System_Internal.String>): boolean;
}


export const RequestFailedDetailsParser: {
};


export type RequestFailedDetailsParser = RequestFailedDetailsParser$instance;

export interface RequestUriBuilder$instance {
    get host(): string | undefined;
    set host(value: string);
    path: string;
    readonly pathAndQuery: string;
    port: int;
    query: string;
    scheme: string;
    appendPath(value: string): void;
    appendPath(value: string, escape: boolean): void;
    appendPath(value: ReadOnlySpan<System_Internal.Char>, escape: boolean): void;
    appendQuery(name: string, value: string): void;
    appendQuery(name: string, value: string, escapeValue: boolean): void;
    appendQuery(name: ReadOnlySpan<System_Internal.Char>, value: ReadOnlySpan<System_Internal.Char>, escapeValue: boolean): void;
    reset(value: Uri): void;
    toString(): string;
    toUri(): Uri;
}


export const RequestUriBuilder: {
    new(): RequestUriBuilder;
};


export type RequestUriBuilder = RequestUriBuilder$instance;

export interface ResourceIdentifier$instance {
    readonly location: Nullable<AzureLocation>;
    readonly name: string;
    readonly parent: ResourceIdentifier | undefined;
    readonly provider: string | undefined;
    readonly resourceGroupName: string | undefined;
    readonly resourceType: ResourceType;
    readonly subscriptionId: string | undefined;
    appendChildResource(childResourceType: string, childResourceName: string): ResourceIdentifier;
    appendProviderResource(providerNamespace: string, resourceType: string, resourceName: string): ResourceIdentifier;
    compareTo(other: ResourceIdentifier): int;
    equals(other: ResourceIdentifier): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const ResourceIdentifier: {
    new(resourceId: string): ResourceIdentifier;
    readonly root: ResourceIdentifier;
    parse(input: string): ResourceIdentifier;
    tryParse(input: string, result: ResourceIdentifier): boolean;
};


export type ResourceIdentifier = ResourceIdentifier$instance;

export interface ResponseClassificationHandler$instance {
    tryClassify(message: HttpMessage, isError: boolean): boolean;
}


export const ResponseClassificationHandler: {
};


export type ResponseClassificationHandler = ResponseClassificationHandler$instance;

export interface ResponseClassifier$instance {
    isErrorResponse(message: HttpMessage): boolean;
    isRetriable(message: HttpMessage, exception: Exception): boolean;
    isRetriableException(exception: Exception): boolean;
    isRetriableResponse(message: HttpMessage): boolean;
}


export const ResponseClassifier: {
    new(): ResponseClassifier;
};


export type ResponseClassifier = ResponseClassifier$instance;

export interface RetryOptions$instance {
    delay: TimeSpan;
    maxDelay: TimeSpan;
    maxRetries: int;
    mode: RetryMode;
    networkTimeout: TimeSpan;
}


export const RetryOptions: {
    new(): RetryOptions;
};


export type RetryOptions = RetryOptions$instance;

export interface StatusCodeClassifier$instance extends ResponseClassifier {
    isErrorResponse(message: HttpMessage): boolean;
}


export const StatusCodeClassifier: {
    new(successStatusCodes: ReadOnlySpan<System_Internal.UInt16>): StatusCodeClassifier;
};


export type StatusCodeClassifier = StatusCodeClassifier$instance;

export interface TelemetryDetails$instance {
    readonly applicationId: string | undefined;
    readonly assembly: Assembly;
    apply(message: HttpMessage): void;
    toString(): string;
}


export const TelemetryDetails: {
    new(assembly: Assembly, applicationId: string): TelemetryDetails;
};


export type TelemetryDetails = TelemetryDetails$instance;

export interface TokenCredential$instance extends AuthenticationTokenProvider {
    createTokenOptions(properties: IReadOnlyDictionary<System_Internal.String, unknown>): GetTokenOptions | undefined;
    createTokenOptions(properties: IReadOnlyDictionary<System_Internal.String, unknown>): GetTokenOptions | undefined;
    getToken(requestContext: TokenRequestContext, cancellationToken: CancellationToken): AccessToken;
    getToken(properties: GetTokenOptions, cancellationToken: CancellationToken): AuthenticationToken;
    getTokenAsync(requestContext: TokenRequestContext, cancellationToken: CancellationToken): ValueTask<AccessToken>;
    getTokenAsync(properties: GetTokenOptions, cancellationToken: CancellationToken): ValueTask<AuthenticationToken>;
    getTokenAsync(options: GetTokenOptions, cancellationToken: CancellationToken): ValueTask<AuthenticationToken>;
}


export const TokenCredential: {
};


export type TokenCredential = TokenCredential$instance;

export abstract class DelegatedTokenCredential$instance {
    static create(getToken: Func<TokenRequestContext, CancellationToken, AccessToken>, getTokenAsync: Func<TokenRequestContext, CancellationToken, ValueTask<AccessToken>>): TokenCredential;
    static create(getToken: Func<TokenRequestContext, CancellationToken, AccessToken>): TokenCredential;
}


export type DelegatedTokenCredential = DelegatedTokenCredential$instance;

export abstract class HttpHeader_Common$instance {
    static readonly jsonContentType: HttpHeader;
    static readonly jsonAccept: HttpHeader;
    static readonly octetStreamContentType: HttpHeader;
    static readonly formUrlEncodedContentType: HttpHeader;
}


export type HttpHeader_Common = HttpHeader_Common$instance;

export abstract class HttpHeader_Names$instance {
    static readonly date: string;
    static readonly xMsDate: string;
    static readonly contentType: string;
    static readonly contentLength: string;
    static readonly eTag: string;
    static readonly xMsRequestId: string;
    static readonly userAgent: string;
    static readonly accept: string;
    static readonly authorization: string;
    static readonly range: string;
    static readonly xMsRange: string;
    static readonly ifMatch: string;
    static readonly ifNoneMatch: string;
    static readonly ifModifiedSince: string;
    static readonly ifUnmodifiedSince: string;
    static readonly prefer: string;
    static readonly referer: string;
    static readonly host: string;
    static readonly contentDisposition: string;
    static readonly wwwAuthenticate: string;
}


export type HttpHeader_Names = HttpHeader_Names$instance;

export abstract class MultipartResponse$instance {
    static parse(response: Response, expectCrLf: boolean, cancellationToken: CancellationToken): Response[];
    static parseAsync(response: Response, expectCrLf: boolean, cancellationToken: CancellationToken): Task<Response[]>;
}


export type MultipartResponse = MultipartResponse$instance;


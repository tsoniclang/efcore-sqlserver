// Generated by tsbindgen - Architecture
// Namespace: Microsoft.IdentityModel.JsonWebTokens
// Assembly: Microsoft.IdentityModel.JsonWebTokens

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import * as Microsoft_IdentityModel_Logging_Internal from "../../Microsoft.IdentityModel.Logging/internal/index.js";
import type { ISafeLogSecurityArtifact } from "../../Microsoft.IdentityModel.Logging/internal/index.js";
import * as Microsoft_IdentityModel_Tokens_Internal from "../../Microsoft.IdentityModel.Tokens/internal/index.js";
import type { EncryptingCredentials, SecurityKey, SecurityToken, SecurityTokenDescriptor, SigningCredentials, TokenHandler, TokenValidationParameters, TokenValidationResult } from "../../Microsoft.IdentityModel.Tokens/internal/index.js";
import type { IDictionary, IEnumerable } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Boolean as ClrBoolean, Byte, Char, DateTime, Int32, Object as ClrObject, ReadOnlyMemory, String as ClrString, Type, ValueType } from "@tsonic/dotnet/System.js";
import type { Claim } from "@tsonic/dotnet/System.Security.Claims.js";
import type { Regex } from "@tsonic/dotnet/System.Text.RegularExpressions.js";
import type { Task } from "@tsonic/dotnet/System.Threading.Tasks.js";

export interface JwtHeaderParameterNames$instance {
}


export const JwtHeaderParameterNames: {
    new(): JwtHeaderParameterNames;
    readonly alg: string;
    readonly apu: string;
    readonly apv: string;
    readonly epk: string;
    readonly cty: string;
    readonly enc: string;
    readonly IV: string;
    readonly jku: string;
    readonly jwk: string;
    readonly kid: string;
    readonly typ: string;
    readonly x5c: string;
    readonly x5t: string;
    readonly x5u: string;
    readonly zip: string;
};


export type JwtHeaderParameterNames = JwtHeaderParameterNames$instance;

export interface JwtRegisteredClaimNames$instance {
}


export const JwtRegisteredClaimNames: {
    new(): JwtRegisteredClaimNames;
    readonly actort: string;
    readonly acr: string;
    readonly address: string;
    readonly amr: string;
    readonly aud: string;
    readonly authTime: string;
    readonly azp: string;
    readonly birthdate: string;
    readonly cHash: string;
    readonly atHash: string;
    readonly email: string;
    readonly emailVerified: string;
    readonly exp: string;
    readonly gender: string;
    readonly familyName: string;
    readonly givenName: string;
    readonly iat: string;
    readonly iss: string;
    readonly jti: string;
    readonly locale: string;
    readonly middleName: string;
    readonly name: string;
    readonly nameId: string;
    readonly nickname: string;
    readonly nonce: string;
    readonly nbf: string;
    readonly phoneNumber: string;
    readonly phoneNumberVerified: string;
    readonly picture: string;
    readonly prn: string;
    readonly preferredUsername: string;
    readonly profile: string;
    readonly sid: string;
    readonly sub: string;
    readonly typ: string;
    readonly uniqueName: string;
    readonly updatedAt: string;
    readonly website: string;
    readonly zoneInfo: string;
};


export type JwtRegisteredClaimNames = JwtRegisteredClaimNames$instance;

export interface JsonWebToken$instance extends SecurityToken {
    readonly actor: string;
    readonly alg: string;
    readonly audiences: IEnumerable<System_Internal.String>;
    readonly authenticationTag: string;
    readonly azp: string;
    readonly ciphertext: string;
    readonly claims: IEnumerable<Claim>;
    readonly cty: string;
    readonly enc: string;
    readonly encodedHeader: string;
    readonly encodedPayload: string;
    readonly encodedSignature: string;
    readonly encodedToken: string;
    readonly encryptedKey: string;
    readonly id: string;
    readonly initializationVector: string;
    readonly innerToken: JsonWebToken;
    readonly isEncrypted: boolean;
    readonly isSigned: boolean;
    readonly issuedAt: DateTime;
    readonly issuer: string;
    readonly kid: string;
    readonly securityKey: SecurityKey;
    signingKey: SecurityKey;
    readonly subject: string | undefined;
    readonly typ: string;
    readonly validFrom: DateTime;
    readonly validTo: DateTime;
    readonly x5t: string;
    readonly zip: string;
    getClaim(key: string): Claim;
    getHeaderValue<T>(key: string): T;
    getPayloadValue<T>(key: string): T;
    toString(): string | undefined;
    tryGetClaim(key: string, value: Claim): boolean;
    tryGetHeaderValue<T>(key: string, value: T): boolean;
    tryGetPayloadValue<T>(key: string, value: T): boolean;
    tryGetValue<T>(key: string, value: T): boolean;
    unsafeToString(): string;
}


export const JsonWebToken: {
    new(jwtEncodedString: string): JsonWebToken;
    new(encodedTokenMemory: ReadOnlyMemory<System_Internal.Char>): JsonWebToken;
    new(header: string, payload: string): JsonWebToken;
};


export interface __JsonWebToken$views {
    As_ISafeLogSecurityArtifact(): Microsoft_IdentityModel_Logging_Internal.ISafeLogSecurityArtifact$instance;
}

export type JsonWebToken = JsonWebToken$instance & __JsonWebToken$views;


export interface JsonWebTokenHandler$instance extends TokenHandler {
    readonly canValidateToken: boolean;
    inboundClaimTypeMap: IDictionary<System_Internal.String, System_Internal.String>;
    mapInboundClaims: boolean;
    readonly tokenType: Type;
    canReadToken(token: string): boolean;
    createToken(payload: string): string;
    createToken(payload: string, additionalHeaderClaims: IDictionary<System_Internal.String, unknown>): string;
    createToken(payload: string, signingCredentials: SigningCredentials): string;
    createToken(payload: string, signingCredentials: SigningCredentials, additionalHeaderClaims: IDictionary<System_Internal.String, unknown>): string;
    createToken(tokenDescriptor: SecurityTokenDescriptor): string;
    createToken(payload: string, encryptingCredentials: EncryptingCredentials): string;
    createToken(payload: string, encryptingCredentials: EncryptingCredentials, additionalHeaderClaims: IDictionary<System_Internal.String, unknown>): string;
    createToken(payload: string, signingCredentials: SigningCredentials, encryptingCredentials: EncryptingCredentials): string;
    createToken(payload: string, signingCredentials: SigningCredentials, encryptingCredentials: EncryptingCredentials, additionalHeaderClaims: IDictionary<System_Internal.String, unknown>): string;
    createToken(payload: string, encryptingCredentials: EncryptingCredentials, compressionAlgorithm: string): string;
    createToken(payload: string, signingCredentials: SigningCredentials, encryptingCredentials: EncryptingCredentials, compressionAlgorithm: string): string;
    createToken(payload: string, signingCredentials: SigningCredentials, encryptingCredentials: EncryptingCredentials, compressionAlgorithm: string, additionalHeaderClaims: IDictionary<System_Internal.String, unknown>, additionalInnerHeaderClaims: IDictionary<System_Internal.String, unknown>): string;
    createToken(payload: string, signingCredentials: SigningCredentials, encryptingCredentials: EncryptingCredentials, compressionAlgorithm: string, additionalHeaderClaims: IDictionary<System_Internal.String, unknown>): string;
    decryptToken(jwtToken: JsonWebToken, validationParameters: TokenValidationParameters): string;
    encryptToken(innerJwt: string, encryptingCredentials: EncryptingCredentials): string;
    encryptToken(innerJwt: string, encryptingCredentials: EncryptingCredentials, additionalHeaderClaims: IDictionary<System_Internal.String, unknown>): string;
    encryptToken(innerJwt: string, encryptingCredentials: EncryptingCredentials, algorithm: string): string;
    encryptToken(innerJwt: string, encryptingCredentials: EncryptingCredentials, algorithm: string, additionalHeaderClaims: IDictionary<System_Internal.String, unknown>): string;
    readJsonWebToken(token: string): JsonWebToken;
    readToken(token: string): SecurityToken;
    validateToken(token: string, validationParameters: TokenValidationParameters): TokenValidationResult;
    validateTokenAsync(token: string, validationParameters: TokenValidationParameters): Task<TokenValidationResult>;
    validateTokenAsync(token: SecurityToken, validationParameters: TokenValidationParameters): Task<TokenValidationResult>;
    validateTokenAsync(token: string, validationParameters: TokenValidationParameters): Task<TokenValidationResult>;
    validateTokenAsync(token: SecurityToken, validationParameters: TokenValidationParameters): Task<TokenValidationResult>;
}


export const JsonWebTokenHandler: {
    new(): JsonWebTokenHandler;
    defaultInboundClaimTypeMap: IDictionary<System_Internal.String, System_Internal.String>;
    defaultMapInboundClaims: boolean;
    readonly base64UrlEncodedUnsignedJWSHeader: string;
    shortClaimTypeProperty: string;
};


export type JsonWebTokenHandler = JsonWebTokenHandler$instance;

export interface JwtTokenUtilities$instance {
}


export const JwtTokenUtilities: {
    new(): JwtTokenUtilities;
    regexJws: Regex;
    regexJwe: Regex;
    createEncodedSignature(input: string, signingCredentials: SigningCredentials, cacheProvider: boolean): string;
    createEncodedSignature(input: string, signingCredentials: SigningCredentials): string;
    generateKeyBytes(sizeInBits: int): byte[];
    getAllDecryptionKeys(validationParameters: TokenValidationParameters): IEnumerable<SecurityKey>;
};


export type JwtTokenUtilities = JwtTokenUtilities$instance;

export abstract class JsonClaimValueTypes$instance {
    static readonly json: string;
    static readonly jsonArray: string;
    static readonly jsonNull: string;
}


export type JsonClaimValueTypes = JsonClaimValueTypes$instance;

export abstract class JwtConstants$instance {
    static readonly headerType: string;
    static readonly headerTypeAlt: string;
    static readonly tokenType: string;
    static readonly tokenTypeAlt: string;
    static readonly jsonCompactSerializationRegex: string;
    static readonly jweCompactSerializationRegex: string;
    static readonly jweSegmentCount: int;
    static readonly jwsSegmentCount: int;
    static readonly maxJwtSegmentCount: int;
    static readonly directKeyUseAlg: string;
}


export type JwtConstants = JwtConstants$instance;


// Generated by tsbindgen - Architecture
// Namespace: System.IdentityModel.Tokens.Jwt
// Assembly: System.IdentityModel.Tokens.Jwt

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { JsonWebToken } from "../../Microsoft.IdentityModel.JsonWebTokens/internal/index.js";
import * as Microsoft_IdentityModel_Logging_Internal from "../../Microsoft.IdentityModel.Logging/internal/index.js";
import type { ISafeLogSecurityArtifact } from "../../Microsoft.IdentityModel.Logging/internal/index.js";
import * as Microsoft_IdentityModel_Tokens_Internal from "../../Microsoft.IdentityModel.Tokens/internal/index.js";
import type { EncryptingCredentials, ISecurityTokenValidator, SecurityKey, SecurityKeyIdentifierClause, SecurityToken, SecurityTokenDescriptor, SecurityTokenHandler, SigningCredentials, TokenValidationParameters, TokenValidationResult } from "../../Microsoft.IdentityModel.Tokens/internal/index.js";
import * as System_Collections_Generic_Internal from "@tsonic/dotnet/System.Collections.Generic.js";
import type { Dictionary, ICollection as ICollection__System_Collections_Generic, IDictionary as IDictionary__System_Collections_Generic, IEnumerable as IEnumerable__System_Collections_Generic, IList, IReadOnlyCollection, IReadOnlyDictionary, ISet, KeyValuePair } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Collections_Internal from "@tsonic/dotnet/System.Collections.js";
import type { ICollection, IDictionary, IEnumerable } from "@tsonic/dotnet/System.Collections.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Boolean as ClrBoolean, DateTime, Int32, Int64, Nullable, Object as ClrObject, String as ClrString, Type, ValueType, Void } from "@tsonic/dotnet/System.js";
import * as System_Runtime_Serialization_Internal from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { IDeserializationCallback, ISerializable } from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { Claim, ClaimsIdentity, ClaimsPrincipal } from "@tsonic/dotnet/System.Security.Claims.js";
import type { Task } from "@tsonic/dotnet/System.Threading.Tasks.js";
import type { XmlReader, XmlWriter } from "@tsonic/dotnet/System.Xml.js";

export interface JwtHeaderParameterNames$instance {
}


export const JwtHeaderParameterNames: {
    new(): JwtHeaderParameterNames;
    readonly alg: string;
    readonly cty: string;
    readonly enc: string;
    readonly IV: string;
    readonly jku: string;
    readonly jwk: string;
    readonly kid: string;
    readonly typ: string;
    readonly x5c: string;
    readonly x5t: string;
    readonly x5u: string;
    readonly zip: string;
    readonly epk: string;
    readonly apu: string;
    readonly apv: string;
};


export type JwtHeaderParameterNames = JwtHeaderParameterNames$instance;

export interface JwtRegisteredClaimNames$instance {
}


export const JwtRegisteredClaimNames: {
    new(): JwtRegisteredClaimNames;
    readonly actort: string;
    readonly acr: string;
    readonly amr: string;
    readonly address: string;
    readonly atHash: string;
    readonly aud: string;
    readonly authTime: string;
    readonly azp: string;
    readonly birthdate: string;
    readonly cHash: string;
    readonly email: string;
    readonly emailVerified: string;
    readonly exp: string;
    readonly gender: string;
    readonly familyName: string;
    readonly givenName: string;
    readonly iat: string;
    readonly iss: string;
    readonly jti: string;
    readonly locale: string;
    readonly middleName: string;
    readonly name: string;
    readonly nameId: string;
    readonly nickname: string;
    readonly nonce: string;
    readonly nbf: string;
    readonly phoneNumber: string;
    readonly phoneNumberVerified: string;
    readonly picture: string;
    readonly prn: string;
    readonly preferredUsername: string;
    readonly profile: string;
    readonly sid: string;
    readonly sub: string;
    readonly typ: string;
    readonly uniqueName: string;
    readonly updatedAt: string;
    readonly website: string;
    readonly zoneInfo: string;
};


export type JwtRegisteredClaimNames = JwtRegisteredClaimNames$instance;

export interface JwtHeader$instance extends Dictionary<System_Internal.String, unknown> {
    readonly alg: string;
    readonly cty: string;
    readonly enc: string;
    readonly encryptingCredentials: EncryptingCredentials;
    readonly IV: string;
    readonly kid: string;
    readonly signingCredentials: SigningCredentials;
    readonly typ: string;
    readonly x5c: string;
    readonly x5t: string;
    readonly zip: string;
    base64UrlEncode(): string;
    serializeToJson(): string;
}


export const JwtHeader: {
    new(): JwtHeader;
    new(signingCredentials: SigningCredentials): JwtHeader;
    new(encryptingCredentials: EncryptingCredentials): JwtHeader;
    new(signingCredentials: SigningCredentials, outboundAlgorithmMap: IDictionary__System_Collections_Generic<System_Internal.String, System_Internal.String>): JwtHeader;
    new(signingCredentials: SigningCredentials, outboundAlgorithmMap: IDictionary__System_Collections_Generic<System_Internal.String, System_Internal.String>, tokenType: string): JwtHeader;
    new(signingCredentials: SigningCredentials, outboundAlgorithmMap: IDictionary__System_Collections_Generic<System_Internal.String, System_Internal.String>, tokenType: string, additionalInnerHeaderClaims: IDictionary__System_Collections_Generic<System_Internal.String, unknown>): JwtHeader;
    new(encryptingCredentials: EncryptingCredentials, outboundAlgorithmMap: IDictionary__System_Collections_Generic<System_Internal.String, System_Internal.String>): JwtHeader;
    new(encryptingCredentials: EncryptingCredentials, outboundAlgorithmMap: IDictionary__System_Collections_Generic<System_Internal.String, System_Internal.String>, tokenType: string): JwtHeader;
    new(encryptingCredentials: EncryptingCredentials, outboundAlgorithmMap: IDictionary__System_Collections_Generic<System_Internal.String, System_Internal.String>, tokenType: string, additionalHeaderClaims: IDictionary__System_Collections_Generic<System_Internal.String, unknown>): JwtHeader;
    base64UrlDeserialize(base64UrlEncodedJsonString: string): JwtHeader;
};


export type JwtHeader = JwtHeader$instance;

export interface JwtPayload$instance extends Dictionary<System_Internal.String, unknown> {
    readonly acr: string;
    readonly actort: string;
    readonly amr: IList<System_Internal.String>;
    readonly aud: IList<System_Internal.String>;
    readonly authTime: Nullable<System_Internal.Int32>;
    readonly azp: string;
    readonly cHash: string;
    readonly claims: IEnumerable__System_Collections_Generic<Claim>;
    readonly exp: Nullable<System_Internal.Int32>;
    readonly expiration: Nullable<System_Internal.Int64>;
    readonly iat: Nullable<System_Internal.Int32>;
    readonly iss: string;
    readonly issuedAt: DateTime;
    readonly jti: string;
    readonly nbf: Nullable<System_Internal.Int32>;
    readonly nonce: string;
    readonly notBefore: Nullable<System_Internal.Int64>;
    readonly sub: string;
    readonly validFrom: DateTime;
    readonly validTo: DateTime;
    addClaim(claim: Claim): void;
    addClaims(claims: IEnumerable__System_Collections_Generic<Claim>): void;
    base64UrlEncode(): string;
    serializeToJson(): string;
}


export const JwtPayload: {
    new(): JwtPayload;
    new(claims: IEnumerable__System_Collections_Generic<Claim>): JwtPayload;
    new(issuer: string, audience: string, claims: IEnumerable__System_Collections_Generic<Claim>, notBefore: Nullable<DateTime>, expires: Nullable<DateTime>): JwtPayload;
    new(issuer: string, audience: string, claims: IEnumerable__System_Collections_Generic<Claim>, notBefore: Nullable<DateTime>, expires: Nullable<DateTime>, issuedAt: Nullable<DateTime>): JwtPayload;
    new(issuer: string, audience: string, claims: IEnumerable__System_Collections_Generic<Claim>, claimsCollection: IDictionary__System_Collections_Generic<System_Internal.String, unknown>, notBefore: Nullable<DateTime>, expires: Nullable<DateTime>, issuedAt: Nullable<DateTime>): JwtPayload;
    base64UrlDeserialize(base64UrlEncodedJsonString: string): JwtPayload;
    deserialize(jsonString: string): JwtPayload;
};


export type JwtPayload = JwtPayload$instance;

export interface JwtSecurityToken$instance extends SecurityToken {
    readonly actor: string;
    readonly audiences: IEnumerable__System_Collections_Generic<System_Internal.String>;
    readonly claims: IEnumerable__System_Collections_Generic<Claim>;
    readonly encodedHeader: string;
    readonly encodedPayload: string;
    readonly encryptingCredentials: EncryptingCredentials;
    readonly header: JwtHeader;
    readonly id: string;
    readonly innerToken: JwtSecurityToken;
    readonly issuedAt: DateTime;
    readonly issuer: string;
    readonly payload: JwtPayload;
    readonly rawAuthenticationTag: string;
    readonly rawCiphertext: string;
    readonly rawData: string;
    readonly rawEncryptedKey: string;
    readonly rawHeader: string;
    readonly rawInitializationVector: string;
    readonly rawPayload: string;
    readonly rawSignature: string;
    readonly securityKey: SecurityKey;
    readonly signatureAlgorithm: string;
    readonly signingCredentials: SigningCredentials;
    signingKey: SecurityKey;
    readonly subject: string | undefined;
    readonly validFrom: DateTime;
    readonly validTo: DateTime;
    toString(): string | undefined;
    unsafeToString(): string;
}


export const JwtSecurityToken: {
    new(jwtEncodedString: string): JwtSecurityToken;
    new(header: JwtHeader, payload: JwtPayload, rawHeader: string, rawPayload: string, rawSignature: string): JwtSecurityToken;
    new(header: JwtHeader, innerToken: JwtSecurityToken, rawHeader: string, rawEncryptedKey: string, rawInitializationVector: string, rawCiphertext: string, rawAuthenticationTag: string): JwtSecurityToken;
    new(header: JwtHeader, payload: JwtPayload): JwtSecurityToken;
    new(issuer: string, audience: string, claims: IEnumerable__System_Collections_Generic<Claim>, notBefore: Nullable<DateTime>, expires: Nullable<DateTime>, signingCredentials: SigningCredentials): JwtSecurityToken;
};


export interface __JwtSecurityToken$views {
    As_ISafeLogSecurityArtifact(): Microsoft_IdentityModel_Logging_Internal.ISafeLogSecurityArtifact$instance;
}

export type JwtSecurityToken = JwtSecurityToken$instance & __JwtSecurityToken$views;


export interface JwtSecurityTokenHandler$instance extends SecurityTokenHandler {
    readonly canValidateToken: boolean;
    readonly canWriteToken: boolean;
    inboundClaimFilter: ISet<System_Internal.String>;
    inboundClaimTypeMap: IDictionary__System_Collections_Generic<System_Internal.String, System_Internal.String>;
    mapInboundClaims: boolean;
    readonly outboundAlgorithmMap: IDictionary__System_Collections_Generic<System_Internal.String, System_Internal.String>;
    outboundClaimTypeMap: IDictionary__System_Collections_Generic<System_Internal.String, System_Internal.String>;
    readonly tokenType: Type;
    canReadToken(token: string): boolean;
    canReadToken(reader: XmlReader): boolean;
    createEncodedJwt(tokenDescriptor: SecurityTokenDescriptor): string;
    createEncodedJwt(issuer: string, audience: string, subject: ClaimsIdentity, notBefore: Nullable<DateTime>, expires: Nullable<DateTime>, issuedAt: Nullable<DateTime>, signingCredentials: SigningCredentials): string;
    createEncodedJwt(issuer: string, audience: string, subject: ClaimsIdentity, notBefore: Nullable<DateTime>, expires: Nullable<DateTime>, issuedAt: Nullable<DateTime>, signingCredentials: SigningCredentials, encryptingCredentials: EncryptingCredentials): string;
    createEncodedJwt(issuer: string, audience: string, subject: ClaimsIdentity, notBefore: Nullable<DateTime>, expires: Nullable<DateTime>, issuedAt: Nullable<DateTime>, signingCredentials: SigningCredentials, encryptingCredentials: EncryptingCredentials, claimCollection: IDictionary__System_Collections_Generic<System_Internal.String, unknown>): string;
    createJwtSecurityToken(tokenDescriptor: SecurityTokenDescriptor): JwtSecurityToken;
    createJwtSecurityToken(issuer: string, audience: string, subject: ClaimsIdentity, notBefore: Nullable<DateTime>, expires: Nullable<DateTime>, issuedAt: Nullable<DateTime>, signingCredentials: SigningCredentials, encryptingCredentials: EncryptingCredentials): JwtSecurityToken;
    createJwtSecurityToken(issuer: string, audience: string, subject: ClaimsIdentity, notBefore: Nullable<DateTime>, expires: Nullable<DateTime>, issuedAt: Nullable<DateTime>, signingCredentials: SigningCredentials, encryptingCredentials: EncryptingCredentials, claimCollection: IDictionary__System_Collections_Generic<System_Internal.String, unknown>): JwtSecurityToken;
    createJwtSecurityToken(issuer?: string, audience?: string, subject?: ClaimsIdentity, notBefore?: Nullable<DateTime>, expires?: Nullable<DateTime>, issuedAt?: Nullable<DateTime>, signingCredentials?: SigningCredentials): JwtSecurityToken;
    createToken(tokenDescriptor: SecurityTokenDescriptor): SecurityToken;
    readJwtToken(token: string): JwtSecurityToken;
    readToken(token: string): SecurityToken;
    readToken(reader: XmlReader, validationParameters: TokenValidationParameters): SecurityToken;
    readToken(reader: XmlReader): SecurityToken;
    validateToken(token: string, validationParameters: TokenValidationParameters, validatedToken: SecurityToken): ClaimsPrincipal;
    validateToken(reader: XmlReader, validationParameters: TokenValidationParameters, validatedToken: SecurityToken): ClaimsPrincipal;
    validateTokenAsync(token: string, validationParameters: TokenValidationParameters): Task<TokenValidationResult>;
    validateTokenAsync(token: string, validationParameters: TokenValidationParameters): Task<TokenValidationResult>;
    validateTokenAsync(token: SecurityToken, validationParameters: TokenValidationParameters): Task<TokenValidationResult>;
    writeToken(token: SecurityToken): string;
    writeToken(writer: XmlWriter, token: SecurityToken): void;
}


export const JwtSecurityTokenHandler: {
    new(): JwtSecurityTokenHandler;
    defaultInboundClaimTypeMap: IDictionary__System_Collections_Generic<System_Internal.String, System_Internal.String>;
    defaultMapInboundClaims: boolean;
    defaultOutboundClaimTypeMap: IDictionary__System_Collections_Generic<System_Internal.String, System_Internal.String>;
    defaultInboundClaimFilter: ISet<System_Internal.String>;
    defaultOutboundAlgorithmMap: IDictionary__System_Collections_Generic<System_Internal.String, System_Internal.String>;
    shortClaimTypeProperty: string;
    jsonClaimTypeProperty: string;
};


export interface __JwtSecurityTokenHandler$views {
    As_ISecurityTokenValidator(): Microsoft_IdentityModel_Tokens_Internal.ISecurityTokenValidator$instance;
}

export type JwtSecurityTokenHandler = JwtSecurityTokenHandler$instance & __JwtSecurityTokenHandler$views;


export abstract class JsonClaimValueTypes$instance {
    static readonly json: string;
    static readonly jsonArray: string;
    static readonly jsonNull: string;
}


export type JsonClaimValueTypes = JsonClaimValueTypes$instance;

export abstract class JwtConstants$instance {
    static readonly headerType: string;
    static readonly headerTypeAlt: string;
    static readonly tokenType: string;
    static readonly tokenTypeAlt: string;
    static readonly jsonCompactSerializationRegex: string;
    static readonly jweCompactSerializationRegex: string;
    static readonly directKeyUseAlg: string;
}


export type JwtConstants = JwtConstants$instance;

export abstract class JwtSecurityTokenConverter$instance {
    static convert(token: JsonWebToken): JwtSecurityToken;
}


export type JwtSecurityTokenConverter = JwtSecurityTokenConverter$instance;


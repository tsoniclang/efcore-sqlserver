// Generated by tsbindgen - Architecture
// Namespace: Azure.Identity
// Assembly: Azure.Identity

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import type { HttpPipelinePolicy, HttpPipelineTransport } from "../../Azure.Core.Pipeline/internal/index.js";
import * as Azure_Core_Internal from "../../Azure.Core/internal/index.js";
import type { AccessToken, ClientOptions, DiagnosticsOptions, HttpPipelinePosition, ResourceIdentifier, RetryOptions, TokenCredential, TokenRequestContext } from "../../Azure.Core/internal/index.js";
import type { AuthenticationToken, GetTokenOptions } from "../../System.ClientModel.Primitives/internal/index.js";
import type { IList, IReadOnlyCollection, IReadOnlyDictionary } from "@tsonic/dotnet/System.Collections.Generic.js";
import type { Stream } from "@tsonic/dotnet/System.IO.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Boolean as ClrBoolean, Byte, DateTimeOffset, Exception, Func, Int32, Nullable, Object as ClrObject, ReadOnlyMemory, String as ClrString, TimeSpan, Uri, ValueType, Void } from "@tsonic/dotnet/System.js";
import * as System_Runtime_Serialization_Internal from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { ISerializable } from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { X509Certificate2 } from "@tsonic/dotnet/System.Security.Cryptography.X509Certificates.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading.js";
import type { Task, ValueTask } from "@tsonic/dotnet/System.Threading.Tasks.js";

export interface DeviceCodeInfo$instance {
    readonly clientId: string;
    readonly deviceCode: string;
    readonly expiresOn: DateTimeOffset;
    readonly message: string;
    readonly scopes: IReadOnlyCollection<System_Internal.String>;
    readonly userCode: string;
    readonly verificationUri: Uri;
}


export const DeviceCodeInfo: {
    new(): DeviceCodeInfo;
};


export type DeviceCodeInfo = DeviceCodeInfo$instance;

export interface TokenCacheData$instance {
    readonly cacheBytes: ReadOnlyMemory<System_Internal.Byte>;
}


export const TokenCacheData: {
    new(cacheBytes: ReadOnlyMemory<System_Internal.Byte>): TokenCacheData;
};


export type TokenCacheData = TokenCacheData$instance;

export interface AuthenticationFailedException$instance extends Exception {
}


export const AuthenticationFailedException: {
    new(message: string): AuthenticationFailedException;
    new(message: string, innerException: Exception): AuthenticationFailedException;
};


export type AuthenticationFailedException = AuthenticationFailedException$instance;

export interface AuthenticationRecord$instance {
    readonly authority: string;
    readonly clientId: string;
    readonly homeAccountId: string;
    readonly tenantId: string;
    readonly username: string;
    serialize(stream: Stream, cancellationToken?: CancellationToken): void;
    serializeAsync(stream: Stream, cancellationToken?: CancellationToken): Task;
}


export const AuthenticationRecord: {
    new(): AuthenticationRecord;
    deserialize(stream: Stream, cancellationToken?: CancellationToken): AuthenticationRecord;
    deserializeAsync(stream: Stream, cancellationToken?: CancellationToken): Task<AuthenticationRecord>;
};


export type AuthenticationRecord = AuthenticationRecord$instance;

export interface AuthenticationRequiredException$instance extends CredentialUnavailableException {
    readonly tokenRequestContext: TokenRequestContext;
}


export const AuthenticationRequiredException: {
    new(message: string, context: TokenRequestContext): AuthenticationRequiredException;
    new(message: string, context: TokenRequestContext, innerException: Exception): AuthenticationRequiredException;
};


export type AuthenticationRequiredException = AuthenticationRequiredException$instance;

export interface AuthorizationCodeCredential$instance extends TokenCredential {
    getToken(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): AccessToken;
    getToken(properties: GetTokenOptions, cancellationToken: CancellationToken): AuthenticationToken;
    getTokenAsync(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): ValueTask<AccessToken>;
    getTokenAsync(properties: GetTokenOptions, cancellationToken: CancellationToken): ValueTask<AuthenticationToken>;
}


export const AuthorizationCodeCredential: {
    new(tenantId: string, clientId: string, clientSecret: string, authorizationCode: string): AuthorizationCodeCredential;
    new(tenantId: string, clientId: string, clientSecret: string, authorizationCode: string, options: AuthorizationCodeCredentialOptions): AuthorizationCodeCredential;
    new(tenantId: string, clientId: string, clientSecret: string, authorizationCode: string, options: TokenCredentialOptions): AuthorizationCodeCredential;
};


export type AuthorizationCodeCredential = AuthorizationCodeCredential$instance;

export interface AuthorizationCodeCredentialOptions$instance extends TokenCredentialOptions {
    readonly additionallyAllowedTenants: IList<System_Internal.String>;
    disableInstanceDiscovery: boolean;
    redirectUri: Uri;
}


export const AuthorizationCodeCredentialOptions: {
    new(): AuthorizationCodeCredentialOptions;
};


export type AuthorizationCodeCredentialOptions = AuthorizationCodeCredentialOptions$instance;

export interface AzureCliCredential$instance extends TokenCredential {
    getToken(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): AccessToken;
    getToken(properties: GetTokenOptions, cancellationToken: CancellationToken): AuthenticationToken;
    getTokenAsync(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): ValueTask<AccessToken>;
    getTokenAsync(properties: GetTokenOptions, cancellationToken: CancellationToken): ValueTask<AuthenticationToken>;
}


export const AzureCliCredential: {
    new(): AzureCliCredential;
    new(options: AzureCliCredentialOptions): AzureCliCredential;
};


export type AzureCliCredential = AzureCliCredential$instance;

export interface AzureCliCredentialOptions$instance extends TokenCredentialOptions {
    readonly additionallyAllowedTenants: IList<System_Internal.String>;
    processTimeout: Nullable<TimeSpan>;
    subscription: string;
    tenantId: string;
}


export const AzureCliCredentialOptions: {
    new(): AzureCliCredentialOptions;
};


export type AzureCliCredentialOptions = AzureCliCredentialOptions$instance;

export interface AzureDeveloperCliCredential$instance extends TokenCredential {
    getToken(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): AccessToken;
    getToken(properties: GetTokenOptions, cancellationToken: CancellationToken): AuthenticationToken;
    getTokenAsync(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): ValueTask<AccessToken>;
    getTokenAsync(properties: GetTokenOptions, cancellationToken: CancellationToken): ValueTask<AuthenticationToken>;
}


export const AzureDeveloperCliCredential: {
    new(): AzureDeveloperCliCredential;
    new(options: AzureDeveloperCliCredentialOptions): AzureDeveloperCliCredential;
};


export type AzureDeveloperCliCredential = AzureDeveloperCliCredential$instance;

export interface AzureDeveloperCliCredentialOptions$instance extends TokenCredentialOptions {
    readonly additionallyAllowedTenants: IList<System_Internal.String>;
    processTimeout: Nullable<TimeSpan>;
    tenantId: string;
}


export const AzureDeveloperCliCredentialOptions: {
    new(): AzureDeveloperCliCredentialOptions;
};


export type AzureDeveloperCliCredentialOptions = AzureDeveloperCliCredentialOptions$instance;

export interface AzurePipelinesCredential$instance extends TokenCredential {
    getToken(requestContext: TokenRequestContext, cancellationToken: CancellationToken): AccessToken;
    getToken(properties: GetTokenOptions, cancellationToken: CancellationToken): AuthenticationToken;
    getTokenAsync(requestContext: TokenRequestContext, cancellationToken: CancellationToken): ValueTask<AccessToken>;
    getTokenAsync(properties: GetTokenOptions, cancellationToken: CancellationToken): ValueTask<AuthenticationToken>;
}


export const AzurePipelinesCredential: {
    new(tenantId: string, clientId: string, serviceConnectionId: string, systemAccessToken: string, options: AzurePipelinesCredentialOptions): AzurePipelinesCredential;
};


export type AzurePipelinesCredential = AzurePipelinesCredential$instance;

export interface AzurePipelinesCredentialOptions$instance extends TokenCredentialOptions {
    readonly additionallyAllowedTenants: IList<System_Internal.String>;
    disableInstanceDiscovery: boolean;
    tokenCachePersistenceOptions: TokenCachePersistenceOptions;
}


export const AzurePipelinesCredentialOptions: {
    new(): AzurePipelinesCredentialOptions;
};


export type AzurePipelinesCredentialOptions = AzurePipelinesCredentialOptions$instance;

export interface AzurePowerShellCredential$instance extends TokenCredential {
    getToken(requestContext: TokenRequestContext, cancellationToken: CancellationToken): AccessToken;
    getToken(properties: GetTokenOptions, cancellationToken: CancellationToken): AuthenticationToken;
    getTokenAsync(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): ValueTask<AccessToken>;
    getTokenAsync(properties: GetTokenOptions, cancellationToken: CancellationToken): ValueTask<AuthenticationToken>;
}


export const AzurePowerShellCredential: {
    new(): AzurePowerShellCredential;
    new(options: AzurePowerShellCredentialOptions): AzurePowerShellCredential;
};


export type AzurePowerShellCredential = AzurePowerShellCredential$instance;

export interface AzurePowerShellCredentialOptions$instance extends TokenCredentialOptions {
    readonly additionallyAllowedTenants: IList<System_Internal.String>;
    processTimeout: Nullable<TimeSpan>;
    tenantId: string;
}


export const AzurePowerShellCredentialOptions: {
    new(): AzurePowerShellCredentialOptions;
};


export type AzurePowerShellCredentialOptions = AzurePowerShellCredentialOptions$instance;

export interface BrowserCustomizationOptions$instance {
    errorMessage: string;
    successMessage: string;
    useEmbeddedWebView: Nullable<System_Internal.Boolean>;
}


export const BrowserCustomizationOptions: {
    new(): BrowserCustomizationOptions;
};


export type BrowserCustomizationOptions = BrowserCustomizationOptions$instance;

export interface ChainedTokenCredential$instance extends TokenCredential {
    getToken(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): AccessToken;
    getToken(properties: GetTokenOptions, cancellationToken: CancellationToken): AuthenticationToken;
    getTokenAsync(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): ValueTask<AccessToken>;
    getTokenAsync(properties: GetTokenOptions, cancellationToken: CancellationToken): ValueTask<AuthenticationToken>;
}


export const ChainedTokenCredential: {
    new(sources: TokenCredential[]): ChainedTokenCredential;
};


export type ChainedTokenCredential = ChainedTokenCredential$instance;

export interface ClientAssertionCredential$instance extends TokenCredential {
    getToken(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): AccessToken;
    getToken(properties: GetTokenOptions, cancellationToken: CancellationToken): AuthenticationToken;
    getTokenAsync(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): ValueTask<AccessToken>;
    getTokenAsync(properties: GetTokenOptions, cancellationToken: CancellationToken): ValueTask<AuthenticationToken>;
}


export const ClientAssertionCredential: {
    new(tenantId: string, clientId: string, assertionCallback: Func<CancellationToken, Task<System_Internal.String>>, options: ClientAssertionCredentialOptions): ClientAssertionCredential;
    new(tenantId: string, clientId: string, assertionCallback: Func<System_Internal.String>, options: ClientAssertionCredentialOptions): ClientAssertionCredential;
};


export type ClientAssertionCredential = ClientAssertionCredential$instance;

export interface ClientAssertionCredentialOptions$instance extends TokenCredentialOptions {
    readonly additionallyAllowedTenants: IList<System_Internal.String>;
    disableInstanceDiscovery: boolean;
    tokenCachePersistenceOptions: TokenCachePersistenceOptions;
}


export const ClientAssertionCredentialOptions: {
    new(): ClientAssertionCredentialOptions;
};


export type ClientAssertionCredentialOptions = ClientAssertionCredentialOptions$instance;

export interface ClientCertificateCredential$instance extends TokenCredential {
    getToken(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): AccessToken;
    getToken(properties: GetTokenOptions, cancellationToken: CancellationToken): AuthenticationToken;
    getTokenAsync(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): ValueTask<AccessToken>;
    getTokenAsync(properties: GetTokenOptions, cancellationToken: CancellationToken): ValueTask<AuthenticationToken>;
}


export const ClientCertificateCredential: {
    new(tenantId: string, clientId: string, clientCertificatePath: string): ClientCertificateCredential;
    new(tenantId: string, clientId: string, clientCertificatePath: string, options: TokenCredentialOptions): ClientCertificateCredential;
    new(tenantId: string, clientId: string, clientCertificatePath: string, options: ClientCertificateCredentialOptions): ClientCertificateCredential;
    new(tenantId: string, clientId: string, clientCertificate: X509Certificate2): ClientCertificateCredential;
    new(tenantId: string, clientId: string, clientCertificate: X509Certificate2, options: TokenCredentialOptions): ClientCertificateCredential;
    new(tenantId: string, clientId: string, clientCertificate: X509Certificate2, options: ClientCertificateCredentialOptions): ClientCertificateCredential;
};


export type ClientCertificateCredential = ClientCertificateCredential$instance;

export interface ClientCertificateCredentialOptions$instance extends TokenCredentialOptions {
    readonly additionallyAllowedTenants: IList<System_Internal.String>;
    disableInstanceDiscovery: boolean;
    sendCertificateChain: boolean;
    tokenCachePersistenceOptions: TokenCachePersistenceOptions;
}


export const ClientCertificateCredentialOptions: {
    new(): ClientCertificateCredentialOptions;
};


export type ClientCertificateCredentialOptions = ClientCertificateCredentialOptions$instance;

export interface ClientSecretCredential$instance extends TokenCredential {
    getToken(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): AccessToken;
    getToken(properties: GetTokenOptions, cancellationToken: CancellationToken): AuthenticationToken;
    getTokenAsync(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): ValueTask<AccessToken>;
    getTokenAsync(properties: GetTokenOptions, cancellationToken: CancellationToken): ValueTask<AuthenticationToken>;
}


export const ClientSecretCredential: {
    new(tenantId: string, clientId: string, clientSecret: string): ClientSecretCredential;
    new(tenantId: string, clientId: string, clientSecret: string, options: ClientSecretCredentialOptions): ClientSecretCredential;
    new(tenantId: string, clientId: string, clientSecret: string, options: TokenCredentialOptions): ClientSecretCredential;
};


export type ClientSecretCredential = ClientSecretCredential$instance;

export interface ClientSecretCredentialOptions$instance extends TokenCredentialOptions {
    readonly additionallyAllowedTenants: IList<System_Internal.String>;
    disableInstanceDiscovery: boolean;
    tokenCachePersistenceOptions: TokenCachePersistenceOptions;
}


export const ClientSecretCredentialOptions: {
    new(): ClientSecretCredentialOptions;
};


export type ClientSecretCredentialOptions = ClientSecretCredentialOptions$instance;

export interface CredentialUnavailableException$instance extends AuthenticationFailedException {
}


export const CredentialUnavailableException: {
    new(message: string): CredentialUnavailableException;
    new(message: string, innerException: Exception): CredentialUnavailableException;
};


export type CredentialUnavailableException = CredentialUnavailableException$instance;

export interface DefaultAzureCredential$instance extends TokenCredential {
    getToken(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): AccessToken;
    getToken(properties: GetTokenOptions, cancellationToken: CancellationToken): AuthenticationToken;
    getTokenAsync(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): ValueTask<AccessToken>;
    getTokenAsync(properties: GetTokenOptions, cancellationToken: CancellationToken): ValueTask<AuthenticationToken>;
}


export const DefaultAzureCredential: {
    new(includeInteractiveCredentials: boolean): DefaultAzureCredential;
    new(options: DefaultAzureCredentialOptions): DefaultAzureCredential;
};


export type DefaultAzureCredential = DefaultAzureCredential$instance;

export interface DefaultAzureCredentialOptions$instance extends TokenCredentialOptions {
    readonly additionallyAllowedTenants: IList<System_Internal.String>;
    credentialProcessTimeout: Nullable<TimeSpan>;
    disableInstanceDiscovery: boolean;
    excludeAzureCliCredential: boolean;
    excludeAzureDeveloperCliCredential: boolean;
    excludeAzurePowerShellCredential: boolean;
    excludeEnvironmentCredential: boolean;
    excludeInteractiveBrowserCredential: boolean;
    excludeManagedIdentityCredential: boolean;
    excludeSharedTokenCacheCredential: boolean;
    excludeVisualStudioCodeCredential: boolean;
    excludeVisualStudioCredential: boolean;
    excludeWorkloadIdentityCredential: boolean;
    interactiveBrowserCredentialClientId: string;
    interactiveBrowserTenantId: string;
    managedIdentityClientId: string;
    managedIdentityResourceId: ResourceIdentifier;
    sharedTokenCacheTenantId: string;
    sharedTokenCacheUsername: string;
    tenantId: string;
    visualStudioCodeTenantId: string;
    visualStudioTenantId: string;
    workloadIdentityClientId: string;
}


export const DefaultAzureCredentialOptions: {
    new(): DefaultAzureCredentialOptions;
};


export type DefaultAzureCredentialOptions = DefaultAzureCredentialOptions$instance;

export interface DeviceCodeCredential$instance extends TokenCredential {
    authenticate(cancellationToken?: CancellationToken): AuthenticationRecord;
    authenticate(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): AuthenticationRecord;
    authenticateAsync(cancellationToken?: CancellationToken): Task<AuthenticationRecord>;
    authenticateAsync(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): Task<AuthenticationRecord>;
    getToken(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): AccessToken;
    getToken(properties: GetTokenOptions, cancellationToken: CancellationToken): AuthenticationToken;
    getTokenAsync(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): ValueTask<AccessToken>;
    getTokenAsync(properties: GetTokenOptions, cancellationToken: CancellationToken): ValueTask<AuthenticationToken>;
}


export const DeviceCodeCredential: {
    new(): DeviceCodeCredential;
    new(options: DeviceCodeCredentialOptions): DeviceCodeCredential;
    new(deviceCodeCallback: Func<DeviceCodeInfo, CancellationToken, Task>, clientId: string, options: TokenCredentialOptions): DeviceCodeCredential;
    new(deviceCodeCallback: Func<DeviceCodeInfo, CancellationToken, Task>, tenantId: string, clientId: string, options: TokenCredentialOptions): DeviceCodeCredential;
};


export type DeviceCodeCredential = DeviceCodeCredential$instance;

export interface DeviceCodeCredentialOptions$instance extends TokenCredentialOptions {
    readonly additionallyAllowedTenants: IList<System_Internal.String>;
    authenticationRecord: AuthenticationRecord;
    clientId: string;
    deviceCodeCallback: Func<DeviceCodeInfo, CancellationToken, Task>;
    disableAutomaticAuthentication: boolean;
    disableInstanceDiscovery: boolean;
    tenantId: string;
    tokenCachePersistenceOptions: TokenCachePersistenceOptions;
}


export const DeviceCodeCredentialOptions: {
    new(): DeviceCodeCredentialOptions;
};


export type DeviceCodeCredentialOptions = DeviceCodeCredentialOptions$instance;

export interface EnvironmentCredential$instance extends TokenCredential {
    getToken(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): AccessToken;
    getToken(properties: GetTokenOptions, cancellationToken: CancellationToken): AuthenticationToken;
    getTokenAsync(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): ValueTask<AccessToken>;
    getTokenAsync(properties: GetTokenOptions, cancellationToken: CancellationToken): ValueTask<AuthenticationToken>;
}


export const EnvironmentCredential: {
    new(): EnvironmentCredential;
    new(options: TokenCredentialOptions): EnvironmentCredential;
    new(options: EnvironmentCredentialOptions): EnvironmentCredential;
};


export type EnvironmentCredential = EnvironmentCredential$instance;

export interface EnvironmentCredentialOptions$instance extends TokenCredentialOptions {
    readonly additionallyAllowedTenants: IList<System_Internal.String>;
    disableInstanceDiscovery: boolean;
}


export const EnvironmentCredentialOptions: {
    new(): EnvironmentCredentialOptions;
};


export type EnvironmentCredentialOptions = EnvironmentCredentialOptions$instance;

export interface InteractiveBrowserCredential$instance extends TokenCredential {
    authenticate(cancellationToken?: CancellationToken): AuthenticationRecord;
    authenticate(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): AuthenticationRecord;
    authenticateAsync(cancellationToken?: CancellationToken): Task<AuthenticationRecord>;
    authenticateAsync(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): Task<AuthenticationRecord>;
    getToken(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): AccessToken;
    getToken(properties: GetTokenOptions, cancellationToken: CancellationToken): AuthenticationToken;
    getTokenAsync(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): ValueTask<AccessToken>;
    getTokenAsync(properties: GetTokenOptions, cancellationToken: CancellationToken): ValueTask<AuthenticationToken>;
}


export const InteractiveBrowserCredential: {
    new(): InteractiveBrowserCredential;
    new(options: InteractiveBrowserCredentialOptions): InteractiveBrowserCredential;
    new(clientId: string): InteractiveBrowserCredential;
    new(tenantId: string, clientId: string, options: TokenCredentialOptions): InteractiveBrowserCredential;
};


export type InteractiveBrowserCredential = InteractiveBrowserCredential$instance;

export interface InteractiveBrowserCredentialOptions$instance extends TokenCredentialOptions {
    readonly additionallyAllowedTenants: IList<System_Internal.String>;
    authenticationRecord: AuthenticationRecord;
    browserCustomization: BrowserCustomizationOptions;
    clientId: string;
    disableAutomaticAuthentication: boolean;
    disableInstanceDiscovery: boolean;
    loginHint: string;
    redirectUri: Uri;
    tenantId: string;
    tokenCachePersistenceOptions: TokenCachePersistenceOptions;
}


export const InteractiveBrowserCredentialOptions: {
    new(): InteractiveBrowserCredentialOptions;
};


export type InteractiveBrowserCredentialOptions = InteractiveBrowserCredentialOptions$instance;

export interface ManagedIdentityCredential$instance extends TokenCredential {
    getToken(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): AccessToken;
    getToken(properties: GetTokenOptions, cancellationToken: CancellationToken): AuthenticationToken;
    getTokenAsync(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): ValueTask<AccessToken>;
    getTokenAsync(properties: GetTokenOptions, cancellationToken: CancellationToken): ValueTask<AuthenticationToken>;
}


export const ManagedIdentityCredential: {
    new(clientId: string, options: TokenCredentialOptions): ManagedIdentityCredential;
    new(resourceId: ResourceIdentifier, options: TokenCredentialOptions): ManagedIdentityCredential;
    new(id: ManagedIdentityId): ManagedIdentityCredential;
    new(options: ManagedIdentityCredentialOptions): ManagedIdentityCredential;
};


export type ManagedIdentityCredential = ManagedIdentityCredential$instance;

export interface ManagedIdentityCredentialOptions$instance extends TokenCredentialOptions {
}


export const ManagedIdentityCredentialOptions: {
    new(managedIdentityId: ManagedIdentityId): ManagedIdentityCredentialOptions;
};


export type ManagedIdentityCredentialOptions = ManagedIdentityCredentialOptions$instance;

export interface ManagedIdentityId$instance {
    toString(): string | undefined;
}


export const ManagedIdentityId: {
    new(): ManagedIdentityId;
    readonly systemAssigned: ManagedIdentityId;
    fromUserAssignedClientId(id: string): ManagedIdentityId;
    fromUserAssignedObjectId(id: string): ManagedIdentityId;
    fromUserAssignedResourceId(id: ResourceIdentifier): ManagedIdentityId;
};


export type ManagedIdentityId = ManagedIdentityId$instance;

export interface OnBehalfOfCredential$instance extends TokenCredential {
    getToken(requestContext: TokenRequestContext, cancellationToken: CancellationToken): AccessToken;
    getToken(properties: GetTokenOptions, cancellationToken: CancellationToken): AuthenticationToken;
    getTokenAsync(requestContext: TokenRequestContext, cancellationToken: CancellationToken): ValueTask<AccessToken>;
    getTokenAsync(properties: GetTokenOptions, cancellationToken: CancellationToken): ValueTask<AuthenticationToken>;
}


export const OnBehalfOfCredential: {
    new(tenantId: string, clientId: string, clientCertificate: X509Certificate2, userAssertion: string): OnBehalfOfCredential;
    new(tenantId: string, clientId: string, clientCertificate: X509Certificate2, userAssertion: string, options: OnBehalfOfCredentialOptions): OnBehalfOfCredential;
    new(tenantId: string, clientId: string, clientSecret: string, userAssertion: string): OnBehalfOfCredential;
    new(tenantId: string, clientId: string, clientSecret: string, userAssertion: string, options: OnBehalfOfCredentialOptions): OnBehalfOfCredential;
    new(tenantId: string, clientId: string, clientAssertionCallback: Func<CancellationToken, Task<System_Internal.String>>, userAssertion: string, options: OnBehalfOfCredentialOptions): OnBehalfOfCredential;
    new(tenantId: string, clientId: string, clientAssertionCallback: Func<System_Internal.String>, userAssertion: string, options: OnBehalfOfCredentialOptions): OnBehalfOfCredential;
};


export type OnBehalfOfCredential = OnBehalfOfCredential$instance;

export interface OnBehalfOfCredentialOptions$instance extends TokenCredentialOptions {
    readonly additionallyAllowedTenants: IList<System_Internal.String>;
    disableInstanceDiscovery: boolean;
    sendCertificateChain: boolean;
    tokenCachePersistenceOptions: TokenCachePersistenceOptions;
}


export const OnBehalfOfCredentialOptions: {
    new(): OnBehalfOfCredentialOptions;
};


export type OnBehalfOfCredentialOptions = OnBehalfOfCredentialOptions$instance;

export interface SharedTokenCacheCredential$instance extends TokenCredential {
    getToken(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): AccessToken;
    getToken(properties: GetTokenOptions, cancellationToken: CancellationToken): AuthenticationToken;
    getTokenAsync(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): ValueTask<AccessToken>;
    getTokenAsync(properties: GetTokenOptions, cancellationToken: CancellationToken): ValueTask<AuthenticationToken>;
}


export const SharedTokenCacheCredential: {
    new(): SharedTokenCacheCredential;
    new(options: SharedTokenCacheCredentialOptions): SharedTokenCacheCredential;
    new(username: string, options: TokenCredentialOptions): SharedTokenCacheCredential;
};


export type SharedTokenCacheCredential = SharedTokenCacheCredential$instance;

export interface SharedTokenCacheCredentialOptions$instance extends TokenCredentialOptions {
    authenticationRecord: AuthenticationRecord;
    clientId: string;
    disableInstanceDiscovery: boolean;
    enableGuestTenantAuthentication: boolean;
    tenantId: string;
    tokenCachePersistenceOptions: TokenCachePersistenceOptions;
    username: string;
}


export const SharedTokenCacheCredentialOptions: {
    new(): SharedTokenCacheCredentialOptions;
    new(tokenCacheOptions: TokenCachePersistenceOptions): SharedTokenCacheCredentialOptions;
};


export type SharedTokenCacheCredentialOptions = SharedTokenCacheCredentialOptions$instance;

export interface TokenCachePersistenceOptions$instance {
    name: string;
    unsafeAllowUnencryptedStorage: boolean;
}


export const TokenCachePersistenceOptions: {
    new(): TokenCachePersistenceOptions;
};


export type TokenCachePersistenceOptions = TokenCachePersistenceOptions$instance;

export interface TokenCacheRefreshArgs$instance {
    readonly isCaeEnabled: boolean;
    readonly suggestedCacheKey: string;
}


export const TokenCacheRefreshArgs: {
    new(): TokenCacheRefreshArgs;
};


export type TokenCacheRefreshArgs = TokenCacheRefreshArgs$instance;

export interface TokenCacheUpdatedArgs$instance {
    readonly isCaeEnabled: boolean;
    readonly unsafeCacheData: ReadOnlyMemory<System_Internal.Byte>;
}


export const TokenCacheUpdatedArgs: {
    new(): TokenCacheUpdatedArgs;
};


export type TokenCacheUpdatedArgs = TokenCacheUpdatedArgs$instance;

export interface TokenCredentialDiagnosticsOptions$instance extends DiagnosticsOptions {
    isAccountIdentifierLoggingEnabled: boolean;
}


export const TokenCredentialDiagnosticsOptions: {
    new(): TokenCredentialDiagnosticsOptions;
};


export type TokenCredentialDiagnosticsOptions = TokenCredentialDiagnosticsOptions$instance;

export interface TokenCredentialOptions$instance extends ClientOptions {
    authorityHost: Uri;
    readonly diagnostics: DiagnosticsOptions | TokenCredentialDiagnosticsOptions;
    isUnsafeSupportLoggingEnabled: boolean;
}


export const TokenCredentialOptions: {
    new(): TokenCredentialOptions;
};


export type TokenCredentialOptions = TokenCredentialOptions$instance;

export interface UnsafeTokenCacheOptions$instance extends TokenCachePersistenceOptions {
}


export const UnsafeTokenCacheOptions: {
};


export type UnsafeTokenCacheOptions = UnsafeTokenCacheOptions$instance;

export interface UsernamePasswordCredential$instance extends TokenCredential {
    authenticate(cancellationToken?: CancellationToken): AuthenticationRecord;
    authenticate(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): AuthenticationRecord;
    authenticateAsync(cancellationToken?: CancellationToken): Task<AuthenticationRecord>;
    authenticateAsync(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): Task<AuthenticationRecord>;
    getToken(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): AccessToken;
    getToken(properties: GetTokenOptions, cancellationToken: CancellationToken): AuthenticationToken;
    getTokenAsync(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): ValueTask<AccessToken>;
    getTokenAsync(properties: GetTokenOptions, cancellationToken: CancellationToken): ValueTask<AuthenticationToken>;
}


export const UsernamePasswordCredential: {
    new(username: string, password: string, tenantId: string, clientId: string): UsernamePasswordCredential;
    new(username: string, password: string, tenantId: string, clientId: string, options: TokenCredentialOptions): UsernamePasswordCredential;
    new(username: string, password: string, tenantId: string, clientId: string, options: UsernamePasswordCredentialOptions): UsernamePasswordCredential;
};


export type UsernamePasswordCredential = UsernamePasswordCredential$instance;

export interface UsernamePasswordCredentialOptions$instance extends TokenCredentialOptions {
    readonly additionallyAllowedTenants: IList<System_Internal.String>;
    disableInstanceDiscovery: boolean;
    tokenCachePersistenceOptions: TokenCachePersistenceOptions;
}


export const UsernamePasswordCredentialOptions: {
    new(): UsernamePasswordCredentialOptions;
};


export type UsernamePasswordCredentialOptions = UsernamePasswordCredentialOptions$instance;

export interface VisualStudioCodeCredential$instance extends TokenCredential {
    getToken(requestContext: TokenRequestContext, cancellationToken: CancellationToken): AccessToken;
    getToken(properties: GetTokenOptions, cancellationToken: CancellationToken): AuthenticationToken;
    getTokenAsync(requestContext: TokenRequestContext, cancellationToken: CancellationToken): ValueTask<AccessToken>;
    getTokenAsync(properties: GetTokenOptions, cancellationToken: CancellationToken): ValueTask<AuthenticationToken>;
}


export const VisualStudioCodeCredential: {
    new(): VisualStudioCodeCredential;
    new(options: VisualStudioCodeCredentialOptions): VisualStudioCodeCredential;
};


export type VisualStudioCodeCredential = VisualStudioCodeCredential$instance;

export interface VisualStudioCodeCredentialOptions$instance extends TokenCredentialOptions {
    readonly additionallyAllowedTenants: IList<System_Internal.String>;
    tenantId: string;
}


export const VisualStudioCodeCredentialOptions: {
    new(): VisualStudioCodeCredentialOptions;
};


export type VisualStudioCodeCredentialOptions = VisualStudioCodeCredentialOptions$instance;

export interface VisualStudioCredential$instance extends TokenCredential {
    getToken(requestContext: TokenRequestContext, cancellationToken: CancellationToken): AccessToken;
    getToken(properties: GetTokenOptions, cancellationToken: CancellationToken): AuthenticationToken;
    getTokenAsync(requestContext: TokenRequestContext, cancellationToken: CancellationToken): ValueTask<AccessToken>;
    getTokenAsync(properties: GetTokenOptions, cancellationToken: CancellationToken): ValueTask<AuthenticationToken>;
}


export const VisualStudioCredential: {
    new(): VisualStudioCredential;
    new(options: VisualStudioCredentialOptions): VisualStudioCredential;
};


export type VisualStudioCredential = VisualStudioCredential$instance;

export interface VisualStudioCredentialOptions$instance extends TokenCredentialOptions {
    readonly additionallyAllowedTenants: IList<System_Internal.String>;
    processTimeout: Nullable<TimeSpan>;
    tenantId: string;
}


export const VisualStudioCredentialOptions: {
    new(): VisualStudioCredentialOptions;
};


export type VisualStudioCredentialOptions = VisualStudioCredentialOptions$instance;

export interface WorkloadIdentityCredential$instance extends TokenCredential {
    getToken(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): AccessToken;
    getToken(properties: GetTokenOptions, cancellationToken: CancellationToken): AuthenticationToken;
    getTokenAsync(requestContext: TokenRequestContext, cancellationToken?: CancellationToken): ValueTask<AccessToken>;
    getTokenAsync(properties: GetTokenOptions, cancellationToken: CancellationToken): ValueTask<AuthenticationToken>;
}


export const WorkloadIdentityCredential: {
    new(): WorkloadIdentityCredential;
    new(options: WorkloadIdentityCredentialOptions): WorkloadIdentityCredential;
};


export type WorkloadIdentityCredential = WorkloadIdentityCredential$instance;

export interface WorkloadIdentityCredentialOptions$instance extends TokenCredentialOptions {
    readonly additionallyAllowedTenants: IList<System_Internal.String>;
    clientId: string;
    disableInstanceDiscovery: boolean;
    tenantId: string;
    tokenFilePath: string;
}


export const WorkloadIdentityCredentialOptions: {
    new(): WorkloadIdentityCredentialOptions;
};


export type WorkloadIdentityCredentialOptions = WorkloadIdentityCredentialOptions$instance;

export abstract class AzureAuthorityHosts$instance {
    static readonly azurePublicCloud: Uri;
    static readonly azureChina: Uri;
    static readonly azureGermany: Uri;
    static readonly azureGovernment: Uri;
}


export type AzureAuthorityHosts = AzureAuthorityHosts$instance;

export abstract class IdentityModelFactory$instance {
    static authenticationRecord(username: string, authority: string, homeAccountId: string, tenantId: string, clientId: string): AuthenticationRecord;
    static deviceCodeInfo(userCode: string, deviceCode: string, verificationUri: Uri, expiresOn: DateTimeOffset, message: string, clientId: string, scopes: IReadOnlyCollection<System_Internal.String>): DeviceCodeInfo;
}


export type IdentityModelFactory = IdentityModelFactory$instance;


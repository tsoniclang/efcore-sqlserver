// Generated by tsbindgen - Architecture
// Namespace: Azure
// Assembly: Azure.Core

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { HttpPipeline, HttpPipelinePolicy } from "../../Azure.Core.Pipeline/internal/index.js";
import type { JsonPropertyNames, ObjectSerializer } from "../../Azure.Core.Serialization/internal/index.js";
import type { ClientOptions, DelayStrategy, HttpPipelinePosition, RehydrationToken, RequestFailedDetailsParser, ResponseClassificationHandler, ResponseHeaders } from "../../Azure.Core/internal/index.js";
import * as System_ClientModel_Primitives_Internal from "../../System.ClientModel.Primitives/internal/index.js";
import type { IJsonModel_1, IPersistableModel_1, ModelReaderWriterOptions } from "../../System.ClientModel.Primitives/internal/index.js";
import * as System_ClientModel_Internal from "../../System.ClientModel/internal/index.js";
import type { ApiKeyCredential } from "../../System.ClientModel/internal/index.js";
import type { BinaryData } from "../../System/internal/index.js";
import * as System_Collections_Generic_Internal from "@tsonic/dotnet/System.Collections.Generic.js";
import type { IAsyncEnumerable, IAsyncEnumerator, IEnumerable as IEnumerable__System_Collections_Generic, IEnumerator, IReadOnlyList } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Collections_Internal from "@tsonic/dotnet/System.Collections.js";
import type { IEnumerable } from "@tsonic/dotnet/System.Collections.js";
import type { Stream } from "@tsonic/dotnet/System.IO.js";
import * as System_Lib from "@tsonic/dotnet/System.js";
import type { Boolean as ClrBoolean, Byte, DateTimeOffset, Enum, EventArgs, Exception, IComparable, IConvertible, IDisposable, IEquatable, IFormattable, Int32, Int64, ISpanFormattable, Nullable, Object as ClrObject, ReadOnlyMemory, String as ClrString, TimeSpan, ValueType, Void } from "@tsonic/dotnet/System.js";
import * as System_Runtime_Serialization_Internal from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { Utf8JsonReader, Utf8JsonWriter } from "@tsonic/dotnet/System.Text.Json.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading.js";
import type { Task, ValueTask } from "@tsonic/dotnet/System.Threading.Tasks.js";

export enum ErrorOptions {
    default_ = 0,
    noThrow = 1
}


export enum WaitUntil {
    completed = 0,
    started = 1
}


export interface ETag$instance {
    equals(other: ETag): boolean;
    equals(other: string): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
    toString(format: string): string;
}


export const ETag: {
    new(etag: string): ETag;
    readonly all: ETag;
};


export type ETag = ETag$instance;

export interface HttpRange$instance {
    readonly length: Nullable<System_Internal.Int64>;
    readonly offset: long;
    equals(other: HttpRange): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string;
}


export const HttpRange: {
    new(offset: long, length: Nullable<System_Internal.Int64>): HttpRange;
};


export type HttpRange = HttpRange$instance;

export interface AsyncPageable_1$instance<T> {
    asPages(continuationToken?: string, pageSizeHint?: Nullable<System_Internal.Int32>): IAsyncEnumerable<Page_1<T>>;
    equals(obj: unknown): boolean;
    getAsyncEnumerator(cancellationToken?: CancellationToken): IAsyncEnumerator<T>;
    getHashCode(): int;
    toString(): string | undefined;
}


export const AsyncPageable_1: {
    fromPages<T>(pages: IEnumerable__System_Collections_Generic<Page_1<T>>): AsyncPageable_1<T>;
};


export type AsyncPageable_1<T> = AsyncPageable_1$instance<T>;

export interface AzureKeyCredential$instance extends ApiKeyCredential {
    readonly key: string;
}


export const AzureKeyCredential: {
    new(key: string): AzureKeyCredential;
};


export type AzureKeyCredential = AzureKeyCredential$instance;

export interface AzureNamedKeyCredential$instance {
    readonly name: string;
    deconstruct(name: string, key: string): void;
    update(name: string, key: string): void;
}


export const AzureNamedKeyCredential: {
    new(name: string, key: string): AzureNamedKeyCredential;
};


export type AzureNamedKeyCredential = AzureNamedKeyCredential$instance;

export interface AzureSasCredential$instance {
    readonly signature: string;
    update(signature: string): void;
}


export const AzureSasCredential: {
    new(signature: string): AzureSasCredential;
};


export type AzureSasCredential = AzureSasCredential$instance;

export interface HttpAuthorization$instance {
    readonly parameter: string;
    readonly scheme: string;
    toString(): string;
}


export const HttpAuthorization: {
    new(scheme: string, parameter: string): HttpAuthorization;
};


export type HttpAuthorization = HttpAuthorization$instance;

export interface JsonPatchDocument$instance {
    appendAdd<T>(path: string, value: T): void;
    appendAddRaw(path: string, rawJsonValue: string): void;
    appendCopy(from_: string, path: string): void;
    appendMove(from_: string, path: string): void;
    appendRemove(path: string): void;
    appendReplace<T>(path: string, value: T): void;
    appendReplaceRaw(path: string, rawJsonValue: string): void;
    appendTest<T>(path: string, value: T): void;
    appendTestRaw(path: string, rawJsonValue: string): void;
    toBytes(): ReadOnlyMemory<System_Internal.Byte>;
    toString(): string;
}


export const JsonPatchDocument: {
    new(): JsonPatchDocument;
    new(serializer: ObjectSerializer): JsonPatchDocument;
    new(rawDocument: ReadOnlyMemory<System_Internal.Byte>): JsonPatchDocument;
    new(rawDocument: ReadOnlyMemory<System_Internal.Byte>, serializer: ObjectSerializer): JsonPatchDocument;
};


export type JsonPatchDocument = JsonPatchDocument$instance;

export interface MatchConditions$instance {
    ifMatch: Nullable<ETag>;
    ifNoneMatch: Nullable<ETag>;
}


export const MatchConditions: {
    new(): MatchConditions;
};


export type MatchConditions = MatchConditions$instance;

export interface NullableResponse_1$instance<T> {
    readonly hasValue: boolean;
    readonly value: T;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    getRawResponse(): Response;
    toString(): string;
}


export const NullableResponse_1: {
};


export type NullableResponse_1<T> = NullableResponse_1$instance<T>;

export interface Operation$instance {
    readonly hasCompleted: boolean;
    readonly id: string;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    getRawResponse(): Response;
    getRehydrationToken(): Nullable<RehydrationToken>;
    toString(): string | undefined;
    updateStatus(cancellationToken?: CancellationToken): Response;
    updateStatusAsync(cancellationToken?: CancellationToken): ValueTask<Response>;
    waitForCompletionResponse(cancellationToken?: CancellationToken): Response;
    waitForCompletionResponse(pollingInterval: TimeSpan, cancellationToken?: CancellationToken): Response;
    waitForCompletionResponse(delayStrategy: DelayStrategy, cancellationToken?: CancellationToken): Response;
    waitForCompletionResponseAsync(cancellationToken?: CancellationToken): ValueTask<Response>;
    waitForCompletionResponseAsync(pollingInterval: TimeSpan, cancellationToken?: CancellationToken): ValueTask<Response>;
    waitForCompletionResponseAsync(delayStrategy: DelayStrategy, cancellationToken?: CancellationToken): ValueTask<Response>;
}


export const Operation: {
    rehydrate(pipeline: HttpPipeline, rehydrationToken: RehydrationToken, options?: ClientOptions): Operation;
    rehydrate<T extends IPersistableModel_1<T>>(pipeline: HttpPipeline, rehydrationToken: RehydrationToken, options?: ClientOptions): Operation_1<T>;
    rehydrateAsync(pipeline: HttpPipeline, rehydrationToken: RehydrationToken, options?: ClientOptions): Task<Operation>;
    rehydrateAsync<T extends IPersistableModel_1<T>>(pipeline: HttpPipeline, rehydrationToken: RehydrationToken, options?: ClientOptions): Task<Operation_1<T>>;
};


export type Operation = Operation$instance;

export interface Operation_1$instance<T> extends Operation {
    readonly hasValue: boolean;
    readonly value: T;
    waitForCompletion(cancellationToken?: CancellationToken): Response_1<T>;
    waitForCompletion(pollingInterval: TimeSpan, cancellationToken: CancellationToken): Response_1<T>;
    waitForCompletion(delayStrategy: DelayStrategy, cancellationToken: CancellationToken): Response_1<T>;
    waitForCompletionAsync(cancellationToken?: CancellationToken): ValueTask<Response_1<T>>;
    waitForCompletionAsync(pollingInterval: TimeSpan, cancellationToken: CancellationToken): ValueTask<Response_1<T>>;
    waitForCompletionAsync(delayStrategy: DelayStrategy, cancellationToken: CancellationToken): ValueTask<Response_1<T>>;
    waitForCompletionResponseAsync(cancellationToken?: CancellationToken): ValueTask<Response>;
    waitForCompletionResponseAsync(pollingInterval: TimeSpan, cancellationToken?: CancellationToken): ValueTask<Response>;
    waitForCompletionResponseAsync(cancellationToken?: CancellationToken): ValueTask<Response>;
    waitForCompletionResponseAsync(pollingInterval: TimeSpan, cancellationToken?: CancellationToken): ValueTask<Response>;
    waitForCompletionResponseAsync(delayStrategy: DelayStrategy, cancellationToken?: CancellationToken): ValueTask<Response>;
}


export const Operation_1: {
};


export type Operation_1<T> = Operation_1$instance<T>;

export interface Page_1$instance<T> {
    readonly continuationToken: string | undefined;
    readonly values: IReadOnlyList<T>;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    getRawResponse(): Response;
    toString(): string | undefined;
}


export const Page_1: {
    fromValues<T>(values: IReadOnlyList<T>, continuationToken: string, response: Response): Page_1<T>;
};


export type Page_1<T> = Page_1$instance<T>;

export interface Pageable_1$instance<T> {
    asPages(continuationToken?: string, pageSizeHint?: Nullable<System_Internal.Int32>): IEnumerable__System_Collections_Generic<Page_1<T>>;
    equals(obj: unknown): boolean;
    getEnumerator(): IEnumerator<T>;
    getHashCode(): int;
    toString(): string | undefined;
}


export const Pageable_1: {
    fromPages<T>(pages: IEnumerable__System_Collections_Generic<Page_1<T>>): Pageable_1<T>;
};


export type Pageable_1<T> = Pageable_1$instance<T>;

export interface PageableOperation_1$instance<T> extends Operation_1<AsyncPageable_1<T>> {
    readonly value: AsyncPageable_1<T>;
    getValues(cancellationToken?: CancellationToken): Pageable_1<T>;
    getValuesAsync(cancellationToken?: CancellationToken): AsyncPageable_1<T>;
}


export const PageableOperation_1: {
};


export type PageableOperation_1<T> = PageableOperation_1$instance<T>;

export interface RequestConditions$instance extends MatchConditions {
    ifModifiedSince: Nullable<DateTimeOffset>;
    ifUnmodifiedSince: Nullable<DateTimeOffset>;
}


export const RequestConditions: {
    new(): RequestConditions;
};


export type RequestConditions = RequestConditions$instance;

export interface RequestContext$instance {
    cancellationToken: CancellationToken;
    errorOptions: ErrorOptions;
    addClassifier(statusCode: int, isError: boolean): void;
    addClassifier(classifier: ResponseClassificationHandler): void;
    addPolicy(policy: HttpPipelinePolicy, position: HttpPipelinePosition): void;
}


export const RequestContext: {
    new(): RequestContext;
};


export type RequestContext = RequestContext$instance;

export interface RequestFailedException$instance extends Exception {
    readonly errorCode: string | undefined;
    readonly status: int;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
    getRawResponse(): Response | undefined;
}


export const RequestFailedException: {
    new(message: string): RequestFailedException;
    new(message: string, innerException: Exception): RequestFailedException;
    new(status: int, message: string): RequestFailedException;
    new(status: int, message: string, innerException: Exception): RequestFailedException;
    new(status: int, message: string, errorCode: string, innerException: Exception): RequestFailedException;
    new(response: Response): RequestFailedException;
    new(response: Response, innerException: Exception): RequestFailedException;
    new(response: Response, innerException: Exception, detailsParser: RequestFailedDetailsParser): RequestFailedException;
};


export type RequestFailedException = RequestFailedException$instance;

export interface Response$instance {
    clientRequestId: string;
    readonly content: BinaryData;
    get contentStream(): Stream | undefined;
    set contentStream(value: Stream);
    readonly headers: ResponseHeaders;
    readonly isError: boolean;
    readonly reasonPhrase: string;
    readonly status: int;
    dispose(): void;
    toString(): string;
}


export const Response: {
    fromValue<T>(value: T, response: Response): Response_1<T>;
};


export type Response = Response$instance;

export interface Response_1$instance<T> extends NullableResponse_1<T> {
    readonly hasValue: boolean;
    readonly value: T;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const Response_1: {
};


export type Response_1<T> = Response_1$instance<T>;

export interface ResponseError$instance {
    readonly code: string | undefined;
    readonly message: string | undefined;
    toString(): string;
}


export const ResponseError: {
    new(): ResponseError;
    new(code: string, message: string): ResponseError;
};


export interface __ResponseError$views {
    As_IJsonModel_1(): System_ClientModel_Primitives_Internal.IJsonModel_1$instance<ResponseError>;
    As_IPersistableModel_1(): System_ClientModel_Primitives_Internal.IPersistableModel_1$instance<ResponseError>;
}

export interface ResponseError$instance extends System_ClientModel_Primitives_Internal.IJsonModel_1$instance<ResponseError> {}

export type ResponseError = ResponseError$instance & __ResponseError$views;


export interface SyncAsyncEventArgs$instance extends EventArgs {
    readonly cancellationToken: CancellationToken;
    readonly isRunningSynchronously: boolean;
}


export const SyncAsyncEventArgs: {
    new(isRunningSynchronously: boolean, cancellationToken: CancellationToken): SyncAsyncEventArgs;
};


export type SyncAsyncEventArgs = SyncAsyncEventArgs$instance;

export abstract class AzureCoreExtensions$instance {
    static toDynamicFromJson(utf8Json: BinaryData, propertyNameFormat: JsonPropertyNames, dateTimeFormat?: string): unknown;
    static toDynamicFromJson(utf8Json: BinaryData): unknown;
    static toObject<T>(data: BinaryData, serializer: ObjectSerializer, cancellationToken?: CancellationToken): T | undefined;
    static toObjectAsync<T>(data: BinaryData, serializer: ObjectSerializer, cancellationToken?: CancellationToken): ValueTask<T>;
    static toObjectFromJson(data: BinaryData): unknown | undefined;
}


export type AzureCoreExtensions = AzureCoreExtensions$instance;


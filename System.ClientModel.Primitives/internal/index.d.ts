// Generated by tsbindgen - Architecture
// Namespace: System.ClientModel.Primitives
// Assembly: System.ClientModel

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { ApiKeyCredential, AuthenticationTokenProvider, BinaryContent, ClientResult, ContinuationToken } from "../../System.ClientModel/internal/index.js";
import type { BinaryData } from "../../System/internal/index.js";
import * as System_Collections_Generic_Internal from "@tsonic/dotnet/System.Collections.Generic.js";
import type { IAsyncEnumerable, ICollection as ICollection__System_Collections_Generic, IEnumerable as IEnumerable__System_Collections_Generic, IEnumerator, IList as IList__System_Collections_Generic, IReadOnlyCollection, IReadOnlyDictionary, IReadOnlyList, KeyValuePair } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Collections_Internal from "@tsonic/dotnet/System.Collections.js";
import type { ICollection, IEnumerable, IList } from "@tsonic/dotnet/System.Collections.js";
import * as System_Collections_ObjectModel_Internal from "@tsonic/dotnet/System.Collections.ObjectModel.js";
import type { KeyedCollection } from "@tsonic/dotnet/System.Collections.ObjectModel.js";
import type { Activity, ActivityContext, ActivityKind, ActivitySource } from "@tsonic/dotnet/System.Diagnostics.js";
import type { Stream } from "@tsonic/dotnet/System.IO.js";
import * as System_Lib from "@tsonic/dotnet/System.js";
import type { Attribute, Boolean as ClrBoolean, DateTimeOffset, Enum, Exception, Func, IComparable, IConvertible, IDisposable, IFormattable, Int32, ISpanFormattable, Nullable, Object as ClrObject, ReadOnlySpan, String as ClrString, TimeSpan, Type, UInt16, Uri, ValueType, Void } from "@tsonic/dotnet/System.js";
import type { HttpClient } from "@tsonic/dotnet/System.Net.Http.js";
import type { JsonSerializerOptions, Utf8JsonReader, Utf8JsonWriter } from "@tsonic/dotnet/System.Text.Json.js";
import * as System_Text_Json_Serialization_Internal from "@tsonic/dotnet/System.Text.Json.Serialization.js";
import type { JsonConverter } from "@tsonic/dotnet/System.Text.Json.Serialization.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading.js";
import type { ValueTask } from "@tsonic/dotnet/System.Threading.Tasks.js";
import type { ILoggerFactory } from "@tsonic/microsoft-extensions/Microsoft.Extensions.Logging.js";

export enum ClientErrorBehaviors {
    default_ = 0,
    noThrow = 1
}


export enum CredentialKind {
    none = 0,
    apiKeyString = 1,
    tokenCredential = 2
}


export enum PipelinePosition {
    perCall = 0,
    perTry = 1,
    beforeTransport = 2
}


export interface IJsonModel_1$instance<T> extends IPersistableModel_1<T> {
    create(reader: Utf8JsonReader, options: ModelReaderWriterOptions): T | undefined;
    create(data: BinaryData, options: ModelReaderWriterOptions): T | undefined;
    create(data: BinaryData, options: ModelReaderWriterOptions): T;
    getFormatFromOptions(options: ModelReaderWriterOptions): string;
    write(writer: Utf8JsonWriter, options: ModelReaderWriterOptions): void;
    write(options: ModelReaderWriterOptions): BinaryData;
}


export type IJsonModel_1<T> = IJsonModel_1$instance<T>;

export interface IPersistableModel_1$instance<T> {
    create(data: BinaryData, options: ModelReaderWriterOptions): T | undefined;
    getFormatFromOptions(options: ModelReaderWriterOptions): string;
    write(options: ModelReaderWriterOptions): BinaryData;
}


export type IPersistableModel_1<T> = IPersistableModel_1$instance<T>;

export interface ClientConnection$instance {
    readonly credential: unknown | undefined;
    readonly credentialKind: CredentialKind;
    readonly id: string;
    readonly locator: string;
    toString(): string;
    tryGetLocatorAsUri(uri: Uri): boolean;
}


export const ClientConnection: {
    new(id: string, locator: string, credential: unknown, credentialKind: CredentialKind): ClientConnection;
    new(id: string, locator: string): ClientConnection;
};


export type ClientConnection = ClientConnection$instance;

export interface ApiKeyAuthenticationPolicy$instance extends AuthenticationPolicy {
    process(message: PipelineMessage, pipeline: IReadOnlyList<PipelinePolicy>, currentIndex: int): void;
    processAsync(message: PipelineMessage, pipeline: IReadOnlyList<PipelinePolicy>, currentIndex: int): ValueTask;
}


export const ApiKeyAuthenticationPolicy: {
    new(): ApiKeyAuthenticationPolicy;
    createBasicAuthorizationPolicy(credential: ApiKeyCredential): ApiKeyAuthenticationPolicy;
    createBearerAuthorizationPolicy(credential: ApiKeyCredential): ApiKeyAuthenticationPolicy;
    createHeaderApiKeyPolicy(credential: ApiKeyCredential, headerName: string, keyPrefix?: string): ApiKeyAuthenticationPolicy;
};


export type ApiKeyAuthenticationPolicy = ApiKeyAuthenticationPolicy$instance;

export interface AsyncCollectionResult$instance {
    getContinuationToken(page: ClientResult): ContinuationToken | undefined;
    getRawPagesAsync(): IAsyncEnumerable<ClientResult>;
}


export const AsyncCollectionResult: {
};


export type AsyncCollectionResult = AsyncCollectionResult$instance;

export interface AuthenticationPolicy$instance extends PipelinePolicy {
}


export const AuthenticationPolicy: {
};


export type AuthenticationPolicy = AuthenticationPolicy$instance;

export interface AuthenticationToken$instance {
    readonly expiresOn: Nullable<DateTimeOffset>;
    readonly refreshOn: Nullable<DateTimeOffset>;
    readonly tokenType: string;
    readonly tokenValue: string;
}


export const AuthenticationToken: {
    new(tokenValue: string, tokenType: string, expiresOn: DateTimeOffset, refreshOn: Nullable<DateTimeOffset>): AuthenticationToken;
};


export type AuthenticationToken = AuthenticationToken$instance;

export interface BearerTokenPolicy$instance extends AuthenticationPolicy {
    process(message: PipelineMessage, pipeline: IReadOnlyList<PipelinePolicy>, currentIndex: int): void;
    processAsync(message: PipelineMessage, pipeline: IReadOnlyList<PipelinePolicy>, currentIndex: int): ValueTask;
}


export const BearerTokenPolicy: {
    new(tokenProvider: AuthenticationTokenProvider, contexts: IEnumerable__System_Collections_Generic<IReadOnlyDictionary<System_Internal.String, unknown>>): BearerTokenPolicy;
    new(tokenProvider: AuthenticationTokenProvider, scope: string): BearerTokenPolicy;
};


export type BearerTokenPolicy = BearerTokenPolicy$instance;

export interface ClientCache$instance {
    getClient<T>(clientId: unknown, createClient: Func<T>): T;
}


export const ClientCache: {
    new(maxSize: int): ClientCache;
};


export type ClientCache = ClientCache$instance;

export interface ClientConnectionCollection$instance extends KeyedCollection<System_Internal.String, ClientConnection> {
    addRange(connections: IEnumerable__System_Collections_Generic<ClientConnection>): void;
}


export const ClientConnectionCollection: {
    new(): ClientConnectionCollection;
};


export type ClientConnectionCollection = ClientConnectionCollection$instance;

export interface ClientConnectionProvider$instance {
    readonly subclients: ClientCache;
    getAllConnections(): IEnumerable__System_Collections_Generic<ClientConnection>;
    getConnection(connectionId: string): ClientConnection;
}


export const ClientConnectionProvider: {
};


export type ClientConnectionProvider = ClientConnectionProvider$instance;

export interface ClientLoggingOptions$instance {
    readonly allowedHeaderNames: IList__System_Collections_Generic<System_Internal.String>;
    readonly allowedQueryParameters: IList__System_Collections_Generic<System_Internal.String>;
    enableLogging: Nullable<System_Internal.Boolean>;
    enableMessageContentLogging: Nullable<System_Internal.Boolean>;
    enableMessageLogging: Nullable<System_Internal.Boolean>;
    get loggerFactory(): ILoggerFactory | undefined;
    set loggerFactory(value: ILoggerFactory);
    messageContentSizeLimit: Nullable<System_Internal.Int32>;
    freeze(): void;
}


export const ClientLoggingOptions: {
    new(): ClientLoggingOptions;
};


export type ClientLoggingOptions = ClientLoggingOptions$instance;

export interface ClientPipeline$instance {
    createMessage(): PipelineMessage;
    send(message: PipelineMessage): void;
    sendAsync(message: PipelineMessage): ValueTask;
}


export const ClientPipeline: {
    new(): ClientPipeline;
    create(options: ClientPipelineOptions, perCallPolicies: ReadOnlySpan<PipelinePolicy>, perTryPolicies: ReadOnlySpan<PipelinePolicy>, beforeTransportPolicies: ReadOnlySpan<PipelinePolicy>): ClientPipeline;
    create(options?: ClientPipelineOptions): ClientPipeline;
};


export type ClientPipeline = ClientPipeline$instance;

export interface ClientPipelineOptions$instance {
    get clientLoggingOptions(): ClientLoggingOptions | undefined;
    set clientLoggingOptions(value: ClientLoggingOptions);
    enableDistributedTracing: Nullable<System_Internal.Boolean>;
    get messageLoggingPolicy(): PipelinePolicy | undefined;
    set messageLoggingPolicy(value: PipelinePolicy);
    networkTimeout: Nullable<TimeSpan>;
    get retryPolicy(): PipelinePolicy | undefined;
    set retryPolicy(value: PipelinePolicy);
    transport: PipelineTransport;
    addPolicy(policy: PipelinePolicy, position: PipelinePosition): void;
    freeze(): void;
}


export const ClientPipelineOptions: {
    new(): ClientPipelineOptions;
};


export type ClientPipelineOptions = ClientPipelineOptions$instance;

export interface ClientRetryPolicy$instance extends PipelinePolicy {
    process(message: PipelineMessage, pipeline: IReadOnlyList<PipelinePolicy>, currentIndex: int): void;
    processAsync(message: PipelineMessage, pipeline: IReadOnlyList<PipelinePolicy>, currentIndex: int): ValueTask;
}


export const ClientRetryPolicy: {
    new(maxRetries: int): ClientRetryPolicy;
    new(maxRetries: int, enableLogging: boolean, loggerFactory: ILoggerFactory): ClientRetryPolicy;
    readonly default_: ClientRetryPolicy;
};


export type ClientRetryPolicy = ClientRetryPolicy$instance;

export interface CollectionResult$instance {
    getContinuationToken(page: ClientResult): ContinuationToken | undefined;
    getRawPages(): IEnumerable__System_Collections_Generic<ClientResult>;
}


export const CollectionResult: {
};


export type CollectionResult = CollectionResult$instance;

export interface GetTokenOptions$instance {
    readonly properties: IReadOnlyDictionary<System_Internal.String, unknown>;
}


export const GetTokenOptions: {
    new(properties: IReadOnlyDictionary<System_Internal.String, unknown>): GetTokenOptions;
    readonly scopesPropertyName: string;
    readonly tokenUrlPropertyName: string;
    readonly authorizationUrlPropertyName: string;
    readonly refreshUrlPropertyName: string;
};


export type GetTokenOptions = GetTokenOptions$instance;

export interface HttpClientPipelineTransport$instance extends PipelineTransport {
    dispose(): void;
}


export const HttpClientPipelineTransport: {
    new(): HttpClientPipelineTransport;
    new(client: HttpClient): HttpClientPipelineTransport;
    new(client: HttpClient, enableLogging: boolean, loggerFactory: ILoggerFactory): HttpClientPipelineTransport;
    readonly shared: HttpClientPipelineTransport;
};


export type HttpClientPipelineTransport = HttpClientPipelineTransport$instance;

export interface JsonModelConverter$instance extends JsonConverter<IJsonModel_1<unknown>> {
    canConvert(typeToConvert: Type): boolean;
    read(reader: Utf8JsonReader, typeToConvert: Type, options: JsonSerializerOptions): IJsonModel_1<unknown> | undefined;
    write(writer: Utf8JsonWriter, value: IJsonModel_1<unknown>, options: JsonSerializerOptions): void;
}


export const JsonModelConverter: {
    new(): JsonModelConverter;
    new(options: ModelReaderWriterOptions): JsonModelConverter;
    new(options: ModelReaderWriterOptions, context: ModelReaderWriterContext): JsonModelConverter;
};


export type JsonModelConverter = JsonModelConverter$instance;

export interface MessageLoggingPolicy$instance extends PipelinePolicy {
    process(message: PipelineMessage, pipeline: IReadOnlyList<PipelinePolicy>, currentIndex: int): void;
    processAsync(message: PipelineMessage, pipeline: IReadOnlyList<PipelinePolicy>, currentIndex: int): ValueTask;
}


export const MessageLoggingPolicy: {
    new(options: ClientLoggingOptions): MessageLoggingPolicy;
    readonly default_: MessageLoggingPolicy;
};


export type MessageLoggingPolicy = MessageLoggingPolicy$instance;

export interface ModelReaderWriterBuildableAttribute$instance extends Attribute {
}


export const ModelReaderWriterBuildableAttribute: {
    new(type_: Type): ModelReaderWriterBuildableAttribute;
};


export type ModelReaderWriterBuildableAttribute = ModelReaderWriterBuildableAttribute$instance;

export interface ModelReaderWriterContext$instance {
    getTypeBuilder(type_: Type): ModelReaderWriterTypeBuilder;
    tryGetTypeBuilder(type_: Type, builder: ModelReaderWriterTypeBuilder): boolean;
}


export const ModelReaderWriterContext: {
};


export type ModelReaderWriterContext = ModelReaderWriterContext$instance;

export interface ModelReaderWriterContextTypeAttribute$instance extends Attribute {
}


export const ModelReaderWriterContextTypeAttribute: {
    new(contextType: Type): ModelReaderWriterContextTypeAttribute;
};


export type ModelReaderWriterContextTypeAttribute = ModelReaderWriterContextTypeAttribute$instance;

export interface ModelReaderWriterOptions$instance {
    readonly format: string;
}


export const ModelReaderWriterOptions: {
    new(format: string): ModelReaderWriterOptions;
    readonly json: ModelReaderWriterOptions;
    readonly xml: ModelReaderWriterOptions;
};


export type ModelReaderWriterOptions = ModelReaderWriterOptions$instance;

export interface ModelReaderWriterTypeBuilder$instance {
}


export const ModelReaderWriterTypeBuilder: {
};


export type ModelReaderWriterTypeBuilder = ModelReaderWriterTypeBuilder$instance;

export interface OperationResult$instance {
    readonly hasCompleted: boolean;
    readonly rehydrationToken: ContinuationToken | undefined;
    getRawResponse(): PipelineResponse;
    updateStatus(options?: RequestOptions): ClientResult;
    updateStatusAsync(options?: RequestOptions): ValueTask<ClientResult>;
    waitForCompletion(cancellationToken?: CancellationToken): void;
    waitForCompletionAsync(cancellationToken?: CancellationToken): ValueTask;
}


export const OperationResult: {
};


export type OperationResult = OperationResult$instance;

export interface PersistableModelProxyAttribute$instance extends Attribute {
    readonly proxyType: Type;
}


export const PersistableModelProxyAttribute: {
    new(proxyType: Type): PersistableModelProxyAttribute;
};


export type PersistableModelProxyAttribute = PersistableModelProxyAttribute$instance;

export interface PipelineMessage$instance {
    bufferResponse: boolean;
    readonly cancellationToken: CancellationToken;
    networkTimeout: Nullable<TimeSpan>;
    readonly request: PipelineRequest;
    readonly response: PipelineResponse;
    responseClassifier: PipelineMessageClassifier;
    apply(options: RequestOptions): void;
    dispose(): void;
    extractResponse(): PipelineResponse | undefined;
    setProperty(key: Type, value: unknown): void;
    tryGetProperty(key: Type, value: unknown): boolean;
}


export const PipelineMessage: {
    new(): PipelineMessage;
};


export type PipelineMessage = PipelineMessage$instance;

export interface PipelineMessageClassifier$instance {
    tryClassify(message: PipelineMessage, isError: boolean): boolean;
    tryClassify(message: PipelineMessage, exception: Exception, isRetriable: boolean): boolean;
}


export const PipelineMessageClassifier: {
    readonly default_: PipelineMessageClassifier;
    create(successStatusCodes: ReadOnlySpan<System_Internal.UInt16>): PipelineMessageClassifier;
};


export type PipelineMessageClassifier = PipelineMessageClassifier$instance;

export interface PipelinePolicy$instance {
    process(message: PipelineMessage, pipeline: IReadOnlyList<PipelinePolicy>, currentIndex: int): void;
    processAsync(message: PipelineMessage, pipeline: IReadOnlyList<PipelinePolicy>, currentIndex: int): ValueTask;
}


export const PipelinePolicy: {
};


export type PipelinePolicy = PipelinePolicy$instance;

export interface PipelineRequest$instance {
    content: BinaryContent;
    readonly headers: PipelineRequestHeaders;
    method: string;
    uri: Uri;
    dispose(): void;
}


export const PipelineRequest: {
};


export type PipelineRequest = PipelineRequest$instance;

export interface PipelineRequestHeaders$instance {
    add(name: string, value: string): void;
    getEnumerator(): IEnumerator<KeyValuePair<System_Internal.String, System_Internal.String>>;
    remove(name: string): boolean;
    set_(name: string, value: string): void;
    tryGetValue(name: string, value: string): boolean;
    tryGetValues(name: string, values: IEnumerable__System_Collections_Generic<System_Internal.String>): boolean;
}


export const PipelineRequestHeaders: {
};


export type PipelineRequestHeaders = PipelineRequestHeaders$instance;

export interface PipelineResponse$instance {
    readonly content: BinaryData;
    get contentStream(): Stream | undefined;
    set contentStream(value: Stream);
    readonly headers: PipelineResponseHeaders;
    readonly isError: boolean;
    readonly reasonPhrase: string;
    readonly status: int;
    bufferContent(cancellationToken?: CancellationToken): BinaryData;
    bufferContentAsync(cancellationToken?: CancellationToken): ValueTask<BinaryData>;
    dispose(): void;
}


export const PipelineResponse: {
};


export type PipelineResponse = PipelineResponse$instance;

export interface PipelineResponseHeaders$instance {
    getEnumerator(): IEnumerator<KeyValuePair<System_Internal.String, System_Internal.String>>;
    tryGetValue(name: string, value: string): boolean;
    tryGetValues(name: string, values: IEnumerable__System_Collections_Generic<System_Internal.String>): boolean;
}


export const PipelineResponseHeaders: {
};


export type PipelineResponseHeaders = PipelineResponseHeaders$instance;

export interface PipelineTransport$instance extends PipelinePolicy {
    createMessage(): PipelineMessage;
    process(message: PipelineMessage): void;
    process(message: PipelineMessage, pipeline: IReadOnlyList<PipelinePolicy>, currentIndex: int): void;
    process(message: PipelineMessage, pipeline: IReadOnlyList<PipelinePolicy>, currentIndex: int): void;
    processAsync(message: PipelineMessage): ValueTask;
    processAsync(message: PipelineMessage, pipeline: IReadOnlyList<PipelinePolicy>, currentIndex: int): ValueTask;
    processAsync(message: PipelineMessage, pipeline: IReadOnlyList<PipelinePolicy>, currentIndex: int): ValueTask;
}


export const PipelineTransport: {
};


export type PipelineTransport = PipelineTransport$instance;

export interface RequestOptions$instance {
    bufferResponse: boolean;
    cancellationToken: CancellationToken;
    errorOptions: ClientErrorBehaviors;
    addHeader(name: string, value: string): void;
    addPolicy(policy: PipelinePolicy, position: PipelinePosition): void;
    freeze(): void;
    setHeader(name: string, value: string): void;
}


export const RequestOptions: {
    new(): RequestOptions;
};


export type RequestOptions = RequestOptions$instance;

export abstract class ActivityExtensions$instance {
    static markClientActivityFailed(activity: Activity, exception: Exception): Activity;
    static startClientActivity(activitySource: ActivitySource, options: ClientPipelineOptions, name: string, kind?: ActivityKind, parentContext?: ActivityContext, tags?: IEnumerable__System_Collections_Generic<KeyValuePair<System_Internal.String, unknown>>): Activity | undefined;
}


export type ActivityExtensions = ActivityExtensions$instance;

export abstract class ModelReaderWriter$instance {
    static read<T>(data: BinaryData, options: ModelReaderWriterOptions, context: ModelReaderWriterContext): T | undefined;
    static read<T extends IPersistableModel_1<T>>(data: BinaryData, options?: ModelReaderWriterOptions): T | undefined;
    static read(data: BinaryData, returnType: Type, options: ModelReaderWriterOptions, context: ModelReaderWriterContext): unknown | undefined;
    static read(data: BinaryData, returnType: Type, options?: ModelReaderWriterOptions): unknown | undefined;
    static write(model: unknown, options: ModelReaderWriterOptions, context: ModelReaderWriterContext): BinaryData;
    static write(model: unknown, options?: ModelReaderWriterOptions): BinaryData;
    static write<T>(model: T, options: ModelReaderWriterOptions, context: ModelReaderWriterContext): BinaryData;
    static write<T extends IPersistableModel_1<T>>(model: T, options?: ModelReaderWriterOptions): BinaryData;
}


export type ModelReaderWriter = ModelReaderWriter$instance;


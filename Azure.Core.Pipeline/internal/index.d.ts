// Generated by tsbindgen - Architecture
// Namespace: Azure.Core.Pipeline
// Assembly: Azure.Core

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import type { ClientOptions, DelayStrategy, HttpMessage, Request, RequestFailedDetailsParser, ResponseClassifier, TokenCredential } from "../../Azure.Core/internal/index.js";
import type { RequestContext, Response } from "../../Azure/internal/index.js";
import type { IDictionary, IEnumerable, IList } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Boolean as ClrBoolean, Func, IDisposable, Int32, Object as ClrObject, ReadOnlyMemory, String as ClrString, Void } from "@tsonic/dotnet/System.js";
import type { HttpClient, HttpMessageHandler } from "@tsonic/dotnet/System.Net.Http.js";
import type { SslPolicyErrors } from "@tsonic/dotnet/System.Net.Security.js";
import type { X509Certificate2, X509Chain } from "@tsonic/dotnet/System.Security.Cryptography.X509Certificates.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading.js";
import type { ValueTask } from "@tsonic/dotnet/System.Threading.Tasks.js";

export interface BearerTokenAuthenticationPolicy$instance extends HttpPipelinePolicy {
    process(message: HttpMessage, pipeline: ReadOnlyMemory<HttpPipelinePolicy>): void;
    processAsync(message: HttpMessage, pipeline: ReadOnlyMemory<HttpPipelinePolicy>): ValueTask;
}


export const BearerTokenAuthenticationPolicy: {
    new(credential: TokenCredential, scope: string): BearerTokenAuthenticationPolicy;
    new(credential: TokenCredential, scopes: IEnumerable<System_Internal.String>): BearerTokenAuthenticationPolicy;
};


export type BearerTokenAuthenticationPolicy = BearerTokenAuthenticationPolicy$instance;

export interface DisposableHttpPipeline$instance extends HttpPipeline {
    dispose(): void;
}


export const DisposableHttpPipeline: {
    new(): DisposableHttpPipeline;
};


export type DisposableHttpPipeline = DisposableHttpPipeline$instance;

export interface HttpClientTransport$instance extends HttpPipelineTransport {
    createRequest(): Request;
    dispose(): void;
    process(message: HttpMessage): void;
    processAsync(message: HttpMessage): ValueTask;
}


export const HttpClientTransport: {
    new(): HttpClientTransport;
    new(messageHandler: HttpMessageHandler): HttpClientTransport;
    new(client: HttpClient): HttpClientTransport;
    readonly shared: HttpClientTransport;
};


export type HttpClientTransport = HttpClientTransport$instance;

export interface HttpPipeline$instance {
    readonly responseClassifier: ResponseClassifier;
    createMessage(): HttpMessage;
    createMessage(context: RequestContext): HttpMessage;
    createMessage(context: RequestContext, classifier?: ResponseClassifier): HttpMessage;
    createRequest(): Request;
    send(message: HttpMessage, cancellationToken: CancellationToken): void;
    sendAsync(message: HttpMessage, cancellationToken: CancellationToken): ValueTask;
    sendRequest(request: Request, cancellationToken: CancellationToken): Response;
    sendRequestAsync(request: Request, cancellationToken: CancellationToken): ValueTask<Response>;
}


export const HttpPipeline: {
    new(transport: HttpPipelineTransport, policies: HttpPipelinePolicy[], responseClassifier: ResponseClassifier): HttpPipeline;
    createClientRequestIdScope(clientRequestId: string): IDisposable;
    createHttpMessagePropertiesScope(messageProperties: IDictionary<System_Internal.String, unknown>): IDisposable;
};


export type HttpPipeline = HttpPipeline$instance;

export interface HttpPipelineOptions$instance {
    readonly clientOptions: ClientOptions;
    readonly perCallPolicies: IList<HttpPipelinePolicy>;
    readonly perRetryPolicies: IList<HttpPipelinePolicy>;
    requestFailedDetailsParser: RequestFailedDetailsParser;
    responseClassifier: ResponseClassifier;
}


export const HttpPipelineOptions: {
    new(options: ClientOptions): HttpPipelineOptions;
};


export type HttpPipelineOptions = HttpPipelineOptions$instance;

export interface HttpPipelinePolicy$instance {
    process(message: HttpMessage, pipeline: ReadOnlyMemory<HttpPipelinePolicy>): void;
    processAsync(message: HttpMessage, pipeline: ReadOnlyMemory<HttpPipelinePolicy>): ValueTask;
}


export const HttpPipelinePolicy: {
};


export type HttpPipelinePolicy = HttpPipelinePolicy$instance;

export interface HttpPipelineSynchronousPolicy$instance extends HttpPipelinePolicy {
    onReceivedResponse(message: HttpMessage): void;
    onSendingRequest(message: HttpMessage): void;
    process(message: HttpMessage, pipeline: ReadOnlyMemory<HttpPipelinePolicy>): void;
    process(message: HttpMessage, pipeline: ReadOnlyMemory<HttpPipelinePolicy>): void;
    processAsync(message: HttpMessage, pipeline: ReadOnlyMemory<HttpPipelinePolicy>): ValueTask;
    processAsync(message: HttpMessage, pipeline: ReadOnlyMemory<HttpPipelinePolicy>): ValueTask;
}


export const HttpPipelineSynchronousPolicy: {
};


export type HttpPipelineSynchronousPolicy = HttpPipelineSynchronousPolicy$instance;

export interface HttpPipelineTransport$instance {
    createRequest(): Request;
    process(message: HttpMessage): void;
    processAsync(message: HttpMessage): ValueTask;
}


export const HttpPipelineTransport: {
};


export type HttpPipelineTransport = HttpPipelineTransport$instance;

export interface HttpPipelineTransportOptions$instance {
    readonly clientCertificates: IList<X509Certificate2>;
    isClientRedirectEnabled: boolean;
    get serverCertificateCustomValidationCallback(): Func<ServerCertificateCustomValidationArgs, System_Internal.Boolean> | undefined;
    set serverCertificateCustomValidationCallback(value: Func<ServerCertificateCustomValidationArgs, System_Internal.Boolean>);
}


export const HttpPipelineTransportOptions: {
    new(): HttpPipelineTransportOptions;
};


export type HttpPipelineTransportOptions = HttpPipelineTransportOptions$instance;

export interface RedirectPolicy$instance extends HttpPipelinePolicy {
    process(message: HttpMessage, pipeline: ReadOnlyMemory<HttpPipelinePolicy>): void;
    processAsync(message: HttpMessage, pipeline: ReadOnlyMemory<HttpPipelinePolicy>): ValueTask;
}


export const RedirectPolicy: {
    new(): RedirectPolicy;
    setAllowAutoRedirect(message: HttpMessage, allowAutoRedirect: boolean): void;
};


export type RedirectPolicy = RedirectPolicy$instance;

export interface RetryPolicy$instance extends HttpPipelinePolicy {
    process(message: HttpMessage, pipeline: ReadOnlyMemory<HttpPipelinePolicy>): void;
    processAsync(message: HttpMessage, pipeline: ReadOnlyMemory<HttpPipelinePolicy>): ValueTask;
}


export const RetryPolicy: {
    new(maxRetries: int, delayStrategy: DelayStrategy): RetryPolicy;
};


export type RetryPolicy = RetryPolicy$instance;

export interface ServerCertificateCustomValidationArgs$instance {
    readonly certificate: X509Certificate2 | undefined;
    readonly certificateAuthorityChain: X509Chain | undefined;
    readonly sslPolicyErrors: SslPolicyErrors;
}


export const ServerCertificateCustomValidationArgs: {
    new(certificate: X509Certificate2, certificateAuthorityChain: X509Chain, sslPolicyErrors: SslPolicyErrors): ServerCertificateCustomValidationArgs;
};


export type ServerCertificateCustomValidationArgs = ServerCertificateCustomValidationArgs$instance;

export abstract class HttpPipelineBuilder$instance {
    static build(options: ClientOptions, perCallPolicies: HttpPipelinePolicy[], perRetryPolicies: HttpPipelinePolicy[], transportOptions: HttpPipelineTransportOptions, responseClassifier: ResponseClassifier): DisposableHttpPipeline;
    static build(options: ClientOptions, perCallPolicies: HttpPipelinePolicy[], perRetryPolicies: HttpPipelinePolicy[], responseClassifier: ResponseClassifier): HttpPipeline;
    static build(options: ClientOptions, ...perRetryPolicies: HttpPipelinePolicy[]): HttpPipeline;
    static build(options: HttpPipelineOptions, transportOptions: HttpPipelineTransportOptions): DisposableHttpPipeline;
    static build(options: HttpPipelineOptions): HttpPipeline;
}


export type HttpPipelineBuilder = HttpPipelineBuilder$instance;


// Generated by tsbindgen - Architecture
// Namespace: Microsoft.IdentityModel.Tokens
// Assembly: Microsoft.IdentityModel.Tokens

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import * as Microsoft_IdentityModel_Logging_Internal from "../../Microsoft.IdentityModel.Logging/internal/index.js";
import type { ISafeLogSecurityArtifact, LoggerContext } from "../../Microsoft.IdentityModel.Logging/internal/index.js";
import type { LKGConfigurationCacheOptions } from "../../Microsoft.IdentityModel.Tokens.Configuration/internal/index.js";
import type { Dictionary, ICollection, IDictionary, IEnumerable, IList, IReadOnlyDictionary } from "@tsonic/dotnet/System.Collections.Generic.js";
import type { CompressionLevel } from "@tsonic/dotnet/System.IO.Compression.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { ArgumentException, AsyncCallback, Boolean as ClrBoolean, Byte, Char, DateTime, DateTimeKind, Enum, Exception, Func, Guid, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormattable, Int32, Int64, IntPtr, ISpanFormattable, MulticastDelegate, Nullable, Object as ClrObject, ReadOnlySpan, Span, String as ClrString, TimeSpan, Type, Uri, Void } from "@tsonic/dotnet/System.js";
import * as System_Runtime_Serialization_Internal from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "@tsonic/dotnet/System.Runtime.Serialization.js";
import * as System_Security_Claims_Internal from "@tsonic/dotnet/System.Security.Claims.js";
import type { Claim, ClaimsIdentity, ClaimsPrincipal } from "@tsonic/dotnet/System.Security.Claims.js";
import type { AsymmetricAlgorithm, ECDsa, HashAlgorithm, HashAlgorithmName, KeyedHashAlgorithm, RSA, RSAParameters } from "@tsonic/dotnet/System.Security.Cryptography.js";
import type { X509Certificate2 } from "@tsonic/dotnet/System.Security.Cryptography.X509Certificates.js";
import * as System_Security_Principal_Internal from "@tsonic/dotnet/System.Security.Principal.js";
import type { IIdentity } from "@tsonic/dotnet/System.Security.Principal.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading.js";
import type { Task } from "@tsonic/dotnet/System.Threading.Tasks.js";
import type { XmlReader, XmlWriter } from "@tsonic/dotnet/System.Xml.js";

export enum PrivateKeyStatus {
    exists = 0,
    doesNotExist = 1,
    unknown = 2
}


export enum ValidationFailure {
    none = 0,
    invalidLifetime = 1,
    invalidIssuer = 2
}


export type AlgorithmValidator = (algorithm: string, securityKey: SecurityKey, securityToken: SecurityToken, validationParameters: TokenValidationParameters) => boolean;


export type AudienceValidator = (audiences: IEnumerable<System_Internal.String>, securityToken: SecurityToken, validationParameters: TokenValidationParameters) => boolean;


export type IssuerSigningKeyResolver = (token: string, securityToken: SecurityToken, kid: string, validationParameters: TokenValidationParameters) => IEnumerable<SecurityKey>;


export type IssuerSigningKeyResolverUsingConfiguration = (token: string, securityToken: SecurityToken, kid: string, validationParameters: TokenValidationParameters, configuration: BaseConfiguration) => IEnumerable<SecurityKey>;


export type IssuerSigningKeyValidator = (securityKey: SecurityKey, securityToken: SecurityToken, validationParameters: TokenValidationParameters) => boolean;


export type IssuerSigningKeyValidatorUsingConfiguration = (securityKey: SecurityKey, securityToken: SecurityToken, validationParameters: TokenValidationParameters, configuration: BaseConfiguration) => boolean;


export type IssuerValidator = (issuer: string, securityToken: SecurityToken, validationParameters: TokenValidationParameters) => string;


export type IssuerValidatorUsingConfiguration = (issuer: string, securityToken: SecurityToken, validationParameters: TokenValidationParameters, configuration: BaseConfiguration) => string;


export type LifetimeValidator = (notBefore: Nullable<DateTime>, expires: Nullable<DateTime>, securityToken: SecurityToken, validationParameters: TokenValidationParameters) => boolean;


export type SignatureValidator = (token: string, validationParameters: TokenValidationParameters) => SecurityToken;


export type SignatureValidatorUsingConfiguration = (token: string, validationParameters: TokenValidationParameters, configuration: BaseConfiguration) => SecurityToken;


export type TokenDecryptionKeyResolver = (token: string, securityToken: SecurityToken, kid: string, validationParameters: TokenValidationParameters) => IEnumerable<SecurityKey>;


export type TokenReader = (token: string, validationParameters: TokenValidationParameters) => SecurityToken;


export type TokenReplayValidator = (expirationTime: Nullable<DateTime>, securityToken: string, validationParameters: TokenValidationParameters) => boolean;


export type TransformBeforeSignatureValidation = (token: SecurityToken, validationParameters: TokenValidationParameters) => SecurityToken;


export type TypeValidator = (type: string, securityToken: SecurityToken, validationParameters: TokenValidationParameters) => string;


export interface ICompressionProvider$instance {
    readonly algorithm: string;
    decompress(value: byte[]): byte[];
    isSupportedAlgorithm(algorithm: string): boolean;
}


export type ICompressionProvider = ICompressionProvider$instance;

export interface ICryptoProvider$instance {
    create(algorithm: string, ...args: unknown[]): unknown;
    isSupportedAlgorithm(algorithm: string, ...args: unknown[]): boolean;
    release(cryptoInstance: unknown): void;
}


export type ICryptoProvider = ICryptoProvider$instance;

export interface ISecurityTokenValidator$instance {
    readonly canValidateToken: boolean;
    maximumTokenSizeInBytes: int;
    canReadToken(securityToken: string): boolean;
    validateToken(securityToken: string, validationParameters: TokenValidationParameters, validatedToken: SecurityToken): ClaimsPrincipal;
}


export type ISecurityTokenValidator = ISecurityTokenValidator$instance;

export interface ITokenReplayCache$instance {
    tryAdd(securityToken: string, expiresOn: DateTime): boolean;
    tryFind(securityToken: string): boolean;
}


export type ITokenReplayCache = ITokenReplayCache$instance;

export interface AsymmetricSecurityKey$instance extends SecurityKey {
    readonly hasPrivateKey: boolean;
    readonly privateKeyStatus: PrivateKeyStatus;
}


export const AsymmetricSecurityKey: {
    new(): AsymmetricSecurityKey;
};


export type AsymmetricSecurityKey = AsymmetricSecurityKey$instance;

export interface AsymmetricSignatureProvider$instance extends SignatureProvider {
    readonly minimumAsymmetricKeySizeInBitsForSigningMap: IReadOnlyDictionary<System_Internal.String, System_Internal.Int32>;
    readonly minimumAsymmetricKeySizeInBitsForVerifyingMap: IReadOnlyDictionary<System_Internal.String, System_Internal.Int32>;
    sign(input: ReadOnlySpan<System_Internal.Byte>, signature: Span<System_Internal.Byte>, bytesWritten: int): boolean;
    sign(input: byte[]): byte[];
    sign(input: byte[], offset: int, count: int): byte[];
    sign(data: ReadOnlySpan<System_Internal.Byte>, destination: Span<System_Internal.Byte>, bytesWritten: int): boolean;
    validateAsymmetricSecurityKeySize(key: SecurityKey, algorithm: string, willCreateSignatures: boolean): void;
    verify(input: byte[], signature: byte[]): boolean;
    verify(input: byte[], inputOffset: int, inputLength: int, signature: byte[], signatureOffset: int, signatureLength: int): boolean;
}


export const AsymmetricSignatureProvider: {
    new(key: SecurityKey, algorithm: string): AsymmetricSignatureProvider;
    new(key: SecurityKey, algorithm: string, willCreateSignatures: boolean): AsymmetricSignatureProvider;
    readonly defaultMinimumAsymmetricKeySizeInBitsForSigningMap: Dictionary<System_Internal.String, System_Internal.Int32>;
    readonly defaultMinimumAsymmetricKeySizeInBitsForVerifyingMap: Dictionary<System_Internal.String, System_Internal.Int32>;
};


export type AsymmetricSignatureProvider = AsymmetricSignatureProvider$instance;

export interface AuthenticatedEncryptionProvider$instance {
    readonly algorithm: string;
    context: string;
    readonly key: SecurityKey;
    decrypt(ciphertext: byte[], authenticatedData: byte[], iv: byte[], authenticationTag: byte[]): byte[];
    dispose(): void;
    encrypt(plaintext: byte[], authenticatedData: byte[]): AuthenticatedEncryptionResult;
    encrypt(plaintext: byte[], authenticatedData: byte[], iv: byte[]): AuthenticatedEncryptionResult;
}


export const AuthenticatedEncryptionProvider: {
    new(key: SecurityKey, algorithm: string): AuthenticatedEncryptionProvider;
};


export type AuthenticatedEncryptionProvider = AuthenticatedEncryptionProvider$instance;

export interface AuthenticatedEncryptionResult$instance {
    readonly authenticationTag: byte[];
    readonly ciphertext: byte[];
    readonly IV: byte[];
    readonly key: SecurityKey;
}


export const AuthenticatedEncryptionResult: {
    new(key: SecurityKey, ciphertext: byte[], iv: byte[], authenticationTag: byte[]): AuthenticatedEncryptionResult;
};


export type AuthenticatedEncryptionResult = AuthenticatedEncryptionResult$instance;

export interface BaseConfiguration$instance {
    activeTokenEndpoint: string;
    issuer: string;
    readonly signingKeys: ICollection<SecurityKey>;
    readonly tokenDecryptionKeys: ICollection<SecurityKey>;
    tokenEndpoint: string;
}


export const BaseConfiguration: {
};


export type BaseConfiguration = BaseConfiguration$instance;

export interface BaseConfigurationManager$instance {
    automaticRefreshInterval: TimeSpan;
    readonly isLastKnownGoodValid: boolean;
    lastKnownGoodConfiguration: BaseConfiguration;
    lastKnownGoodLifetime: TimeSpan;
    metadataAddress: string;
    refreshInterval: TimeSpan;
    useLastKnownGoodConfiguration: boolean;
    getBaseConfigurationAsync(cancel: CancellationToken): Task<BaseConfiguration>;
    requestRefresh(): void;
}


export const BaseConfigurationManager: {
    new(): BaseConfigurationManager;
    new(options: LKGConfigurationCacheOptions): BaseConfigurationManager;
    readonly defaultAutomaticRefreshInterval: TimeSpan;
    readonly defaultLastKnownGoodConfigurationLifetime: TimeSpan;
    readonly defaultRefreshInterval: TimeSpan;
    readonly minimumAutomaticRefreshInterval: TimeSpan;
    readonly minimumRefreshInterval: TimeSpan;
};


export type BaseConfigurationManager = BaseConfigurationManager$instance;

export interface CallContext$instance extends LoggerContext {
}


export const CallContext: {
    new(): CallContext;
    new(activityId: Guid): CallContext;
};


export type CallContext = CallContext$instance;

export interface CaseSensitiveClaimsIdentity$instance extends ClaimsIdentity {
    readonly securityToken: SecurityToken;
    findAll(type: string): IEnumerable<Claim>;
    findFirst(type: string): Claim;
    hasClaim(type: string, value: string): boolean;
}


export const CaseSensitiveClaimsIdentity: {
    new(): CaseSensitiveClaimsIdentity;
    new(authenticationType: string): CaseSensitiveClaimsIdentity;
    new(claimsIdentity: ClaimsIdentity): CaseSensitiveClaimsIdentity;
    new(claims: IEnumerable<Claim>): CaseSensitiveClaimsIdentity;
    new(claims: IEnumerable<Claim>, authenticationType: string): CaseSensitiveClaimsIdentity;
    new(claims: IEnumerable<Claim>, authenticationType: string, nameType: string, roleType: string): CaseSensitiveClaimsIdentity;
    new(authenticationType: string, nameType: string, roleType: string): CaseSensitiveClaimsIdentity;
};


export type CaseSensitiveClaimsIdentity = CaseSensitiveClaimsIdentity$instance;

export interface CompressionAlgorithms$instance {
}


export const CompressionAlgorithms: {
    new(): CompressionAlgorithms;
    readonly deflate: string;
};


export type CompressionAlgorithms = CompressionAlgorithms$instance;

export interface CompressionProviderFactory$instance {
    customCompressionProvider: ICompressionProvider;
    createCompressionProvider(algorithm: string): ICompressionProvider;
    createCompressionProvider(algorithm: string, maximumDeflateSize: int): ICompressionProvider;
    isSupportedAlgorithm(algorithm: string): boolean;
}


export const CompressionProviderFactory: {
    new(): CompressionProviderFactory;
    new(other: CompressionProviderFactory): CompressionProviderFactory;
    default: CompressionProviderFactory;
};


export type CompressionProviderFactory = CompressionProviderFactory$instance;

export interface CryptoProviderCache$instance {
    tryAdd(signatureProvider: SignatureProvider): boolean;
    tryGetSignatureProvider(securityKey: SecurityKey, algorithm: string, typeofProvider: string, willCreateSignatures: boolean, signatureProvider: SignatureProvider): boolean;
    tryRemove(signatureProvider: SignatureProvider): boolean;
}


export const CryptoProviderCache: {
};


export type CryptoProviderCache = CryptoProviderCache$instance;

export interface CryptoProviderCacheOptions$instance {
    sizeLimit: int;
}


export const CryptoProviderCacheOptions: {
    new(): CryptoProviderCacheOptions;
    readonly defaultSizeLimit: int;
};


export type CryptoProviderCacheOptions = CryptoProviderCacheOptions$instance;

export interface CryptoProviderFactory$instance {
    cacheSignatureProviders: boolean;
    readonly cryptoProviderCache: CryptoProviderCache;
    customCryptoProvider: ICryptoProvider;
    signatureProviderObjectPoolCacheSize: int;
    createAuthenticatedEncryptionProvider(key: SecurityKey, algorithm: string): AuthenticatedEncryptionProvider;
    createForSigning(key: SecurityKey, algorithm: string): SignatureProvider;
    createForSigning(key: SecurityKey, algorithm: string, cacheProvider: boolean): SignatureProvider;
    createForVerifying(key: SecurityKey, algorithm: string): SignatureProvider;
    createForVerifying(key: SecurityKey, algorithm: string, cacheProvider: boolean): SignatureProvider;
    createHashAlgorithm(algorithm: HashAlgorithmName): HashAlgorithm;
    createHashAlgorithm(algorithm: string): HashAlgorithm;
    createKeyedHashAlgorithm(keyBytes: byte[], algorithm: string): KeyedHashAlgorithm;
    createKeyWrapProvider(key: SecurityKey, algorithm: string): KeyWrapProvider;
    createKeyWrapProviderForUnwrap(key: SecurityKey, algorithm: string): KeyWrapProvider;
    isSupportedAlgorithm(algorithm: string): boolean;
    isSupportedAlgorithm(algorithm: string, key: SecurityKey): boolean;
    releaseHashAlgorithm(hashAlgorithm: HashAlgorithm): void;
    releaseKeyWrapProvider(provider: KeyWrapProvider): void;
    releaseRsaKeyWrapProvider(provider: RsaKeyWrapProvider): void;
    releaseSignatureProvider(signatureProvider: SignatureProvider): void;
}


export const CryptoProviderFactory: {
    new(): CryptoProviderFactory;
    new(cache: CryptoProviderCache): CryptoProviderFactory;
    new(other: CryptoProviderFactory): CryptoProviderFactory;
    default: CryptoProviderFactory;
    defaultCacheSignatureProviders: boolean;
    defaultSignatureProviderObjectPoolCacheSize: int;
};


export type CryptoProviderFactory = CryptoProviderFactory$instance;

export interface DeflateCompressionProvider$instance {
    readonly algorithm: string;
    readonly compressionLevel: CompressionLevel;
    maximumDeflateSize: int;
    compress(value: byte[]): byte[];
    decompress(value: byte[]): byte[];
    isSupportedAlgorithm(algorithm: string): boolean;
}


export const DeflateCompressionProvider: {
    new(): DeflateCompressionProvider;
    new(compressionLevel: CompressionLevel): DeflateCompressionProvider;
};


export interface __DeflateCompressionProvider$views {
    As_ICompressionProvider(): ICompressionProvider$instance;
}

export interface DeflateCompressionProvider$instance extends ICompressionProvider$instance {}

export type DeflateCompressionProvider = DeflateCompressionProvider$instance & __DeflateCompressionProvider$views;


export interface EcdhKeyExchangeProvider$instance {
    keyDataLen: int;
    generateKdf(apu?: string, apv?: string): SecurityKey;
}


export const EcdhKeyExchangeProvider: {
    new(privateKey: SecurityKey, publicKey: SecurityKey, alg: string, enc: string): EcdhKeyExchangeProvider;
};


export type EcdhKeyExchangeProvider = EcdhKeyExchangeProvider$instance;

export interface ECDsaSecurityKey$instance extends AsymmetricSecurityKey {
    readonly ecDsa: ECDsa;
    readonly hasPrivateKey: boolean;
    readonly keySize: int;
    readonly privateKeyStatus: PrivateKeyStatus;
    canComputeJwkThumbprint(): boolean;
    computeJwkThumbprint(): byte[];
}


export const ECDsaSecurityKey: {
    new(ecdsa: ECDsa): ECDsaSecurityKey;
};


export type ECDsaSecurityKey = ECDsaSecurityKey$instance;

export interface EncryptingCredentials$instance {
    readonly alg: string;
    cryptoProviderFactory: CryptoProviderFactory;
    readonly enc: string;
    readonly key: SecurityKey;
    keyExchangePublicKey: SecurityKey;
    setDefaultCtyClaim: boolean;
}


export const EncryptingCredentials: {
    new(key: SecurityKey, alg: string, enc: string): EncryptingCredentials;
    new(key: SymmetricSecurityKey, enc: string): EncryptingCredentials;
};


export type EncryptingCredentials = EncryptingCredentials$instance;

export interface InMemoryCryptoProviderCache$instance extends CryptoProviderCache {
    dispose(): void;
    tryAdd(signatureProvider: SignatureProvider): boolean;
    tryGetSignatureProvider(securityKey: SecurityKey, algorithm: string, typeofProvider: string, willCreateSignatures: boolean, signatureProvider: SignatureProvider): boolean;
    tryRemove(signatureProvider: SignatureProvider): boolean;
}


export const InMemoryCryptoProviderCache: {
    new(): InMemoryCryptoProviderCache;
    new(cryptoProviderCacheOptions: CryptoProviderCacheOptions): InMemoryCryptoProviderCache;
};


export type InMemoryCryptoProviderCache = InMemoryCryptoProviderCache$instance;

export interface JsonWebKey$instance extends SecurityKey {
    readonly additionalData: IDictionary<System_Internal.String, unknown>;
    alg: string;
    crv: string;
    D: string;
    DP: string;
    DQ: string;
    E: string;
    readonly hasPrivateKey: boolean;
    K: string;
    keyId: string;
    readonly keyOps: IList<System_Internal.String>;
    readonly keySize: int;
    kid: string;
    kty: string;
    N: string;
    readonly oth: IList<System_Internal.String>;
    P: string;
    Q: string;
    QI: string;
    use: string;
    X: string;
    readonly x5c: IList<System_Internal.String>;
    x5t: string;
    x5tS256: string;
    x5u: string;
    Y: string;
    canComputeJwkThumbprint(): boolean;
    computeJwkThumbprint(): byte[];
    toString(): string | undefined;
}


export const JsonWebKey: {
    new(): JsonWebKey;
    new(json: string): JsonWebKey;
    create(json: string): JsonWebKey;
};


export type JsonWebKey = JsonWebKey$instance;

export interface JsonWebKeyConverter$instance {
}


export const JsonWebKeyConverter: {
    new(): JsonWebKeyConverter;
    convertFromECDsaSecurityKey(key: ECDsaSecurityKey): JsonWebKey;
    convertFromRSASecurityKey(key: RsaSecurityKey): JsonWebKey;
    convertFromSecurityKey(key: SecurityKey): JsonWebKey;
    convertFromSymmetricSecurityKey(key: SymmetricSecurityKey): JsonWebKey;
    convertFromX509SecurityKey(key: X509SecurityKey, representAsRsaKey: boolean): JsonWebKey;
    convertFromX509SecurityKey(key: X509SecurityKey): JsonWebKey;
};


export type JsonWebKeyConverter = JsonWebKeyConverter$instance;

export interface JsonWebKeySet$instance {
    readonly additionalData: IDictionary<System_Internal.String, unknown>;
    readonly keys: IList<JsonWebKey>;
    skipUnresolvedJsonWebKeys: boolean;
    getSigningKeys(): IList<SecurityKey>;
}


export const JsonWebKeySet: {
    new(): JsonWebKeySet;
    new(json: string): JsonWebKeySet;
    defaultSkipUnresolvedJsonWebKeys: boolean;
    create(json: string): JsonWebKeySet;
};


export type JsonWebKeySet = JsonWebKeySet$instance;

export interface KeyWrapProvider$instance {
    readonly algorithm: string;
    context: string;
    readonly key: SecurityKey;
    dispose(): void;
    unwrapKey(keyBytes: byte[]): byte[];
    wrapKey(keyBytes: byte[]): byte[];
}


export const KeyWrapProvider: {
};


export type KeyWrapProvider = KeyWrapProvider$instance;

export interface RsaKeyWrapProvider$instance extends KeyWrapProvider {
    readonly algorithm: string;
    context: string;
    readonly key: SecurityKey;
    unwrapKey(keyBytes: byte[]): byte[];
    wrapKey(keyBytes: byte[]): byte[];
}


export const RsaKeyWrapProvider: {
    new(key: SecurityKey, algorithm: string, willUnwrap: boolean): RsaKeyWrapProvider;
};


export type RsaKeyWrapProvider = RsaKeyWrapProvider$instance;

export interface RsaSecurityKey$instance extends AsymmetricSecurityKey {
    readonly hasPrivateKey: boolean;
    readonly keySize: int;
    readonly parameters: RSAParameters;
    readonly privateKeyStatus: PrivateKeyStatus;
    readonly rsa: RSA;
    canComputeJwkThumbprint(): boolean;
    computeJwkThumbprint(): byte[];
}


export const RsaSecurityKey: {
    new(rsaParameters: RSAParameters): RsaSecurityKey;
    new(rsa: RSA): RsaSecurityKey;
};


export type RsaSecurityKey = RsaSecurityKey$instance;

export interface SecurityKey$instance {
    cryptoProviderFactory: CryptoProviderFactory;
    keyId: string;
    readonly keySize: int;
    canComputeJwkThumbprint(): boolean;
    computeJwkThumbprint(): byte[];
    isSupportedAlgorithm(algorithm: string): boolean;
    toString(): string | undefined;
}


export const SecurityKey: {
    new(): SecurityKey;
};


export type SecurityKey = SecurityKey$instance;

export interface SecurityKeyIdentifierClause$instance {
}


export const SecurityKeyIdentifierClause: {
    new(): SecurityKeyIdentifierClause;
};


export type SecurityKeyIdentifierClause = SecurityKeyIdentifierClause$instance;

export interface SecurityToken$instance {
    readonly id: string;
    readonly issuer: string;
    readonly securityKey: SecurityKey;
    signingKey: SecurityKey;
    readonly validFrom: DateTime;
    readonly validTo: DateTime;
    unsafeToString(): string;
}


export const SecurityToken: {
};


export interface __SecurityToken$views {
    As_ISafeLogSecurityArtifact(): Microsoft_IdentityModel_Logging_Internal.ISafeLogSecurityArtifact$instance;
}

export interface SecurityToken$instance extends Microsoft_IdentityModel_Logging_Internal.ISafeLogSecurityArtifact$instance {}

export type SecurityToken = SecurityToken$instance & __SecurityToken$views;


export interface SecurityTokenArgumentException$instance extends ArgumentException {
}


export const SecurityTokenArgumentException: {
    new(): SecurityTokenArgumentException;
    new(message: string): SecurityTokenArgumentException;
    new(message: string, innerException: Exception): SecurityTokenArgumentException;
};


export type SecurityTokenArgumentException = SecurityTokenArgumentException$instance;

export interface SecurityTokenCompressionFailedException$instance extends SecurityTokenException {
}


export const SecurityTokenCompressionFailedException: {
    new(): SecurityTokenCompressionFailedException;
    new(message: string): SecurityTokenCompressionFailedException;
    new(message: string, inner: Exception): SecurityTokenCompressionFailedException;
};


export type SecurityTokenCompressionFailedException = SecurityTokenCompressionFailedException$instance;

export interface SecurityTokenDecompressionFailedException$instance extends SecurityTokenException {
}


export const SecurityTokenDecompressionFailedException: {
    new(): SecurityTokenDecompressionFailedException;
    new(message: string): SecurityTokenDecompressionFailedException;
    new(message: string, inner: Exception): SecurityTokenDecompressionFailedException;
};


export type SecurityTokenDecompressionFailedException = SecurityTokenDecompressionFailedException$instance;

export interface SecurityTokenDecryptionFailedException$instance extends SecurityTokenException {
}


export const SecurityTokenDecryptionFailedException: {
    new(): SecurityTokenDecryptionFailedException;
    new(message: string): SecurityTokenDecryptionFailedException;
    new(message: string, innerException: Exception): SecurityTokenDecryptionFailedException;
};


export type SecurityTokenDecryptionFailedException = SecurityTokenDecryptionFailedException$instance;

export interface SecurityTokenDescriptor$instance {
    additionalHeaderClaims: IDictionary<System_Internal.String, unknown>;
    additionalInnerHeaderClaims: IDictionary<System_Internal.String, unknown>;
    audience: string;
    claims: IDictionary<System_Internal.String, unknown>;
    compressionAlgorithm: string;
    encryptingCredentials: EncryptingCredentials;
    expires: Nullable<DateTime>;
    issuedAt: Nullable<DateTime>;
    issuer: string;
    notBefore: Nullable<DateTime>;
    signingCredentials: SigningCredentials;
    get subject(): ClaimsIdentity | undefined;
    set subject(value: ClaimsIdentity);
    tokenType: string;
}


export const SecurityTokenDescriptor: {
    new(): SecurityTokenDescriptor;
};


export type SecurityTokenDescriptor = SecurityTokenDescriptor$instance;

export interface SecurityTokenEncryptionFailedException$instance extends SecurityTokenException {
}


export const SecurityTokenEncryptionFailedException: {
    new(): SecurityTokenEncryptionFailedException;
    new(message: string): SecurityTokenEncryptionFailedException;
    new(message: string, innerException: Exception): SecurityTokenEncryptionFailedException;
};


export type SecurityTokenEncryptionFailedException = SecurityTokenEncryptionFailedException$instance;

export interface SecurityTokenEncryptionKeyNotFoundException$instance extends SecurityTokenDecryptionFailedException {
}


export const SecurityTokenEncryptionKeyNotFoundException: {
    new(): SecurityTokenEncryptionKeyNotFoundException;
    new(message: string): SecurityTokenEncryptionKeyNotFoundException;
    new(message: string, innerException: Exception): SecurityTokenEncryptionKeyNotFoundException;
};


export type SecurityTokenEncryptionKeyNotFoundException = SecurityTokenEncryptionKeyNotFoundException$instance;

export interface SecurityTokenException$instance extends Exception {
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SecurityTokenException: {
    new(): SecurityTokenException;
    new(message: string): SecurityTokenException;
    new(message: string, innerException: Exception): SecurityTokenException;
};


export type SecurityTokenException = SecurityTokenException$instance;

export interface SecurityTokenExpiredException$instance extends SecurityTokenValidationException {
    expires: DateTime;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SecurityTokenExpiredException: {
    new(): SecurityTokenExpiredException;
    new(message: string): SecurityTokenExpiredException;
    new(message: string, inner: Exception): SecurityTokenExpiredException;
};


export type SecurityTokenExpiredException = SecurityTokenExpiredException$instance;

export interface SecurityTokenHandler$instance extends TokenHandler {
    readonly canValidateToken: boolean;
    readonly canWriteToken: boolean;
    readonly tokenType: Type;
    canReadToken(reader: XmlReader): boolean;
    canReadToken(tokenString: string): boolean;
    createSecurityTokenReference(token: SecurityToken, attached: boolean): SecurityKeyIdentifierClause;
    createToken(tokenDescriptor: SecurityTokenDescriptor): SecurityToken;
    readToken(token: string): SecurityToken;
    validateToken(securityToken: string, validationParameters: TokenValidationParameters, validatedToken: SecurityToken): ClaimsPrincipal;
    validateToken(reader: XmlReader, validationParameters: TokenValidationParameters, validatedToken: SecurityToken): ClaimsPrincipal;
    writeToken(token: SecurityToken): string;
    writeToken(writer: XmlWriter, token: SecurityToken): void;
}


export const SecurityTokenHandler: {
};


export interface __SecurityTokenHandler$views {
    As_ISecurityTokenValidator(): ISecurityTokenValidator$instance;
}

export interface SecurityTokenHandler$instance extends ISecurityTokenValidator$instance {}

export type SecurityTokenHandler = SecurityTokenHandler$instance & __SecurityTokenHandler$views;


export interface SecurityTokenInvalidAlgorithmException$instance extends SecurityTokenValidationException {
    invalidAlgorithm: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SecurityTokenInvalidAlgorithmException: {
    new(): SecurityTokenInvalidAlgorithmException;
    new(message: string): SecurityTokenInvalidAlgorithmException;
    new(message: string, innerException: Exception): SecurityTokenInvalidAlgorithmException;
};


export type SecurityTokenInvalidAlgorithmException = SecurityTokenInvalidAlgorithmException$instance;

export interface SecurityTokenInvalidAudienceException$instance extends SecurityTokenValidationException {
    invalidAudience: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SecurityTokenInvalidAudienceException: {
    new(): SecurityTokenInvalidAudienceException;
    new(message: string): SecurityTokenInvalidAudienceException;
    new(message: string, innerException: Exception): SecurityTokenInvalidAudienceException;
};


export type SecurityTokenInvalidAudienceException = SecurityTokenInvalidAudienceException$instance;

export interface SecurityTokenInvalidIssuerException$instance extends SecurityTokenValidationException {
    invalidIssuer: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SecurityTokenInvalidIssuerException: {
    new(): SecurityTokenInvalidIssuerException;
    new(message: string): SecurityTokenInvalidIssuerException;
    new(message: string, innerException: Exception): SecurityTokenInvalidIssuerException;
};


export type SecurityTokenInvalidIssuerException = SecurityTokenInvalidIssuerException$instance;

export interface SecurityTokenInvalidLifetimeException$instance extends SecurityTokenValidationException {
    expires: Nullable<DateTime>;
    notBefore: Nullable<DateTime>;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SecurityTokenInvalidLifetimeException: {
    new(): SecurityTokenInvalidLifetimeException;
    new(message: string): SecurityTokenInvalidLifetimeException;
    new(message: string, innerException: Exception): SecurityTokenInvalidLifetimeException;
};


export type SecurityTokenInvalidLifetimeException = SecurityTokenInvalidLifetimeException$instance;

export interface SecurityTokenInvalidSignatureException$instance extends SecurityTokenValidationException {
}


export const SecurityTokenInvalidSignatureException: {
    new(): SecurityTokenInvalidSignatureException;
    new(message: string): SecurityTokenInvalidSignatureException;
    new(message: string, innerException: Exception): SecurityTokenInvalidSignatureException;
};


export type SecurityTokenInvalidSignatureException = SecurityTokenInvalidSignatureException$instance;

export interface SecurityTokenInvalidSigningKeyException$instance extends SecurityTokenValidationException {
    signingKey: SecurityKey;
}


export const SecurityTokenInvalidSigningKeyException: {
    new(): SecurityTokenInvalidSigningKeyException;
    new(message: string): SecurityTokenInvalidSigningKeyException;
    new(message: string, inner: Exception): SecurityTokenInvalidSigningKeyException;
};


export type SecurityTokenInvalidSigningKeyException = SecurityTokenInvalidSigningKeyException$instance;

export interface SecurityTokenInvalidTypeException$instance extends SecurityTokenValidationException {
    invalidType: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SecurityTokenInvalidTypeException: {
    new(): SecurityTokenInvalidTypeException;
    new(message: string): SecurityTokenInvalidTypeException;
    new(message: string, innerException: Exception): SecurityTokenInvalidTypeException;
};


export type SecurityTokenInvalidTypeException = SecurityTokenInvalidTypeException$instance;

export interface SecurityTokenKeyWrapException$instance extends SecurityTokenException {
}


export const SecurityTokenKeyWrapException: {
    new(): SecurityTokenKeyWrapException;
    new(message: string): SecurityTokenKeyWrapException;
    new(message: string, innerException: Exception): SecurityTokenKeyWrapException;
};


export type SecurityTokenKeyWrapException = SecurityTokenKeyWrapException$instance;

export interface SecurityTokenMalformedException$instance extends SecurityTokenArgumentException {
}


export const SecurityTokenMalformedException: {
    new(): SecurityTokenMalformedException;
    new(message: string): SecurityTokenMalformedException;
    new(message: string, innerException: Exception): SecurityTokenMalformedException;
};


export type SecurityTokenMalformedException = SecurityTokenMalformedException$instance;

export interface SecurityTokenNoExpirationException$instance extends SecurityTokenValidationException {
}


export const SecurityTokenNoExpirationException: {
    new(): SecurityTokenNoExpirationException;
    new(message: string): SecurityTokenNoExpirationException;
    new(message: string, innerException: Exception): SecurityTokenNoExpirationException;
};


export type SecurityTokenNoExpirationException = SecurityTokenNoExpirationException$instance;

export interface SecurityTokenNotYetValidException$instance extends SecurityTokenValidationException {
    notBefore: DateTime;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SecurityTokenNotYetValidException: {
    new(): SecurityTokenNotYetValidException;
    new(message: string): SecurityTokenNotYetValidException;
    new(message: string, inner: Exception): SecurityTokenNotYetValidException;
};


export type SecurityTokenNotYetValidException = SecurityTokenNotYetValidException$instance;

export interface SecurityTokenReplayAddFailedException$instance extends SecurityTokenValidationException {
}


export const SecurityTokenReplayAddFailedException: {
    new(): SecurityTokenReplayAddFailedException;
    new(message: string): SecurityTokenReplayAddFailedException;
    new(message: string, innerException: Exception): SecurityTokenReplayAddFailedException;
};


export type SecurityTokenReplayAddFailedException = SecurityTokenReplayAddFailedException$instance;

export interface SecurityTokenReplayDetectedException$instance extends SecurityTokenValidationException {
}


export const SecurityTokenReplayDetectedException: {
    new(): SecurityTokenReplayDetectedException;
    new(message: string): SecurityTokenReplayDetectedException;
    new(message: string, inner: Exception): SecurityTokenReplayDetectedException;
};


export type SecurityTokenReplayDetectedException = SecurityTokenReplayDetectedException$instance;

export interface SecurityTokenSignatureKeyNotFoundException$instance extends SecurityTokenInvalidSignatureException {
}


export const SecurityTokenSignatureKeyNotFoundException: {
    new(): SecurityTokenSignatureKeyNotFoundException;
    new(message: string): SecurityTokenSignatureKeyNotFoundException;
    new(message: string, innerException: Exception): SecurityTokenSignatureKeyNotFoundException;
};


export type SecurityTokenSignatureKeyNotFoundException = SecurityTokenSignatureKeyNotFoundException$instance;

export interface SecurityTokenUnableToValidateException$instance extends SecurityTokenInvalidSignatureException {
    validationFailure: ValidationFailure;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SecurityTokenUnableToValidateException: {
    new(): SecurityTokenUnableToValidateException;
    new(validationFailure: ValidationFailure, message: string): SecurityTokenUnableToValidateException;
    new(message: string): SecurityTokenUnableToValidateException;
    new(message: string, innerException: Exception): SecurityTokenUnableToValidateException;
};


export type SecurityTokenUnableToValidateException = SecurityTokenUnableToValidateException$instance;

export interface SecurityTokenValidationException$instance extends SecurityTokenException {
}


export const SecurityTokenValidationException: {
    new(): SecurityTokenValidationException;
    new(message: string): SecurityTokenValidationException;
    new(message: string, innerException: Exception): SecurityTokenValidationException;
};


export type SecurityTokenValidationException = SecurityTokenValidationException$instance;

export interface SignatureProvider$instance {
    readonly algorithm: string;
    context: string;
    cryptoProviderCache: CryptoProviderCache;
    readonly key: SecurityKey;
    readonly willCreateSignatures: boolean;
    dispose(): void;
    sign(input: byte[]): byte[];
    sign(input: byte[], offset: int, count: int): byte[];
    sign(data: ReadOnlySpan<System_Internal.Byte>, destination: Span<System_Internal.Byte>, bytesWritten: int): boolean;
    verify(input: byte[], signature: byte[]): boolean;
    verify(input: byte[], inputOffset: int, inputLength: int, signature: byte[], signatureOffset: int, signatureLength: int): boolean;
}


export const SignatureProvider: {
};


export type SignatureProvider = SignatureProvider$instance;

export interface SigningCredentials$instance {
    readonly algorithm: string;
    cryptoProviderFactory: CryptoProviderFactory;
    readonly digest: string;
    readonly key: SecurityKey;
    readonly kid: string;
}


export const SigningCredentials: {
    new(key: SecurityKey, algorithm: string): SigningCredentials;
    new(key: SecurityKey, algorithm: string, digest: string): SigningCredentials;
};


export type SigningCredentials = SigningCredentials$instance;

export interface SymmetricKeyWrapProvider$instance extends KeyWrapProvider {
    readonly algorithm: string;
    context: string;
    readonly key: SecurityKey;
    unwrapKey(keyBytes: byte[]): byte[];
    wrapKey(keyBytes: byte[]): byte[];
}


export const SymmetricKeyWrapProvider: {
    new(key: SecurityKey, algorithm: string): SymmetricKeyWrapProvider;
};


export type SymmetricKeyWrapProvider = SymmetricKeyWrapProvider$instance;

export interface SymmetricSecurityKey$instance extends SecurityKey {
    readonly key: byte[];
    readonly keySize: int;
    canComputeJwkThumbprint(): boolean;
    computeJwkThumbprint(): byte[];
}


export const SymmetricSecurityKey: {
    new(key: byte[]): SymmetricSecurityKey;
};


export type SymmetricSecurityKey = SymmetricSecurityKey$instance;

export interface SymmetricSignatureProvider$instance extends SignatureProvider {
    minimumSymmetricKeySizeInBits: int;
    sign(input: byte[]): byte[];
    sign(input: ReadOnlySpan<System_Internal.Byte>, signature: Span<System_Internal.Byte>, bytesWritten: int): boolean;
    sign(input: byte[], offset: int, count: int): byte[];
    sign(data: ReadOnlySpan<System_Internal.Byte>, destination: Span<System_Internal.Byte>, bytesWritten: int): boolean;
    verify(input: byte[], signature: byte[]): boolean;
    verify(input: byte[], signature: byte[], length: int): boolean;
    verify(input: byte[], inputOffset: int, inputLength: int, signature: byte[], signatureOffset: int, signatureLength: int): boolean;
}


export const SymmetricSignatureProvider: {
    new(key: SecurityKey, algorithm: string): SymmetricSignatureProvider;
    new(key: SecurityKey, algorithm: string, willCreateSignatures: boolean): SymmetricSignatureProvider;
    readonly defaultMinimumSymmetricKeySizeInBits: int;
};


export type SymmetricSignatureProvider = SymmetricSignatureProvider$instance;

export interface TokenContext$instance extends CallContext {
}


export const TokenContext: {
    new(): TokenContext;
    new(activityId: Guid): TokenContext;
};


export type TokenContext = TokenContext$instance;

export interface TokenHandler$instance {
    maximumTokenSizeInBytes: int;
    setDefaultTimesOnTokenCreation: boolean;
    tokenLifetimeInMinutes: int;
    readToken(token: string): SecurityToken;
    validateTokenAsync(token: string, validationParameters: TokenValidationParameters): Task<TokenValidationResult>;
    validateTokenAsync(token: SecurityToken, validationParameters: TokenValidationParameters): Task<TokenValidationResult>;
}


export const TokenHandler: {
    readonly defaultTokenLifetimeInMinutes: int;
};


export type TokenHandler = TokenHandler$instance;

export interface TokenValidationParameters$instance {
    actorValidationParameters: TokenValidationParameters;
    algorithmValidator: AlgorithmValidator;
    audienceValidator: AudienceValidator;
    authenticationType: string;
    clockSkew: TimeSpan;
    configurationManager: BaseConfigurationManager;
    cryptoProviderFactory: CryptoProviderFactory;
    debugId: string;
    ignoreTrailingSlashWhenValidatingAudience: boolean;
    includeTokenOnFailedValidation: boolean;
    readonly instancePropertyBag: IDictionary<System_Internal.String, unknown>;
    readonly isClone: boolean;
    issuerSigningKey: SecurityKey;
    issuerSigningKeyResolver: IssuerSigningKeyResolver;
    issuerSigningKeyResolverUsingConfiguration: IssuerSigningKeyResolverUsingConfiguration;
    issuerSigningKeys: IEnumerable<SecurityKey>;
    issuerSigningKeyValidator: IssuerSigningKeyValidator;
    issuerSigningKeyValidatorUsingConfiguration: IssuerSigningKeyValidatorUsingConfiguration;
    issuerValidator: IssuerValidator;
    issuerValidatorUsingConfiguration: IssuerValidatorUsingConfiguration;
    lifetimeValidator: LifetimeValidator;
    logTokenId: boolean;
    logValidationExceptions: boolean;
    nameClaimType: string;
    nameClaimTypeRetriever: Func<SecurityToken, System_Internal.String, System_Internal.String>;
    propertyBag: IDictionary<System_Internal.String, unknown>;
    refreshBeforeValidation: boolean;
    requireAudience: boolean;
    requireExpirationTime: boolean;
    requireSignedTokens: boolean;
    roleClaimType: string;
    roleClaimTypeRetriever: Func<SecurityToken, System_Internal.String, System_Internal.String>;
    saveSigninToken: boolean;
    signatureValidator: SignatureValidator;
    signatureValidatorUsingConfiguration: SignatureValidatorUsingConfiguration;
    tokenDecryptionKey: SecurityKey;
    tokenDecryptionKeyResolver: TokenDecryptionKeyResolver;
    tokenDecryptionKeys: IEnumerable<SecurityKey>;
    tokenReader: TokenReader;
    tokenReplayCache: ITokenReplayCache;
    tokenReplayValidator: TokenReplayValidator;
    transformBeforeSignatureValidation: TransformBeforeSignatureValidation;
    tryAllIssuerSigningKeys: boolean;
    typeValidator: TypeValidator;
    validAlgorithms: IEnumerable<System_Internal.String>;
    validateActor: boolean;
    validateAudience: boolean;
    validateIssuer: boolean;
    validateIssuerSigningKey: boolean;
    validateLifetime: boolean;
    validateSignatureLast: boolean;
    validateTokenReplay: boolean;
    validateWithLKG: boolean;
    validAudience: string;
    validAudiences: IEnumerable<System_Internal.String>;
    validIssuer: string;
    validIssuers: IEnumerable<System_Internal.String>;
    validTypes: IEnumerable<System_Internal.String>;
    clone(): TokenValidationParameters;
    createClaimsIdentity(securityToken: SecurityToken, issuer: string): ClaimsIdentity;
}


export const TokenValidationParameters: {
    new(): TokenValidationParameters;
    readonly defaultAuthenticationType: string;
    readonly defaultClockSkew: TimeSpan;
    readonly defaultMaximumTokenSizeInBytes: int;
};


export type TokenValidationParameters = TokenValidationParameters$instance;

export interface TokenValidationResult$instance {
    readonly claims: IDictionary<System_Internal.String, unknown>;
    claimsIdentity: ClaimsIdentity;
    exception: Exception;
    issuer: string;
    isValid: boolean;
    readonly propertyBag: IDictionary<System_Internal.String, unknown>;
    securityToken: SecurityToken;
    tokenContext: CallContext;
    readonly tokenOnFailedValidation: SecurityToken;
    tokenType: string;
}


export const TokenValidationResult: {
    new(): TokenValidationResult;
};


export type TokenValidationResult = TokenValidationResult$instance;

export interface X509EncryptingCredentials$instance extends EncryptingCredentials {
    readonly certificate: X509Certificate2 | undefined;
}


export const X509EncryptingCredentials: {
    new(certificate: X509Certificate2): X509EncryptingCredentials;
    new(certificate: X509Certificate2, keyWrapAlgorithm: string, dataEncryptionAlgorithm: string): X509EncryptingCredentials;
};


export type X509EncryptingCredentials = X509EncryptingCredentials$instance;

export interface X509SecurityKey$instance extends AsymmetricSecurityKey {
    readonly certificate: X509Certificate2 | undefined;
    readonly hasPrivateKey: boolean;
    readonly keySize: int;
    readonly privateKey: AsymmetricAlgorithm;
    readonly privateKeyStatus: PrivateKeyStatus;
    readonly publicKey: AsymmetricAlgorithm;
    readonly x5t: string;
    canComputeJwkThumbprint(): boolean;
    computeJwkThumbprint(): byte[];
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const X509SecurityKey: {
    new(certificate: X509Certificate2): X509SecurityKey;
    new(certificate: X509Certificate2, keyId: string): X509SecurityKey;
};


export type X509SecurityKey = X509SecurityKey$instance;

export interface X509SigningCredentials$instance extends SigningCredentials {
    readonly certificate: X509Certificate2 | undefined;
}


export const X509SigningCredentials: {
    new(certificate: X509Certificate2): X509SigningCredentials;
    new(certificate: X509Certificate2, algorithm: string): X509SigningCredentials;
};


export type X509SigningCredentials = X509SigningCredentials$instance;

export abstract class Base64UrlEncoder$instance {
    static decode(arg: string): string;
    static decodeBytes(str: string): byte[];
    static encode(inArray: byte[], offset: int, length: int): string;
    static encode(inArray: byte[]): string;
    static encode(inArray: ReadOnlySpan<System_Internal.Byte>, output: Span<System_Internal.Char>): int;
    static encode(arg: string): string;
}


export type Base64UrlEncoder = Base64UrlEncoder$instance;

export abstract class CollectionUtilities$instance {
    static isNullOrEmpty<T>(enumerable: IEnumerable<T>): boolean;
}


export type CollectionUtilities = CollectionUtilities$instance;

export abstract class DateTimeUtil$instance {
    static add(time: DateTime, timespan: TimeSpan): DateTime;
    static getMaxValue(kind: DateTimeKind): DateTime;
    static getMinValue(kind: DateTimeKind): DateTime;
    static toUniversalTime(value: DateTime): DateTime;
    static toUniversalTime(value: Nullable<DateTime>): Nullable<DateTime>;
}


export type DateTimeUtil = DateTimeUtil$instance;

export abstract class EpochTime$instance {
    static readonly unixEpoch: DateTime;
    static dateTime(secondsSinceUnixEpoch: long): DateTime;
    static getIntDate(datetime: DateTime): long;
}


export type EpochTime = EpochTime$instance;

export abstract class JsonWebAlgorithmsKeyTypes$instance {
    static readonly ellipticCurve: string;
    static readonly RSA: string;
    static readonly octet: string;
}


export type JsonWebAlgorithmsKeyTypes = JsonWebAlgorithmsKeyTypes$instance;

export abstract class JsonWebKeyECTypes$instance {
    static readonly P256: string;
    static readonly P384: string;
    static readonly P512: string;
    static readonly P521: string;
}


export type JsonWebKeyECTypes = JsonWebKeyECTypes$instance;

export abstract class JsonWebKeyParameterNames$instance {
    static readonly alg: string;
    static readonly crv: string;
    static readonly D: string;
    static readonly DP: string;
    static readonly DQ: string;
    static readonly E: string;
    static readonly K: string;
    static readonly keyOps: string;
    static readonly keys: string;
    static readonly kid: string;
    static readonly kty: string;
    static readonly N: string;
    static readonly oth: string;
    static readonly P: string;
    static readonly Q: string;
    static readonly QI: string;
    static readonly use: string;
    static readonly X: string;
    static readonly x5c: string;
    static readonly x5t: string;
    static readonly x5tS256: string;
    static readonly x5u: string;
    static readonly Y: string;
}


export type JsonWebKeyParameterNames = JsonWebKeyParameterNames$instance;

export abstract class JsonWebKeySetParameterNames$instance {
    static readonly keys: string;
}


export type JsonWebKeySetParameterNames = JsonWebKeySetParameterNames$instance;

export abstract class JsonWebKeyUseNames$instance {
    static readonly sig: string;
    static readonly enc: string;
}


export type JsonWebKeyUseNames = JsonWebKeyUseNames$instance;

export abstract class SecurityAlgorithms$instance {
    static readonly aes128Encryption: string;
    static readonly aes192Encryption: string;
    static readonly aes256Encryption: string;
    static readonly desEncryption: string;
    static readonly aes128KeyWrap: string;
    static readonly aes192KeyWrap: string;
    static readonly aes256KeyWrap: string;
    static readonly rsaV15KeyWrap: string;
    static readonly ripemd160Digest: string;
    static readonly rsaOaepKeyWrap: string;
    static readonly aes128KW: string;
    static readonly aes192KW: string;
    static readonly aes256KW: string;
    static readonly rsaPKCS1: string;
    static readonly rsaOAEP: string;
    static readonly exclusiveC14n: string;
    static readonly exclusiveC14nWithComments: string;
    static readonly envelopedSignature: string;
    static readonly sha256Digest: string;
    static readonly sha384Digest: string;
    static readonly sha512Digest: string;
    static readonly sha256: string;
    static readonly sha384: string;
    static readonly sha512: string;
    static readonly ecdsaSha256Signature: string;
    static readonly ecdsaSha384Signature: string;
    static readonly ecdsaSha512Signature: string;
    static readonly hmacSha256Signature: string;
    static readonly hmacSha384Signature: string;
    static readonly hmacSha512Signature: string;
    static readonly rsaSha256Signature: string;
    static readonly rsaSha384Signature: string;
    static readonly rsaSha512Signature: string;
    static readonly rsaSsaPssSha256Signature: string;
    static readonly rsaSsaPssSha384Signature: string;
    static readonly rsaSsaPssSha512Signature: string;
    static readonly ecdsaSha256: string;
    static readonly ecdsaSha384: string;
    static readonly ecdsaSha512: string;
    static readonly hmacSha256: string;
    static readonly hmacSha384: string;
    static readonly hmacSha512: string;
    static readonly none: string;
    static readonly rsaSha256: string;
    static readonly rsaSha384: string;
    static readonly rsaSha512: string;
    static readonly rsaSsaPssSha256: string;
    static readonly rsaSsaPssSha384: string;
    static readonly rsaSsaPssSha512: string;
    static readonly aes128CbcHmacSha256: string;
    static readonly aes192CbcHmacSha384: string;
    static readonly aes256CbcHmacSha512: string;
    static readonly aes128Gcm: string;
    static readonly aes192Gcm: string;
    static readonly aes256Gcm: string;
    static readonly ecdhEsA128kw: string;
    static readonly ecdhEsA192kw: string;
    static readonly ecdhEsA256kw: string;
    static readonly ecdhEs: string;
}


export type SecurityAlgorithms = SecurityAlgorithms$instance;

export abstract class UniqueId$instance {
    static createRandomId(): string;
    static createRandomId(prefix: string): string;
    static createRandomUri(): Uri;
    static createUniqueId(): string;
    static createUniqueId(prefix: string): string;
}


export type UniqueId = UniqueId$instance;

export abstract class Utility$instance {
    static readonly empty: string;
    static readonly null: string;
    static areEqual(a: byte[], b: byte[]): boolean;
    static cloneByteArray(src: byte[]): byte[];
    static isHttps(address: string): boolean;
    static isHttps(uri: Uri): boolean;
}


export type Utility = Utility$instance;

export abstract class Validators$instance {
    static validateAlgorithm(algorithm: string, securityKey: SecurityKey, securityToken: SecurityToken, validationParameters: TokenValidationParameters): void;
    static validateAudience(audiences: IEnumerable<System_Internal.String>, securityToken: SecurityToken, validationParameters: TokenValidationParameters): void;
    static validateIssuer(issuer: string, securityToken: SecurityToken, validationParameters: TokenValidationParameters): string;
    static validateIssuerSecurityKey(securityKey: SecurityKey, securityToken: SecurityToken, validationParameters: TokenValidationParameters): void;
    static validateLifetime(notBefore: Nullable<DateTime>, expires: Nullable<DateTime>, securityToken: SecurityToken, validationParameters: TokenValidationParameters): void;
    static validateTokenReplay(expirationTime: Nullable<DateTime>, securityToken: string, validationParameters: TokenValidationParameters): void;
    static validateTokenReplay(securityToken: string, expirationTime: Nullable<DateTime>, validationParameters: TokenValidationParameters): void;
    static validateTokenType(type: string, securityToken: SecurityToken, validationParameters: TokenValidationParameters): string;
}


export type Validators = Validators$instance;


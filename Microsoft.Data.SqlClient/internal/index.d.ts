// Generated by tsbindgen - Architecture
// Namespace: Microsoft.Data.SqlClient
// Assembly: Microsoft.Data.SqlClient

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { SqlNotificationRequest } from "../../Microsoft.Data.Sql/internal/index.js";
import type { SensitivityClassification } from "../../Microsoft.Data.SqlClient.DataClassification/internal/index.js";
import type { SqlJson, SqlVector_1 } from "../../Microsoft.Data.SqlTypes/internal/index.js";
import type { DeviceCodeResult } from "../../Microsoft.Identity.Client/internal/index.js";
import * as System_Collections_Generic_Internal from "@tsonic/dotnet/System.Collections.Generic.js";
import type { ICollection as ICollection__System_Collections_Generic, IDictionary as IDictionary__System_Collections_Generic, IEnumerable as IEnumerable__System_Collections_Generic, IEnumerator as IEnumerator__System_Collections_Generic, IList as IList__System_Collections_Generic, List } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Collections_Internal from "@tsonic/dotnet/System.Collections.js";
import type { CollectionBase, ICollection, IDictionary, IEnumerable, IEnumerator, IList } from "@tsonic/dotnet/System.Collections.js";
import type { ReadOnlyCollection } from "@tsonic/dotnet/System.Collections.ObjectModel.js";
import * as System_ComponentModel_Internal from "@tsonic/dotnet/System.ComponentModel.js";
import type { IComponent, ICustomTypeDescriptor } from "@tsonic/dotnet/System.ComponentModel.js";
import * as System_Data_Common_Internal from "@tsonic/dotnet/System.Data.Common.js";
import type { CatalogLocation, DataTableMapping, DbBatch, DbBatchCommand, DbBatchCommandCollection, DbColumn, DbCommand, DbCommandBuilder, DbConnection, DbConnectionStringBuilder, DbDataAdapter, DbDataReader, DbDataSourceEnumerator, DbException, DbParameter, DbParameterCollection, DbProviderFactory, DbTransaction, IDbColumnSchemaGenerator, RowUpdatedEventArgs, RowUpdatingEventArgs } from "@tsonic/dotnet/System.Data.Common.js";
import * as System_Data_Internal from "@tsonic/dotnet/System.Data.js";
import type { CommandBehavior, CommandType, ConnectionState, DataRow, DataRowState, DataRowVersion, DataTable, DbType, IDataAdapter, IDataParameter, IDataParameterCollection, IDataReader, IDataRecord, IDbCommand, IDbConnection, IDbDataAdapter, IDbDataParameter, IDbTransaction, IsolationLevel, ParameterDirection, SqlDbType, StatementCompletedEventHandler, StatementType, UpdateRowSource } from "@tsonic/dotnet/System.Data.js";
import type { SqlBinary, SqlBoolean, SqlByte, SqlBytes, SqlChars, SqlCompareOptions, SqlDateTime, SqlDecimal, SqlDouble, SqlGuid, SqlInt16, SqlInt32, SqlInt64, SqlMoney, SqlSingle, SqlString, SqlXml } from "@tsonic/dotnet/System.Data.SqlTypes.js";
import type { Stream, TextReader } from "@tsonic/dotnet/System.IO.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Array as ClrArray, AsyncCallback, Boolean as ClrBoolean, Byte, Char, DateTime, DateTimeOffset, Decimal, Double, Enum, EventArgs, EventHandler, Exception, Func, Guid, IAsyncDisposable, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, MulticastDelegate, Nullable, Object as ClrObject, Predicate, Single, String as ClrString, TimeSpan, Type, Uri, ValueType, Void } from "@tsonic/dotnet/System.js";
import * as System_Runtime_Serialization_Internal from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { SecureString } from "@tsonic/dotnet/System.Security.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading.js";
import type { Task } from "@tsonic/dotnet/System.Threading.Tasks.js";
import type { XmlReader } from "@tsonic/dotnet/System.Xml.js";

export enum ApplicationIntent {
    readWrite = 0,
    readOnly = 1
}


export enum PoolBlockingPeriod {
    auto = 0,
    alwaysBlock = 1,
    neverBlock = 2
}


export enum SortOrder {
    unspecified = -1,
    ascending = 0,
    descending = 1
}


export enum SqlAuthenticationMethod {
    notSpecified = 0,
    sqlPassword = 1,
    activeDirectoryPassword = 2,
    activeDirectoryIntegrated = 3,
    activeDirectoryInteractive = 4,
    activeDirectoryServicePrincipal = 5,
    activeDirectoryDeviceCodeFlow = 6,
    activeDirectoryManagedIdentity = 7,
    activeDirectoryMSI = 8,
    activeDirectoryDefault = 9,
    activeDirectoryWorkloadIdentity = 10
}


export enum SqlBulkCopyOptions {
    default = 0,
    keepIdentity = 1,
    checkConstraints = 2,
    tableLock = 4,
    keepNulls = 8,
    fireTriggers = 16,
    useInternalTransaction = 32,
    allowEncryptedValueModifications = 64
}


export enum SqlCommandColumnEncryptionSetting {
    useConnectionSetting = 0,
    enabled = 1,
    resultSetOnly = 2,
    disabled = 3
}


export enum SqlConnectionAttestationProtocol {
    notSpecified = 0,
    AAS = 1,
    none = 2,
    HGS = 3
}


export enum SqlConnectionColumnEncryptionSetting {
    disabled = 0,
    enabled = 1
}


export enum SqlConnectionIPAddressPreference {
    iPv4First = 0,
    iPv6First = 1,
    usePlatformDefault = 2
}


export enum SqlConnectionOverrides {
    none = 0,
    openWithoutRetry = 1
}


export enum SqlNotificationInfo {
    alreadyChanged = -2,
    unknown = -1,
    truncate = 0,
    insert = 1,
    update = 2,
    delete = 3,
    drop = 4,
    alter = 5,
    restart = 6,
    error = 7,
    query = 8,
    invalid = 9,
    options = 10,
    isolation = 11,
    expired = 12,
    resource = 13,
    previousFire = 14,
    templateLimit = 15,
    merge = 16
}


export enum SqlNotificationSource {
    client = -2,
    unknown = -1,
    data = 0,
    timeout = 1,
    object = 2,
    database = 3,
    system = 4,
    statement = 5,
    environment = 6,
    execution = 7,
    owner = 8
}


export enum SqlNotificationType {
    unknown = -1,
    change = 0,
    subscribe = 1
}


export type OnChangeEventHandler = (sender: unknown, e: SqlNotificationEventArgs) => void;


export type SqlInfoMessageEventHandler = (sender: unknown, e: SqlInfoMessageEventArgs) => void;


export type SqlRowsCopiedEventHandler = (sender: unknown, e: SqlRowsCopiedEventArgs) => void;


export type SqlRowUpdatedEventHandler = (sender: unknown, e: SqlRowUpdatedEventArgs) => void;


export type SqlRowUpdatingEventHandler = (sender: unknown, e: SqlRowUpdatingEventArgs) => void;


export interface ActiveDirectoryAuthenticationProvider$instance extends SqlAuthenticationProvider {
    acquireTokenAsync(parameters: SqlAuthenticationParameters): Task<SqlAuthenticationToken>;
    beforeLoad(authentication: SqlAuthenticationMethod): void;
    beforeUnload(authentication: SqlAuthenticationMethod): void;
    isSupported(authentication: SqlAuthenticationMethod): boolean;
    setAcquireAuthorizationCodeAsyncCallback(acquireAuthorizationCodeAsyncCallback: Func<Uri, Uri, CancellationToken, Task<Uri>>): void;
    setDeviceCodeFlowCallback(deviceCodeFlowCallbackMethod: Func<DeviceCodeResult, Task>): void;
}


export const ActiveDirectoryAuthenticationProvider: {
    new(): ActiveDirectoryAuthenticationProvider;
    new(deviceCodeFlowCallbackMethod: Func<DeviceCodeResult, Task>, applicationClientId: string): ActiveDirectoryAuthenticationProvider;
    new(applicationClientId: string): ActiveDirectoryAuthenticationProvider;
    clearUserTokenCache(): void;
};


export type ActiveDirectoryAuthenticationProvider = ActiveDirectoryAuthenticationProvider$instance;

export interface SqlAuthenticationInitializer$instance {
    initialize(): void;
}


export const SqlAuthenticationInitializer: {
};


export type SqlAuthenticationInitializer = SqlAuthenticationInitializer$instance;

export interface SqlAuthenticationParameters$instance {
    readonly authenticationMethod: SqlAuthenticationMethod;
    readonly authority: string;
    readonly connectionId: Guid;
    readonly connectionTimeout: int;
    readonly databaseName: string;
    readonly password: string;
    readonly resource: string;
    readonly serverName: string;
    readonly userId: string;
}


export const SqlAuthenticationParameters: {
    new(): SqlAuthenticationParameters;
};


export type SqlAuthenticationParameters = SqlAuthenticationParameters$instance;

export interface SqlAuthenticationProvider$instance {
    acquireTokenAsync(parameters: SqlAuthenticationParameters): Task<SqlAuthenticationToken>;
    beforeLoad(authenticationMethod: SqlAuthenticationMethod): void;
    beforeUnload(authenticationMethod: SqlAuthenticationMethod): void;
    isSupported(authenticationMethod: SqlAuthenticationMethod): boolean;
}


export const SqlAuthenticationProvider: {
    getProvider(authenticationMethod: SqlAuthenticationMethod): SqlAuthenticationProvider;
    setProvider(authenticationMethod: SqlAuthenticationMethod, provider: SqlAuthenticationProvider): boolean;
};


export type SqlAuthenticationProvider = SqlAuthenticationProvider$instance;

export interface SqlAuthenticationToken$instance {
    readonly accessToken: string;
    readonly expiresOn: DateTimeOffset;
}


export const SqlAuthenticationToken: {
    new(accessToken: string, expiresOn: DateTimeOffset): SqlAuthenticationToken;
};


export type SqlAuthenticationToken = SqlAuthenticationToken$instance;

export interface SqlBatch$instance extends DbBatch {
    readonly batchCommands: SqlBatchCommandCollection;
    readonly commands: List<SqlBatchCommand>;
    connection: SqlConnection;
    timeout: int;
    transaction: SqlTransaction;
    cancel(): void;
    dispose(): void;
    executeNonQuery(): int;
    executeNonQueryAsync(cancellationToken?: CancellationToken): Task<System_Internal.Int32>;
    executeReader(): SqlDataReader;
    executeReaderAsync(cancellationToken?: CancellationToken): Task<SqlDataReader>;
    executeScalar(): unknown;
    executeScalarAsync(cancellationToken?: CancellationToken): Task<unknown>;
    prepare(): void;
    prepareAsync(cancellationToken?: CancellationToken): Task;
}


export const SqlBatch: {
    new(): SqlBatch;
    new(connection: SqlConnection, transaction: SqlTransaction): SqlBatch;
};


export type SqlBatch = SqlBatch$instance;

export interface SqlBatchCommand$instance extends DbBatchCommand {
    columnEncryptionSetting: SqlCommandColumnEncryptionSetting;
    commandBehavior: CommandBehavior;
    commandText: string;
    commandType: CommandType;
    readonly parameters: SqlParameterCollection;
    readonly recordsAffected: int;
}


export const SqlBatchCommand: {
    new(): SqlBatchCommand;
    new(commandText: string, commandType: CommandType, parameters: IEnumerable__System_Collections_Generic<SqlParameter>, columnEncryptionSetting: SqlCommandColumnEncryptionSetting): SqlBatchCommand;
};


export type SqlBatchCommand = SqlBatchCommand$instance;

export interface SqlBatchCommandCollection$instance extends DbBatchCommandCollection {
    readonly count: int;
    readonly isReadOnly: boolean;
    item: SqlBatchCommand;
    add(item: SqlBatchCommand): void;
    add(item: DbBatchCommand): void;
    clear(): void;
    contains(item: SqlBatchCommand): boolean;
    contains(item: DbBatchCommand): boolean;
    copyTo(array: SqlBatchCommand[], arrayIndex: int): void;
    copyTo(array: DbBatchCommand[], arrayIndex: int): void;
    getEnumerator(): IEnumerator__System_Collections_Generic<DbBatchCommand>;
    indexOf(item: SqlBatchCommand): int;
    indexOf(item: DbBatchCommand): int;
    insert(index: int, item: SqlBatchCommand): void;
    insert(index: int, item: DbBatchCommand): void;
    remove(item: SqlBatchCommand): boolean;
    remove(item: DbBatchCommand): boolean;
    removeAt(index: int): void;
}


export const SqlBatchCommandCollection: {
    new(): SqlBatchCommandCollection;
};


export type SqlBatchCommandCollection = SqlBatchCommandCollection$instance;

export interface SqlBulkCopy$instance {
    batchSize: int;
    bulkCopyTimeout: int;
    readonly columnMappings: SqlBulkCopyColumnMappingCollection;
    readonly columnOrderHints: SqlBulkCopyColumnOrderHintCollection;
    destinationTableName: string;
    enableStreaming: boolean;
    notifyAfter: int;
    readonly rowsCopied: int;
    readonly rowsCopied64: long;
    close(): void;
    writeToServer(reader: DbDataReader): void;
    writeToServer(rows: DataRow[]): void;
    writeToServer(table: DataTable): void;
    writeToServer(table: DataTable, rowState: DataRowState): void;
    writeToServer(reader: IDataReader): void;
    writeToServerAsync(reader: DbDataReader): Task;
    writeToServerAsync(reader: DbDataReader, cancellationToken: CancellationToken): Task;
    writeToServerAsync(rows: DataRow[]): Task;
    writeToServerAsync(rows: DataRow[], cancellationToken: CancellationToken): Task;
    writeToServerAsync(table: DataTable): Task;
    writeToServerAsync(table: DataTable, rowState: DataRowState): Task;
    writeToServerAsync(table: DataTable, rowState: DataRowState, cancellationToken: CancellationToken): Task;
    writeToServerAsync(table: DataTable, cancellationToken: CancellationToken): Task;
    writeToServerAsync(reader: IDataReader): Task;
    writeToServerAsync(reader: IDataReader, cancellationToken: CancellationToken): Task;
}


export const SqlBulkCopy: {
    new(connection: SqlConnection): SqlBulkCopy;
    new(connection: SqlConnection, copyOptions: SqlBulkCopyOptions, externalTransaction: SqlTransaction): SqlBulkCopy;
    new(connectionString: string): SqlBulkCopy;
    new(connectionString: string, copyOptions: SqlBulkCopyOptions): SqlBulkCopy;
};


export type SqlBulkCopy = SqlBulkCopy$instance;

export interface SqlBulkCopyColumnMapping$instance {
    destinationColumn: string;
    destinationOrdinal: int;
    sourceColumn: string;
    sourceOrdinal: int;
}


export const SqlBulkCopyColumnMapping: {
    new(): SqlBulkCopyColumnMapping;
    new(sourceColumnOrdinal: int, destinationOrdinal: int): SqlBulkCopyColumnMapping;
    new(sourceColumnOrdinal: int, destinationColumn: string): SqlBulkCopyColumnMapping;
    new(sourceColumn: string, destinationOrdinal: int): SqlBulkCopyColumnMapping;
    new(sourceColumn: string, destinationColumn: string): SqlBulkCopyColumnMapping;
};


export type SqlBulkCopyColumnMapping = SqlBulkCopyColumnMapping$instance;

export interface SqlBulkCopyColumnMappingCollection$instance extends CollectionBase {
    readonly item: SqlBulkCopyColumnMapping;
    add(bulkCopyColumnMapping: SqlBulkCopyColumnMapping): SqlBulkCopyColumnMapping;
    add(sourceColumnIndex: int, destinationColumnIndex: int): SqlBulkCopyColumnMapping;
    add(sourceColumnIndex: int, destinationColumn: string): SqlBulkCopyColumnMapping;
    add(sourceColumn: string, destinationColumnIndex: int): SqlBulkCopyColumnMapping;
    add(sourceColumn: string, destinationColumn: string): SqlBulkCopyColumnMapping;
    clear(): void;
    contains(value: SqlBulkCopyColumnMapping): boolean;
    copyTo(array: SqlBulkCopyColumnMapping[], index: int): void;
    indexOf(value: SqlBulkCopyColumnMapping): int;
    insert(index: int, value: SqlBulkCopyColumnMapping): void;
    remove(value: SqlBulkCopyColumnMapping): void;
    removeAt(index: int): void;
}


export const SqlBulkCopyColumnMappingCollection: {
    new(): SqlBulkCopyColumnMappingCollection;
};


export type SqlBulkCopyColumnMappingCollection = SqlBulkCopyColumnMappingCollection$instance;

export interface SqlBulkCopyColumnOrderHint$instance {
    column: string;
    sortOrder: SortOrder;
}


export const SqlBulkCopyColumnOrderHint: {
    new(column: string, sortOrder: SortOrder): SqlBulkCopyColumnOrderHint;
};


export type SqlBulkCopyColumnOrderHint = SqlBulkCopyColumnOrderHint$instance;

export interface SqlBulkCopyColumnOrderHintCollection$instance extends CollectionBase {
    readonly item: SqlBulkCopyColumnOrderHint;
    add(columnOrderHint: SqlBulkCopyColumnOrderHint): SqlBulkCopyColumnOrderHint;
    add(column: string, sortOrder: SortOrder): SqlBulkCopyColumnOrderHint;
    clear(): void;
    contains(value: SqlBulkCopyColumnOrderHint): boolean;
    copyTo(array: SqlBulkCopyColumnOrderHint[], index: int): void;
    indexOf(value: SqlBulkCopyColumnOrderHint): int;
    insert(index: int, columnOrderHint: SqlBulkCopyColumnOrderHint): void;
    remove(columnOrderHint: SqlBulkCopyColumnOrderHint): void;
    removeAt(index: int): void;
}


export const SqlBulkCopyColumnOrderHintCollection: {
    new(): SqlBulkCopyColumnOrderHintCollection;
};


export type SqlBulkCopyColumnOrderHintCollection = SqlBulkCopyColumnOrderHintCollection$instance;

export interface SqlClientFactory$instance extends DbProviderFactory {
    readonly canCreateBatch: boolean;
    createBatch(): DbBatch;
    createBatchCommand(): DbBatchCommand;
    createCommand(): DbCommand;
    createCommandBuilder(): DbCommandBuilder;
    createConnection(): DbConnection;
    createConnectionStringBuilder(): DbConnectionStringBuilder;
    createDataAdapter(): DbDataAdapter;
    createDataSourceEnumerator(): DbDataSourceEnumerator;
    createParameter(): DbParameter;
}


export const SqlClientFactory: {
    new(): SqlClientFactory;
    readonly instance: SqlClientFactory;
};


export type SqlClientFactory = SqlClientFactory$instance;

export interface SqlClientLogger$instance {
    readonly isLoggingEnabled: boolean;
    logAssert(value: boolean, type: string, method: string, message: string): boolean;
    logError(type: string, method: string, message: string): void;
    logInfo(type: string, method: string, message: string): void;
    logWarning(type: string, method: string, message: string): void;
}


export const SqlClientLogger: {
    new(): SqlClientLogger;
};


export type SqlClientLogger = SqlClientLogger$instance;

export interface SqlColumnEncryptionCertificateStoreProvider$instance extends SqlColumnEncryptionKeyStoreProvider {
    decryptColumnEncryptionKey(masterKeyPath: string, encryptionAlgorithm: string, encryptedColumnEncryptionKey: byte[]): byte[];
    encryptColumnEncryptionKey(masterKeyPath: string, encryptionAlgorithm: string, columnEncryptionKey: byte[]): byte[];
    signColumnMasterKeyMetadata(masterKeyPath: string, allowEnclaveComputations: boolean): byte[];
    verifyColumnMasterKeyMetadata(masterKeyPath: string, allowEnclaveComputations: boolean, signature: byte[]): boolean;
}


export const SqlColumnEncryptionCertificateStoreProvider: {
    new(): SqlColumnEncryptionCertificateStoreProvider;
    readonly providerName: string;
};


export type SqlColumnEncryptionCertificateStoreProvider = SqlColumnEncryptionCertificateStoreProvider$instance;

export interface SqlColumnEncryptionCngProvider$instance extends SqlColumnEncryptionKeyStoreProvider {
    decryptColumnEncryptionKey(masterKeyPath: string, encryptionAlgorithm: string, encryptedColumnEncryptionKey: byte[]): byte[];
    encryptColumnEncryptionKey(masterKeyPath: string, encryptionAlgorithm: string, columnEncryptionKey: byte[]): byte[];
    signColumnMasterKeyMetadata(masterKeyPath: string, allowEnclaveComputations: boolean): byte[];
    verifyColumnMasterKeyMetadata(masterKeyPath: string, allowEnclaveComputations: boolean, signature: byte[]): boolean;
}


export const SqlColumnEncryptionCngProvider: {
    new(): SqlColumnEncryptionCngProvider;
    readonly providerName: string;
};


export type SqlColumnEncryptionCngProvider = SqlColumnEncryptionCngProvider$instance;

export interface SqlColumnEncryptionCspProvider$instance extends SqlColumnEncryptionKeyStoreProvider {
    decryptColumnEncryptionKey(masterKeyPath: string, encryptionAlgorithm: string, encryptedColumnEncryptionKey: byte[]): byte[];
    encryptColumnEncryptionKey(masterKeyPath: string, encryptionAlgorithm: string, columnEncryptionKey: byte[]): byte[];
    signColumnMasterKeyMetadata(masterKeyPath: string, allowEnclaveComputations: boolean): byte[];
    verifyColumnMasterKeyMetadata(masterKeyPath: string, allowEnclaveComputations: boolean, signature: byte[]): boolean;
}


export const SqlColumnEncryptionCspProvider: {
    new(): SqlColumnEncryptionCspProvider;
    readonly providerName: string;
};


export type SqlColumnEncryptionCspProvider = SqlColumnEncryptionCspProvider$instance;

export interface SqlColumnEncryptionKeyStoreProvider$instance {
    columnEncryptionKeyCacheTtl: Nullable<TimeSpan>;
    decryptColumnEncryptionKey(masterKeyPath: string, encryptionAlgorithm: string, encryptedColumnEncryptionKey: byte[]): byte[];
    encryptColumnEncryptionKey(masterKeyPath: string, encryptionAlgorithm: string, columnEncryptionKey: byte[]): byte[];
    signColumnMasterKeyMetadata(masterKeyPath: string, allowEnclaveComputations: boolean): byte[];
    verifyColumnMasterKeyMetadata(masterKeyPath: string, allowEnclaveComputations: boolean, signature: byte[]): boolean;
}


export const SqlColumnEncryptionKeyStoreProvider: {
};


export type SqlColumnEncryptionKeyStoreProvider = SqlColumnEncryptionKeyStoreProvider$instance;

export interface SqlCommand$instance extends DbCommand {
    readonly columnEncryptionSetting: SqlCommandColumnEncryptionSetting;
    commandText: string;
    commandTimeout: int;
    commandType: CommandType;
    connection: SqlConnection;
    designTimeVisible: boolean;
    enableOptimizedParameterBinding: boolean;
    notification: SqlNotificationRequest;
    readonly parameters: SqlParameterCollection;
    retryLogicProvider: SqlRetryLogicBaseProvider;
    transaction: SqlTransaction;
    updatedRowSource: UpdateRowSource;
    beginExecuteNonQuery(): IAsyncResult;
    beginExecuteNonQuery(callback: AsyncCallback, stateObject: unknown): IAsyncResult;
    beginExecuteReader(): IAsyncResult;
    beginExecuteReader(callback: AsyncCallback, stateObject: unknown): IAsyncResult;
    beginExecuteReader(callback: AsyncCallback, stateObject: unknown, behavior: CommandBehavior): IAsyncResult;
    beginExecuteReader(behavior: CommandBehavior): IAsyncResult;
    beginExecuteXmlReader(): IAsyncResult;
    beginExecuteXmlReader(callback: AsyncCallback, stateObject: unknown): IAsyncResult;
    cancel(): void;
    clone(): SqlCommand;
    createParameter(): SqlParameter;
    endExecuteNonQuery(asyncResult: IAsyncResult): int;
    endExecuteReader(asyncResult: IAsyncResult): SqlDataReader;
    endExecuteXmlReader(asyncResult: IAsyncResult): XmlReader;
    executeNonQuery(): int;
    executeNonQueryAsync(cancellationToken: CancellationToken): Task<System_Internal.Int32>;
    executeReader(): SqlDataReader;
    executeReader(behavior: CommandBehavior): SqlDataReader;
    executeReaderAsync(): Task<SqlDataReader>;
    executeReaderAsync(behavior: CommandBehavior): Task<SqlDataReader>;
    executeReaderAsync(behavior: CommandBehavior, cancellationToken: CancellationToken): Task<SqlDataReader>;
    executeReaderAsync(cancellationToken: CancellationToken): Task<SqlDataReader>;
    executeScalar(): unknown;
    executeScalarAsync(cancellationToken: CancellationToken): Task<unknown>;
    executeXmlReader(): XmlReader;
    executeXmlReaderAsync(): Task<XmlReader>;
    executeXmlReaderAsync(cancellationToken: CancellationToken): Task<XmlReader>;
    prepare(): void;
    registerColumnEncryptionKeyStoreProvidersOnCommand(customProviders: IDictionary__System_Collections_Generic<System_Internal.String, SqlColumnEncryptionKeyStoreProvider>): void;
    resetCommandTimeout(): void;
}


export const SqlCommand: {
    new(): SqlCommand;
    new(cmdText: string): SqlCommand;
    new(cmdText: string, connection: SqlConnection): SqlCommand;
    new(cmdText: string, connection: SqlConnection, transaction: SqlTransaction): SqlCommand;
    new(cmdText: string, connection: SqlConnection, transaction: SqlTransaction, columnEncryptionSetting: SqlCommandColumnEncryptionSetting): SqlCommand;
};


export type SqlCommand = SqlCommand$instance;

export interface SqlCommandBuilder$instance extends DbCommandBuilder {
    catalogLocation: CatalogLocation;
    catalogSeparator: string;
    dataAdapter: SqlDataAdapter;
    quotePrefix: string;
    quoteSuffix: string;
    schemaSeparator: string;
    getDeleteCommand(): SqlCommand;
    getDeleteCommand(useColumnsForParameterNames: boolean): SqlCommand;
    getInsertCommand(): SqlCommand;
    getInsertCommand(useColumnsForParameterNames: boolean): SqlCommand;
    getUpdateCommand(): SqlCommand;
    getUpdateCommand(useColumnsForParameterNames: boolean): SqlCommand;
    quoteIdentifier(unquotedIdentifier: string): string;
    unquoteIdentifier(quotedIdentifier: string): string;
}


export const SqlCommandBuilder: {
    new(): SqlCommandBuilder;
    new(adapter: SqlDataAdapter): SqlCommandBuilder;
    deriveParameters(command: SqlCommand): void;
};


export type SqlCommandBuilder = SqlCommandBuilder$instance;

export interface SqlConfigurableRetryFactory$instance {
}


export const SqlConfigurableRetryFactory: {
    new(): SqlConfigurableRetryFactory;
    createExponentialRetryProvider(retryLogicOption: SqlRetryLogicOption): SqlRetryLogicBaseProvider;
    createFixedRetryProvider(retryLogicOption: SqlRetryLogicOption): SqlRetryLogicBaseProvider;
    createIncrementalRetryProvider(retryLogicOption: SqlRetryLogicOption): SqlRetryLogicBaseProvider;
    createNoneRetryProvider(): SqlRetryLogicBaseProvider;
};


export type SqlConfigurableRetryFactory = SqlConfigurableRetryFactory$instance;

export interface SqlConnection$instance extends DbConnection {
    accessToken: string;
    accessTokenCallback: Func<SqlAuthenticationParameters, CancellationToken, Task<SqlAuthenticationToken>>;
    readonly canCreateBatch: boolean;
    readonly clientConnectionId: Guid;
    readonly commandTimeout: int;
    get connectionString(): string | undefined;
    set connectionString(value: string);
    readonly connectionTimeout: int;
    credential: SqlCredential;
    readonly database: string;
    readonly dataSource: string;
    fireInfoMessageEventOnUserErrors: boolean;
    readonly packetSize: int;
    retryLogicProvider: SqlRetryLogicBaseProvider;
    readonly serverProcessId: int;
    readonly serverVersion: string;
    readonly state: ConnectionState;
    statisticsEnabled: boolean;
    readonly workstationId: string;
    beginTransaction(): SqlTransaction;
    beginTransaction(iso: IsolationLevel): SqlTransaction;
    beginTransaction(iso: IsolationLevel, transactionName: string): SqlTransaction;
    beginTransaction(transactionName: string): SqlTransaction;
    changeDatabase(database: string): void;
    close(): void;
    createCommand(): SqlCommand;
    getSchema(): DataTable;
    getSchema(collectionName: string): DataTable;
    getSchema(collectionName: string, restrictionValues: string[]): DataTable;
    open(): void;
    open(overrides: SqlConnectionOverrides): void;
    openAsync(overrides: SqlConnectionOverrides, cancellationToken: CancellationToken): Task;
    openAsync(cancellationToken: CancellationToken): Task;
    registerColumnEncryptionKeyStoreProvidersOnConnection(customProviders: IDictionary__System_Collections_Generic<System_Internal.String, SqlColumnEncryptionKeyStoreProvider>): void;
    resetStatistics(): void;
    retrieveInternalInfo(): IDictionary__System_Collections_Generic<System_Internal.String, unknown>;
    retrieveStatistics(): IDictionary;
}


export const SqlConnection: {
    new(): SqlConnection;
    new(connectionString: string): SqlConnection;
    new(connectionString: string, credential: SqlCredential): SqlConnection;
    columnEncryptionKeyCacheTtl: TimeSpan;
    columnEncryptionQueryMetadataCacheEnabled: boolean;
    readonly columnEncryptionTrustedMasterKeyPaths: IDictionary__System_Collections_Generic<System_Internal.String, IList__System_Collections_Generic<System_Internal.String>>;
    changePassword(connectionString: string, credential: SqlCredential, newSecurePassword: SecureString): void;
    changePassword(connectionString: string, newPassword: string): void;
    clearAllPools(): void;
    clearPool(connection: SqlConnection): void;
    registerColumnEncryptionKeyStoreProviders(customProviders: IDictionary__System_Collections_Generic<System_Internal.String, SqlColumnEncryptionKeyStoreProvider>): void;
};


export type SqlConnection = SqlConnection$instance;

export interface SqlConnectionEncryptOption$instance {
    equals(obj: unknown): boolean;
    getHashCode(): int;
    toString(): string | undefined;
}


export const SqlConnectionEncryptOption: {
    new(): SqlConnectionEncryptOption;
    readonly mandatory: SqlConnectionEncryptOption;
    readonly optional: SqlConnectionEncryptOption;
    readonly strict: SqlConnectionEncryptOption;
    parse(value: string): SqlConnectionEncryptOption;
    tryParse(value: string, result: SqlConnectionEncryptOption): boolean;
};


export type SqlConnectionEncryptOption = SqlConnectionEncryptOption$instance;

export interface SqlConnectionStringBuilder$instance extends DbConnectionStringBuilder {
    applicationIntent: ApplicationIntent;
    applicationName: string;
    attachDBFilename: string;
    attestationProtocol: SqlConnectionAttestationProtocol;
    authentication: SqlAuthenticationMethod;
    columnEncryptionSetting: SqlConnectionColumnEncryptionSetting;
    commandTimeout: int;
    connectRetryCount: int;
    connectRetryInterval: int;
    connectTimeout: int;
    currentLanguage: string;
    dataSource: string;
    enclaveAttestationUrl: string;
    encrypt: SqlConnectionEncryptOption;
    enlist: boolean;
    failoverPartner: string;
    failoverPartnerSPN: string;
    hostNameInCertificate: string;
    initialCatalog: string;
    integratedSecurity: boolean;
    ipAddressPreference: SqlConnectionIPAddressPreference;
    readonly isFixedSize: boolean;
    item: unknown;
    readonly keys: ICollection;
    loadBalanceTimeout: int;
    maxPoolSize: int;
    minPoolSize: int;
    multipleActiveResultSets: boolean;
    multiSubnetFailover: boolean;
    packetSize: int;
    password: string;
    persistSecurityInfo: boolean;
    poolBlockingPeriod: PoolBlockingPeriod;
    pooling: boolean;
    replication: boolean;
    serverCertificate: string;
    serverSPN: string;
    transactionBinding: string;
    trustServerCertificate: boolean;
    typeSystemVersion: string;
    userID: string;
    userInstance: boolean;
    readonly values: ICollection;
    workstationID: string;
    clear(): void;
    containsKey(keyword: string): boolean;
    remove(keyword: string): boolean;
    shouldSerialize(keyword: string): boolean;
    tryGetValue(keyword: string, value: unknown): boolean;
}


export const SqlConnectionStringBuilder: {
    new(): SqlConnectionStringBuilder;
    new(connectionString: string): SqlConnectionStringBuilder;
};


export type SqlConnectionStringBuilder = SqlConnectionStringBuilder$instance;

export interface SqlCredential$instance {
    readonly password: SecureString;
    readonly userId: string;
}


export const SqlCredential: {
    new(userId: string, password: SecureString): SqlCredential;
};


export type SqlCredential = SqlCredential$instance;

export interface SqlDataAdapter$instance extends DbDataAdapter {
    deleteCommand: SqlCommand;
    insertCommand: SqlCommand;
    selectCommand: SqlCommand;
    updateBatchSize: int;
    updateCommand: SqlCommand;
}


export const SqlDataAdapter: {
    new(): SqlDataAdapter;
    new(selectCommand: SqlCommand): SqlDataAdapter;
    new(selectCommandText: string, selectConnection: SqlConnection): SqlDataAdapter;
    new(selectCommandText: string, selectConnectionString: string): SqlDataAdapter;
};


export type SqlDataAdapter = SqlDataAdapter$instance;

export interface SqlDataReader$instance extends DbDataReader {
    readonly depth: int;
    readonly fieldCount: int;
    readonly hasRows: boolean;
    readonly isClosed: boolean;
    readonly recordsAffected: int;
    readonly sensitivityClassification: SensitivityClassification;
    readonly visibleFieldCount: int;
    close(): void;
    get_Item(i: int): unknown;
    get_Item(name: string): unknown;
    getBoolean(i: int): boolean;
    getByte(i: int): byte;
    getBytes(i: int, dataIndex: long, buffer: byte[], bufferIndex: int, length: int): long;
    getChar(i: int): char;
    getChars(i: int, dataIndex: long, buffer: char[], bufferIndex: int, length: int): long;
    getColumnSchema(): ReadOnlyCollection<DbColumn>;
    getDataTypeName(i: int): string;
    getDateTime(i: int): DateTime;
    getDateTimeOffset(i: int): DateTimeOffset;
    getDecimal(i: int): decimal;
    getDouble(i: int): double;
    getEnumerator(): IEnumerator;
    getFieldType(i: int): Type;
    getFieldValue<T>(i: int): T;
    getFieldValueAsync<T>(i: int, cancellationToken: CancellationToken): Task<T>;
    getFloat(i: int): float;
    getGuid(i: int): Guid;
    getInt16(i: int): short;
    getInt32(i: int): int;
    getInt64(i: int): long;
    getName(i: int): string;
    getOrdinal(name: string): int;
    getProviderSpecificFieldType(i: int): Type;
    getProviderSpecificValue(i: int): unknown;
    getProviderSpecificValues(values: unknown[]): int;
    getSchemaTable(): DataTable;
    getSqlBinary(i: int): SqlBinary;
    getSqlBoolean(i: int): SqlBoolean;
    getSqlByte(i: int): SqlByte;
    getSqlBytes(i: int): SqlBytes;
    getSqlChars(i: int): SqlChars;
    getSqlDateTime(i: int): SqlDateTime;
    getSqlDecimal(i: int): SqlDecimal;
    getSqlDouble(i: int): SqlDouble;
    getSqlGuid(i: int): SqlGuid;
    getSqlInt16(i: int): SqlInt16;
    getSqlInt32(i: int): SqlInt32;
    getSqlInt64(i: int): SqlInt64;
    getSqlJson(i: int): SqlJson;
    getSqlMoney(i: int): SqlMoney;
    getSqlSingle(i: int): SqlSingle;
    getSqlString(i: int): SqlString;
    getSqlValue(i: int): unknown;
    getSqlValues(values: unknown[]): int;
    getSqlVector<T extends unknown>(i: int): SqlVector_1<T>;
    getSqlXml(i: int): SqlXml;
    getStream(i: int): Stream;
    getString(i: int): string;
    getTextReader(i: int): TextReader;
    getTimeSpan(i: int): TimeSpan;
    getValue(i: int): unknown;
    getValues(values: unknown[]): int;
    getXmlReader(i: int): XmlReader;
    isDBNull(i: int): boolean;
    isDBNullAsync(i: int, cancellationToken: CancellationToken): Task<System_Internal.Boolean>;
    nextResult(): boolean;
    nextResultAsync(cancellationToken: CancellationToken): Task<System_Internal.Boolean>;
    read(): boolean;
    readAsync(cancellationToken: CancellationToken): Task<System_Internal.Boolean>;
}


export const SqlDataReader: {
    new(): SqlDataReader;
};


export type SqlDataReader = SqlDataReader$instance;

export interface SqlDependency$instance {
    readonly hasChanges: boolean;
    readonly id: string;
    addCommandDependency(command: SqlCommand): void;
}


export const SqlDependency: {
    new(): SqlDependency;
    new(command: SqlCommand): SqlDependency;
    new(command: SqlCommand, options: string, timeout: int): SqlDependency;
    start(connectionString: string, queue: string): boolean;
    start(connectionString: string): boolean;
    stop(connectionString: string, queue: string): boolean;
    stop(connectionString: string): boolean;
};


export type SqlDependency = SqlDependency$instance;

export interface SqlError$instance {
    readonly class: byte;
    readonly lineNumber: int;
    readonly message: string | undefined;
    readonly number: int;
    readonly procedure: string;
    readonly server: string;
    readonly source: string;
    readonly state: byte;
    toString(): string | undefined;
}


export const SqlError: {
    new(): SqlError;
};


export type SqlError = SqlError$instance;

export interface SqlErrorCollection$instance {
    readonly count: int;
    readonly item: SqlError;
    copyTo(array: SqlError[], index: int): void;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator;
}


export const SqlErrorCollection: {
    new(): SqlErrorCollection;
};


export type SqlErrorCollection = SqlErrorCollection$instance;

export interface SqlException$instance extends DbException {
    readonly batchCommand: SqlBatchCommand;
    readonly class: byte;
    readonly clientConnectionId: Guid;
    readonly errors: SqlErrorCollection;
    readonly lineNumber: int;
    readonly number: int;
    readonly procedure: string;
    readonly server: string;
    readonly source: string;
    readonly state: byte;
    getObjectData(si: SerializationInfo, context: StreamingContext): void;
    toString(): string;
}


export const SqlException: {
    new(): SqlException;
};


export type SqlException = SqlException$instance;

export interface SqlInfoMessageEventArgs$instance extends EventArgs {
    readonly errors: SqlErrorCollection;
    readonly message: string;
    readonly source: string;
    toString(): string;
}


export const SqlInfoMessageEventArgs: {
    new(): SqlInfoMessageEventArgs;
};


export type SqlInfoMessageEventArgs = SqlInfoMessageEventArgs$instance;

export interface SqlNotificationEventArgs$instance extends EventArgs {
    readonly info: SqlNotificationInfo;
    readonly source: SqlNotificationSource;
    readonly type: SqlNotificationType;
}


export const SqlNotificationEventArgs: {
    new(type: SqlNotificationType, info: SqlNotificationInfo, source: SqlNotificationSource): SqlNotificationEventArgs;
};


export type SqlNotificationEventArgs = SqlNotificationEventArgs$instance;

export interface SqlParameter$instance extends DbParameter {
    compareInfo: SqlCompareOptions;
    dbType: DbType;
    direction: ParameterDirection;
    forceColumnEncryption: boolean;
    isNullable: boolean;
    localeId: int;
    offset: int;
    parameterName: string;
    precision: byte;
    scale: byte;
    size: int;
    sourceColumn: string;
    sourceColumnNullMapping: boolean;
    sourceVersion: DataRowVersion;
    sqlDbType: SqlDbType;
    sqlValue: unknown;
    typeName: string;
    udtTypeName: string;
    value: unknown;
    xmlSchemaCollectionDatabase: string;
    xmlSchemaCollectionName: string;
    xmlSchemaCollectionOwningSchema: string;
    resetDbType(): void;
    resetSqlDbType(): void;
    toString(): string;
}


export const SqlParameter: {
    new(): SqlParameter;
    new(parameterName: string, dbType: SqlDbType): SqlParameter;
    new(parameterName: string, dbType: SqlDbType, size: int): SqlParameter;
    new(parameterName: string, dbType: SqlDbType, size: int, direction: ParameterDirection, isNullable: boolean, precision: byte, scale: byte, sourceColumn: string, sourceVersion: DataRowVersion, value: unknown): SqlParameter;
    new(parameterName: string, dbType: SqlDbType, size: int, direction: ParameterDirection, precision: byte, scale: byte, sourceColumn: string, sourceVersion: DataRowVersion, sourceColumnNullMapping: boolean, value: unknown, xmlSchemaCollectionDatabase: string, xmlSchemaCollectionOwningSchema: string, xmlSchemaCollectionName: string): SqlParameter;
    new(parameterName: string, dbType: SqlDbType, size: int, sourceColumn: string): SqlParameter;
    new(parameterName: string, value: unknown): SqlParameter;
};


export type SqlParameter = SqlParameter$instance;

export interface SqlParameterCollection$instance extends DbParameterCollection {
    readonly count: int;
    readonly isFixedSize: boolean;
    readonly isReadOnly: boolean;
    readonly syncRoot: unknown;
    add(value: SqlParameter): SqlParameter;
    add(value: unknown): int;
    add(parameterName: string, sqlDbType: SqlDbType): SqlParameter;
    add(parameterName: string, sqlDbType: SqlDbType, size: int): SqlParameter;
    add(parameterName: string, sqlDbType: SqlDbType, size: int, sourceColumn: string): SqlParameter;
    addRange(values: SqlParameter[]): void;
    addRange(values: ClrArray): void;
    addWithValue(parameterName: string, value: unknown): SqlParameter;
    clear(): void;
    contains(value: SqlParameter): boolean;
    contains(value: unknown): boolean;
    contains(value: string): boolean;
    copyTo(array: SqlParameter[], index: int): void;
    copyTo(array: ClrArray, index: int): void;
    get_Item(index: int): SqlParameter;
    get_Item(parameterName: string): SqlParameter;
    getEnumerator(): IEnumerator;
    indexOf(value: SqlParameter): int;
    indexOf(value: unknown): int;
    indexOf(parameterName: string): int;
    insert(index: int, value: SqlParameter): void;
    insert(index: int, value: unknown): void;
    remove(value: SqlParameter): void;
    remove(value: unknown): void;
    removeAt(index: int): void;
    removeAt(parameterName: string): void;
    set_Item(index: int, value: SqlParameter): void;
    set_Item(parameterName: string, value: SqlParameter): void;
}


export const SqlParameterCollection: {
    new(): SqlParameterCollection;
};


export type SqlParameterCollection = SqlParameterCollection$instance;

export interface SqlRetryingEventArgs$instance extends EventArgs {
    cancel: boolean;
    readonly delay: TimeSpan;
    readonly exceptions: IList__System_Collections_Generic<Exception>;
    readonly retryCount: int;
}


export const SqlRetryingEventArgs: {
    new(retryCount: int, delay: TimeSpan, exceptions: IList__System_Collections_Generic<Exception>): SqlRetryingEventArgs;
};


export type SqlRetryingEventArgs = SqlRetryingEventArgs$instance;

export interface SqlRetryIntervalBaseEnumerator$instance {
    readonly current: TimeSpan;
    readonly gapTimeInterval: TimeSpan;
    readonly maxTimeInterval: TimeSpan;
    readonly minTimeInterval: TimeSpan;
    clone(): unknown;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export const SqlRetryIntervalBaseEnumerator: {
    new(): SqlRetryIntervalBaseEnumerator;
    new(timeInterval: TimeSpan, maxTime: TimeSpan, minTime: TimeSpan): SqlRetryIntervalBaseEnumerator;
};


export type SqlRetryIntervalBaseEnumerator = SqlRetryIntervalBaseEnumerator$instance;

export interface SqlRetryLogicBase$instance {
    readonly current: int;
    readonly numberOfTries: int;
    readonly retryIntervalEnumerator: SqlRetryIntervalBaseEnumerator;
    readonly transientPredicate: Predicate<Exception>;
    clone(): unknown;
    reset(): void;
    retryCondition(sender: unknown): boolean;
    tryNextInterval(intervalTime: TimeSpan): boolean;
}


export const SqlRetryLogicBase: {
};


export type SqlRetryLogicBase = SqlRetryLogicBase$instance;

export interface SqlRetryLogicBaseProvider$instance {
    retrying: EventHandler<SqlRetryingEventArgs>;
    readonly retryLogic: SqlRetryLogicBase;
    execute<TResult>(sender: unknown, function_: Func<TResult>): TResult;
    executeAsync(sender: unknown, function_: Func<Task>, cancellationToken?: CancellationToken): Task;
    executeAsync<TResult>(sender: unknown, function_: Func<Task<TResult>>, cancellationToken?: CancellationToken): Task<TResult>;
}


export const SqlRetryLogicBaseProvider: {
};


export type SqlRetryLogicBaseProvider = SqlRetryLogicBaseProvider$instance;

export interface SqlRetryLogicOption$instance {
    authorizedSqlCondition: Predicate<System_Internal.String>;
    deltaTime: TimeSpan;
    maxTimeInterval: TimeSpan;
    minTimeInterval: TimeSpan;
    numberOfTries: int;
    transientErrors: IEnumerable__System_Collections_Generic<System_Internal.Int32>;
}


export const SqlRetryLogicOption: {
    new(): SqlRetryLogicOption;
};


export type SqlRetryLogicOption = SqlRetryLogicOption$instance;

export interface SqlRowsCopiedEventArgs$instance extends EventArgs {
    abort: boolean;
    readonly rowsCopied: long;
}


export const SqlRowsCopiedEventArgs: {
    new(rowsCopied: long): SqlRowsCopiedEventArgs;
};


export type SqlRowsCopiedEventArgs = SqlRowsCopiedEventArgs$instance;

export interface SqlRowUpdatedEventArgs$instance extends RowUpdatedEventArgs {
    readonly command: SqlCommand;
}


export const SqlRowUpdatedEventArgs: {
    new(row: DataRow, command: IDbCommand, statementType: StatementType, tableMapping: DataTableMapping): SqlRowUpdatedEventArgs;
};


export type SqlRowUpdatedEventArgs = SqlRowUpdatedEventArgs$instance;

export interface SqlRowUpdatingEventArgs$instance extends RowUpdatingEventArgs {
    command: SqlCommand;
}


export const SqlRowUpdatingEventArgs: {
    new(row: DataRow, command: IDbCommand, statementType: StatementType, tableMapping: DataTableMapping): SqlRowUpdatingEventArgs;
};


export type SqlRowUpdatingEventArgs = SqlRowUpdatingEventArgs$instance;

export interface SqlTransaction$instance extends DbTransaction {
    readonly connection: SqlConnection;
    readonly isolationLevel: IsolationLevel;
    commit(): void;
    rollback(): void;
    rollback(transactionName: string): void;
    save(savePointName: string): void;
}


export const SqlTransaction: {
    new(): SqlTransaction;
};


export type SqlTransaction = SqlTransaction$instance;

export abstract class SqlClientMetaDataCollectionNames$instance {
    static readonly allColumns: string;
    static readonly columns: string;
    static readonly columnSetColumns: string;
    static readonly databases: string;
    static readonly foreignKeys: string;
    static readonly indexColumns: string;
    static readonly indexes: string;
    static readonly procedureParameters: string;
    static readonly procedures: string;
    static readonly structuredTypeMembers: string;
    static readonly tables: string;
    static readonly userDefinedTypes: string;
    static readonly users: string;
    static readonly viewColumns: string;
    static readonly views: string;
}


export type SqlClientMetaDataCollectionNames = SqlClientMetaDataCollectionNames$instance;


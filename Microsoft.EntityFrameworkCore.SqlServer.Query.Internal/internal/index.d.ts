// Generated by tsbindgen - Architecture
// Namespace: Microsoft.EntityFrameworkCore.SqlServer.Query.Internal
// Assembly: Microsoft.EntityFrameworkCore.SqlServer

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { ISqlServerSingletonOptions } from "../../Microsoft.EntityFrameworkCore.SqlServer.Infrastructure.Internal/internal/index.js";
import type { ISqlServerConnection } from "../../Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal/internal/index.js";
import type { IEnumerable, IReadOnlyList } from "@tsonic/dotnet/System.Collections.Generic.js";
import type { DbCommand } from "@tsonic/dotnet/System.Data.Common.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Boolean as ClrBoolean, DateTime, Enum, IComparable, IConvertible, IEquatable, IFormattable, Int32, ISpanFormattable, Object as ClrObject, String as ClrString, Type, ValueType, Void } from "@tsonic/dotnet/System.js";
import * as System_Linq_Expressions_Internal from "@tsonic/dotnet/System.Linq.Expressions.js";
import type { Expression, ExpressionVisitor } from "@tsonic/dotnet/System.Linq.Expressions.js";
import type { MemberInfo, MethodInfo } from "@tsonic/dotnet/System.Reflection.js";
import type { IDiagnosticsLogger } from "@tsonic/efcore/Microsoft.EntityFrameworkCore.Diagnostics.js";
import type { DbLoggerCategory$Query } from "@tsonic/efcore/Microsoft.EntityFrameworkCore.js";
import type { IEntityType, IModel } from "@tsonic/efcore/Microsoft.EntityFrameworkCore.Metadata.js";
import * as Microsoft_EntityFrameworkCore_Query_Internal from "@tsonic/efcore/Microsoft.EntityFrameworkCore.Query.js";
import type { CompiledQueryCacheKeyGeneratorDependencies, EntityQueryRootExpression, EnumerableExpression, EvaluatableExpressionFilterDependencies, IAggregateMethodCallTranslator, IAggregateMethodCallTranslatorProvider, IAsyncQueryProvider, ICompiledQueryCacheKeyGenerator, IEvaluatableExpressionFilter, IMemberTranslator, IMemberTranslatorProvider, IMethodCallTranslator, IMethodCallTranslatorProvider, INavigationExpansionExtensibilityHelper, IPrintableExpression, IQueryableMethodTranslatingExpressionVisitorFactory, IQueryCompilationContextFactory, IQuerySqlGeneratorFactory, IQueryTranslationPostprocessorFactory, IRelationalParameterBasedSqlProcessorFactory, IRelationalQueryStringFactory, IRelationalQuotableExpression, IRelationalSqlTranslatingExpressionVisitorFactory, ISqlExpressionFactory, NavigationExpansionExtensibilityHelper, NavigationExpansionExtensibilityHelperDependencies, ParametersCacheDecorator, PathSegment, QueryableMethodTranslatingExpressionVisitor, QueryableMethodTranslatingExpressionVisitorDependencies, QueryCompilationContext, QueryCompilationContextDependencies, QueryContext, QuerySqlGenerator, QuerySqlGeneratorDependencies, QueryTranslationPostprocessor, QueryTranslationPostprocessorDependencies, RelationalAggregateMethodCallTranslatorProvider, RelationalAggregateMethodCallTranslatorProviderDependencies, RelationalCompiledQueryCacheKeyGenerator, RelationalCompiledQueryCacheKeyGeneratorDependencies, RelationalEvaluatableExpressionFilter, RelationalEvaluatableExpressionFilterDependencies, RelationalMemberTranslatorProvider, RelationalMemberTranslatorProviderDependencies, RelationalMethodCallTranslatorProvider, RelationalMethodCallTranslatorProviderDependencies, RelationalParameterBasedSqlProcessor, RelationalParameterBasedSqlProcessorDependencies, RelationalParameterBasedSqlProcessorParameters, RelationalQueryableMethodTranslatingExpressionVisitor, RelationalQueryableMethodTranslatingExpressionVisitorDependencies, RelationalQueryCompilationContext, RelationalQueryCompilationContextDependencies, RelationalQueryTranslationPostprocessor, RelationalQueryTranslationPostprocessorDependencies, RelationalSqlTranslatingExpressionVisitor, RelationalSqlTranslatingExpressionVisitorDependencies, RelationalTypeMappingPostprocessor, SqlAliasManager, SqlExpressionFactory, SqlExpressionFactoryDependencies, SqlNullabilityProcessor, SqlTreePruner } from "@tsonic/efcore/Microsoft.EntityFrameworkCore.Query.js";
import * as Microsoft_EntityFrameworkCore_Query_SqlExpressions_Internal from "@tsonic/efcore/Microsoft.EntityFrameworkCore.Query.SqlExpressions.js";
import type { ITableBasedExpression, OrderingExpression, SqlExpression, SqlFunctionExpression, TableExpressionBase, TableValuedFunctionExpression } from "@tsonic/efcore/Microsoft.EntityFrameworkCore.Query.SqlExpressions.js";
import type { IRelationalTypeMappingSource, RelationalTypeMapping } from "@tsonic/efcore/Microsoft.EntityFrameworkCore.Storage.js";

export enum SqlServerSqlTranslatingExpressionVisitor_StartsEndsWithContains {
    startsWith = 0,
    endsWith = 1,
    contains = 2
}


export enum TemporalOperationType {
    all = 0,
    asOf = 1,
    between = 2,
    containedIn = 3,
    fromTo = 4
}


export interface SqlServerOpenJsonExpression_ColumnInfo$instance {
    asJson: boolean;
    name: string;
    get path(): IReadOnlyList<PathSegment> | undefined;
    set path(value: IReadOnlyList<PathSegment>);
    typeMapping: RelationalTypeMapping;
    deconstruct(Name: string, TypeMapping: RelationalTypeMapping, Path: IReadOnlyList<PathSegment>, AsJson: boolean): void;
    equals(obj: unknown): boolean;
    equals(other: SqlServerOpenJsonExpression_ColumnInfo): boolean;
    getHashCode(): int;
    toString(): string | undefined;
}


export const SqlServerOpenJsonExpression_ColumnInfo: {
    new(Name: string, TypeMapping: RelationalTypeMapping, Path: IReadOnlyList<PathSegment>, AsJson: boolean): SqlServerOpenJsonExpression_ColumnInfo;
};


export type SqlServerOpenJsonExpression_ColumnInfo = SqlServerOpenJsonExpression_ColumnInfo$instance;

export interface SearchConditionConverter$instance extends ExpressionVisitor {
    visit(expression: Expression): Expression | undefined;
}


export const SearchConditionConverter: {
    new(sqlExpressionFactory: ISqlExpressionFactory): SearchConditionConverter;
};


export type SearchConditionConverter = SearchConditionConverter$instance;

export interface SqlServerAggregateFunctionExpression$instance extends SqlExpression {
    readonly arguments: IReadOnlyList<SqlExpression>;
    readonly argumentsPropagateNullability: IReadOnlyList<System_Internal.Boolean>;
    readonly isNullable: boolean;
    readonly name: string;
    readonly orderings: IReadOnlyList<OrderingExpression>;
    applyTypeMapping(typeMapping: RelationalTypeMapping): SqlServerAggregateFunctionExpression;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    quote(): Expression;
    update(arguments: IReadOnlyList<SqlExpression>, orderings: IReadOnlyList<OrderingExpression>): SqlServerAggregateFunctionExpression;
}


export const SqlServerAggregateFunctionExpression: {
    new(name: string, arguments: IReadOnlyList<SqlExpression>, orderings: IReadOnlyList<OrderingExpression>, nullable: boolean, argumentsPropagateNullability: IEnumerable<System_Internal.Boolean>, type: Type, typeMapping: RelationalTypeMapping): SqlServerAggregateFunctionExpression;
};


export type SqlServerAggregateFunctionExpression = SqlServerAggregateFunctionExpression$instance;

export interface SqlServerAggregateMethodCallTranslatorProvider$instance extends RelationalAggregateMethodCallTranslatorProvider {
}


export const SqlServerAggregateMethodCallTranslatorProvider: {
    new(dependencies: RelationalAggregateMethodCallTranslatorProviderDependencies): SqlServerAggregateMethodCallTranslatorProvider;
};


export type SqlServerAggregateMethodCallTranslatorProvider = SqlServerAggregateMethodCallTranslatorProvider$instance;

export interface SqlServerAggregateOverSubqueryPostprocessor$instance extends ExpressionVisitor {
}


export const SqlServerAggregateOverSubqueryPostprocessor: {
    new(sqlAliasManager: SqlAliasManager): SqlServerAggregateOverSubqueryPostprocessor;
};


export type SqlServerAggregateOverSubqueryPostprocessor = SqlServerAggregateOverSubqueryPostprocessor$instance;

export interface SqlServerByteArrayMethodTranslator$instance {
    translate(instance: SqlExpression, method: MethodInfo, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger<DbLoggerCategory$Query>): SqlExpression | undefined;
}


export const SqlServerByteArrayMethodTranslator: {
    new(sqlExpressionFactory: ISqlExpressionFactory): SqlServerByteArrayMethodTranslator;
};


export type SqlServerByteArrayMethodTranslator = SqlServerByteArrayMethodTranslator$instance;

export interface SqlServerCompiledQueryCacheKeyGenerator$instance extends RelationalCompiledQueryCacheKeyGenerator {
    generateCacheKey(query: Expression, async: boolean): unknown;
}


export const SqlServerCompiledQueryCacheKeyGenerator: {
    new(dependencies: CompiledQueryCacheKeyGeneratorDependencies, relationalDependencies: RelationalCompiledQueryCacheKeyGeneratorDependencies, sqlServerConnection: ISqlServerConnection): SqlServerCompiledQueryCacheKeyGenerator;
};


export type SqlServerCompiledQueryCacheKeyGenerator = SqlServerCompiledQueryCacheKeyGenerator$instance;

export interface SqlServerConvertTranslator$instance {
    translate(instance: SqlExpression, method: MethodInfo, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger<DbLoggerCategory$Query>): SqlExpression | undefined;
}


export const SqlServerConvertTranslator: {
    new(sqlExpressionFactory: ISqlExpressionFactory): SqlServerConvertTranslator;
};


export type SqlServerConvertTranslator = SqlServerConvertTranslator$instance;

export interface SqlServerDataLengthFunctionTranslator$instance {
    translate(instance: SqlExpression, method: MethodInfo, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger<DbLoggerCategory$Query>): SqlExpression | undefined;
}


export const SqlServerDataLengthFunctionTranslator: {
    new(sqlExpressionFactory: ISqlExpressionFactory): SqlServerDataLengthFunctionTranslator;
};


export type SqlServerDataLengthFunctionTranslator = SqlServerDataLengthFunctionTranslator$instance;

export interface SqlServerDateDiffFunctionsTranslator$instance {
    translate(instance: SqlExpression, method: MethodInfo, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger<DbLoggerCategory$Query>): SqlExpression | undefined;
}


export const SqlServerDateDiffFunctionsTranslator: {
    new(sqlExpressionFactory: ISqlExpressionFactory): SqlServerDateDiffFunctionsTranslator;
};


export type SqlServerDateDiffFunctionsTranslator = SqlServerDateDiffFunctionsTranslator$instance;

export interface SqlServerDateOnlyMemberTranslator$instance {
    translate(instance: SqlExpression, member: MemberInfo, returnType: Type, logger: IDiagnosticsLogger<DbLoggerCategory$Query>): SqlExpression | undefined;
}


export const SqlServerDateOnlyMemberTranslator: {
    new(sqlExpressionFactory: ISqlExpressionFactory): SqlServerDateOnlyMemberTranslator;
};


export type SqlServerDateOnlyMemberTranslator = SqlServerDateOnlyMemberTranslator$instance;

export interface SqlServerDateOnlyMethodTranslator$instance {
    translate(instance: SqlExpression, method: MethodInfo, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger<DbLoggerCategory$Query>): SqlExpression | undefined;
}


export const SqlServerDateOnlyMethodTranslator: {
    new(sqlExpressionFactory: ISqlExpressionFactory): SqlServerDateOnlyMethodTranslator;
};


export type SqlServerDateOnlyMethodTranslator = SqlServerDateOnlyMethodTranslator$instance;

export interface SqlServerDateTimeMemberTranslator$instance {
    translate(instance: SqlExpression, member: MemberInfo, returnType: Type, logger: IDiagnosticsLogger<DbLoggerCategory$Query>): SqlExpression | undefined;
}


export const SqlServerDateTimeMemberTranslator: {
    new(sqlExpressionFactory: ISqlExpressionFactory, typeMappingSource: IRelationalTypeMappingSource): SqlServerDateTimeMemberTranslator;
};


export type SqlServerDateTimeMemberTranslator = SqlServerDateTimeMemberTranslator$instance;

export interface SqlServerDateTimeMethodTranslator$instance {
    translate(instance: SqlExpression, method: MethodInfo, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger<DbLoggerCategory$Query>): SqlExpression | undefined;
}


export const SqlServerDateTimeMethodTranslator: {
    new(sqlExpressionFactory: ISqlExpressionFactory, typeMappingSource: IRelationalTypeMappingSource): SqlServerDateTimeMethodTranslator;
};


export type SqlServerDateTimeMethodTranslator = SqlServerDateTimeMethodTranslator$instance;

export interface SqlServerEvaluatableExpressionFilter$instance extends RelationalEvaluatableExpressionFilter {
    isEvaluatableExpression(expression: Expression, model: IModel): boolean;
}


export const SqlServerEvaluatableExpressionFilter: {
    new(dependencies: EvaluatableExpressionFilterDependencies, relationalDependencies: RelationalEvaluatableExpressionFilterDependencies): SqlServerEvaluatableExpressionFilter;
};


export type SqlServerEvaluatableExpressionFilter = SqlServerEvaluatableExpressionFilter$instance;

export interface SqlServerFromPartsFunctionTranslator$instance {
    translate(instance: SqlExpression, method: MethodInfo, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger<DbLoggerCategory$Query>): SqlExpression | undefined;
}


export const SqlServerFromPartsFunctionTranslator: {
    new(sqlExpressionFactory: ISqlExpressionFactory, typeMappingSource: IRelationalTypeMappingSource): SqlServerFromPartsFunctionTranslator;
};


export type SqlServerFromPartsFunctionTranslator = SqlServerFromPartsFunctionTranslator$instance;

export interface SqlServerFullTextSearchFunctionsTranslator$instance {
    translate(instance: SqlExpression, method: MethodInfo, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger<DbLoggerCategory$Query>): SqlExpression | undefined;
}


export const SqlServerFullTextSearchFunctionsTranslator: {
    new(sqlExpressionFactory: ISqlExpressionFactory): SqlServerFullTextSearchFunctionsTranslator;
};


export type SqlServerFullTextSearchFunctionsTranslator = SqlServerFullTextSearchFunctionsTranslator$instance;

export interface SqlServerIsDateFunctionTranslator$instance {
    translate(instance: SqlExpression, method: MethodInfo, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger<DbLoggerCategory$Query>): SqlExpression | undefined;
}


export const SqlServerIsDateFunctionTranslator: {
    new(sqlExpressionFactory: ISqlExpressionFactory): SqlServerIsDateFunctionTranslator;
};


export type SqlServerIsDateFunctionTranslator = SqlServerIsDateFunctionTranslator$instance;

export interface SqlServerIsNumericFunctionTranslator$instance {
    translate(instance: SqlExpression, method: MethodInfo, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger<DbLoggerCategory$Query>): SqlExpression | undefined;
}


export const SqlServerIsNumericFunctionTranslator: {
    new(sqlExpressionFactory: ISqlExpressionFactory): SqlServerIsNumericFunctionTranslator;
};


export type SqlServerIsNumericFunctionTranslator = SqlServerIsNumericFunctionTranslator$instance;

export interface SqlServerJsonPostprocessor$instance extends ExpressionVisitor {
    process(expression: Expression): Expression;
    visit(expression: Expression): Expression | undefined;
}


export const SqlServerJsonPostprocessor: {
    new(typeMappingSource: IRelationalTypeMappingSource, sqlExpressionFactory: ISqlExpressionFactory, sqlAliasManager: SqlAliasManager): SqlServerJsonPostprocessor;
};


export type SqlServerJsonPostprocessor = SqlServerJsonPostprocessor$instance;

export interface SqlServerLongCountMethodTranslator$instance {
    translate(method: MethodInfo, source: EnumerableExpression, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger<DbLoggerCategory$Query>): SqlExpression | undefined;
}


export const SqlServerLongCountMethodTranslator: {
    new(sqlExpressionFactory: ISqlExpressionFactory): SqlServerLongCountMethodTranslator;
};


export type SqlServerLongCountMethodTranslator = SqlServerLongCountMethodTranslator$instance;

export interface SqlServerMathTranslator$instance {
    translate(instance: SqlExpression, method: MethodInfo, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger<DbLoggerCategory$Query>): SqlExpression | undefined;
}


export const SqlServerMathTranslator: {
    new(sqlExpressionFactory: ISqlExpressionFactory): SqlServerMathTranslator;
};


export type SqlServerMathTranslator = SqlServerMathTranslator$instance;

export interface SqlServerMemberTranslatorProvider$instance extends RelationalMemberTranslatorProvider {
}


export const SqlServerMemberTranslatorProvider: {
    new(dependencies: RelationalMemberTranslatorProviderDependencies, typeMappingSource: IRelationalTypeMappingSource): SqlServerMemberTranslatorProvider;
};


export type SqlServerMemberTranslatorProvider = SqlServerMemberTranslatorProvider$instance;

export interface SqlServerMethodCallTranslatorProvider$instance extends RelationalMethodCallTranslatorProvider {
}


export const SqlServerMethodCallTranslatorProvider: {
    new(dependencies: RelationalMethodCallTranslatorProviderDependencies, sqlServerSingletonOptions: ISqlServerSingletonOptions): SqlServerMethodCallTranslatorProvider;
};


export type SqlServerMethodCallTranslatorProvider = SqlServerMethodCallTranslatorProvider$instance;

export interface SqlServerNavigationExpansionExtensibilityHelper$instance extends NavigationExpansionExtensibilityHelper {
    areQueryRootsCompatible(first: EntityQueryRootExpression, second: EntityQueryRootExpression): boolean;
    createQueryRoot(entityType: IEntityType, source: EntityQueryRootExpression): EntityQueryRootExpression;
    validateQueryRootCreation(entityType: IEntityType, source: EntityQueryRootExpression): void;
}


export const SqlServerNavigationExpansionExtensibilityHelper: {
    new(dependencies: NavigationExpansionExtensibilityHelperDependencies): SqlServerNavigationExpansionExtensibilityHelper;
};


export type SqlServerNavigationExpansionExtensibilityHelper = SqlServerNavigationExpansionExtensibilityHelper$instance;

export interface SqlServerNewGuidTranslator$instance {
    translate(instance: SqlExpression, method: MethodInfo, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger<DbLoggerCategory$Query>): SqlExpression | undefined;
}


export const SqlServerNewGuidTranslator: {
    new(sqlExpressionFactory: ISqlExpressionFactory): SqlServerNewGuidTranslator;
};


export type SqlServerNewGuidTranslator = SqlServerNewGuidTranslator$instance;

export interface SqlServerObjectToStringTranslator$instance {
    translate(instance: SqlExpression, method: MethodInfo, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger<DbLoggerCategory$Query>): SqlExpression | undefined;
}


export const SqlServerObjectToStringTranslator: {
    new(sqlExpressionFactory: ISqlExpressionFactory, typeMappingSource: IRelationalTypeMappingSource): SqlServerObjectToStringTranslator;
};


export type SqlServerObjectToStringTranslator = SqlServerObjectToStringTranslator$instance;

export interface SqlServerOpenJsonExpression$instance extends TableValuedFunctionExpression {
    readonly columnInfos: IReadOnlyList<SqlServerOpenJsonExpression_ColumnInfo> | undefined;
    readonly jsonExpression: SqlExpression;
    readonly path: IReadOnlyList<PathSegment> | undefined;
    clone(alias: string, cloningExpressionVisitor: ExpressionVisitor): TableExpressionBase;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    quote(): Expression;
    update(jsonExpression: SqlExpression, path: IReadOnlyList<PathSegment>, columnInfos?: IReadOnlyList<SqlServerOpenJsonExpression_ColumnInfo>): SqlServerOpenJsonExpression;
    update(sqlExpression: SqlExpression): SqlServerOpenJsonExpression;
    withAlias(newAlias: string): SqlServerOpenJsonExpression;
}


export const SqlServerOpenJsonExpression: {
    new(alias: string, jsonExpression: SqlExpression, path: IReadOnlyList<PathSegment>, columnInfos: IReadOnlyList<SqlServerOpenJsonExpression_ColumnInfo>): SqlServerOpenJsonExpression;
};


export type SqlServerOpenJsonExpression = SqlServerOpenJsonExpression$instance;

export interface SqlServerParameterBasedSqlProcessor$instance extends RelationalParameterBasedSqlProcessor {
    process(queryExpression: Expression, parametersDecorator: ParametersCacheDecorator): Expression;
}


export const SqlServerParameterBasedSqlProcessor: {
    new(dependencies: RelationalParameterBasedSqlProcessorDependencies, parameters: RelationalParameterBasedSqlProcessorParameters, sqlServerSingletonOptions: ISqlServerSingletonOptions): SqlServerParameterBasedSqlProcessor;
};


export type SqlServerParameterBasedSqlProcessor = SqlServerParameterBasedSqlProcessor$instance;

export interface SqlServerParameterBasedSqlProcessorFactory$instance {
    create(parameters: RelationalParameterBasedSqlProcessorParameters): RelationalParameterBasedSqlProcessor;
}


export const SqlServerParameterBasedSqlProcessorFactory: {
    new(dependencies: RelationalParameterBasedSqlProcessorDependencies, sqlServerSingletonOptions: ISqlServerSingletonOptions): SqlServerParameterBasedSqlProcessorFactory;
};


export type SqlServerParameterBasedSqlProcessorFactory = SqlServerParameterBasedSqlProcessorFactory$instance;

export interface SqlServerQueryableMethodTranslatingExpressionVisitor$instance extends RelationalQueryableMethodTranslatingExpressionVisitor {
}


export const SqlServerQueryableMethodTranslatingExpressionVisitor: {
    new(dependencies: QueryableMethodTranslatingExpressionVisitorDependencies, relationalDependencies: RelationalQueryableMethodTranslatingExpressionVisitorDependencies, queryCompilationContext: SqlServerQueryCompilationContext, sqlServerSingletonOptions: ISqlServerSingletonOptions): SqlServerQueryableMethodTranslatingExpressionVisitor;
};


export type SqlServerQueryableMethodTranslatingExpressionVisitor = SqlServerQueryableMethodTranslatingExpressionVisitor$instance;

export interface SqlServerQueryableMethodTranslatingExpressionVisitorFactory$instance {
    create(queryCompilationContext: QueryCompilationContext): QueryableMethodTranslatingExpressionVisitor;
}


export const SqlServerQueryableMethodTranslatingExpressionVisitorFactory: {
    new(dependencies: QueryableMethodTranslatingExpressionVisitorDependencies, relationalDependencies: RelationalQueryableMethodTranslatingExpressionVisitorDependencies, sqlServerSingletonOptions: ISqlServerSingletonOptions): SqlServerQueryableMethodTranslatingExpressionVisitorFactory;
};


export type SqlServerQueryableMethodTranslatingExpressionVisitorFactory = SqlServerQueryableMethodTranslatingExpressionVisitorFactory$instance;

export interface SqlServerQueryCompilationContext$instance extends RelationalQueryCompilationContext {
    readonly isBuffering: boolean;
    readonly supportsPrecompiledQuery: boolean;
}


export const SqlServerQueryCompilationContext: {
    new(dependencies: QueryCompilationContextDependencies, relationalDependencies: RelationalQueryCompilationContextDependencies, async: boolean, multipleActiveResultSetsEnabled: boolean): SqlServerQueryCompilationContext;
    new(dependencies: QueryCompilationContextDependencies, relationalDependencies: RelationalQueryCompilationContextDependencies, async: boolean, multipleActiveResultSetsEnabled: boolean, precompiling: boolean): SqlServerQueryCompilationContext;
};


export type SqlServerQueryCompilationContext = SqlServerQueryCompilationContext$instance;

export interface SqlServerQueryCompilationContextFactory$instance {
    create(async: boolean): QueryCompilationContext;
    createPrecompiled(async: boolean): QueryCompilationContext;
}


export const SqlServerQueryCompilationContextFactory: {
    new(dependencies: QueryCompilationContextDependencies, relationalDependencies: RelationalQueryCompilationContextDependencies, sqlServerConnection: ISqlServerConnection): SqlServerQueryCompilationContextFactory;
};


export type SqlServerQueryCompilationContextFactory = SqlServerQueryCompilationContextFactory$instance;

export interface SqlServerQuerySqlGenerator$instance extends QuerySqlGenerator {
}


export const SqlServerQuerySqlGenerator: {
    new(dependencies: QuerySqlGeneratorDependencies, typeMappingSource: IRelationalTypeMappingSource, sqlServerSingletonOptions: ISqlServerSingletonOptions): SqlServerQuerySqlGenerator;
};


export type SqlServerQuerySqlGenerator = SqlServerQuerySqlGenerator$instance;

export interface SqlServerQuerySqlGeneratorFactory$instance {
    create(): QuerySqlGenerator;
}


export const SqlServerQuerySqlGeneratorFactory: {
    new(dependencies: QuerySqlGeneratorDependencies, typeMappingSource: IRelationalTypeMappingSource, sqlServerSingletonOptions: ISqlServerSingletonOptions): SqlServerQuerySqlGeneratorFactory;
};


export type SqlServerQuerySqlGeneratorFactory = SqlServerQuerySqlGeneratorFactory$instance;

export interface SqlServerQueryStringFactory$instance {
    create(command: DbCommand): string;
}


export const SqlServerQueryStringFactory: {
    new(typeMapper: IRelationalTypeMappingSource): SqlServerQueryStringFactory;
};


export type SqlServerQueryStringFactory = SqlServerQueryStringFactory$instance;

export interface SqlServerQueryTranslationPostprocessor$instance extends RelationalQueryTranslationPostprocessor {
    process(query: Expression): Expression;
}


export const SqlServerQueryTranslationPostprocessor: {
    new(dependencies: QueryTranslationPostprocessorDependencies, relationalDependencies: RelationalQueryTranslationPostprocessorDependencies, queryCompilationContext: SqlServerQueryCompilationContext): SqlServerQueryTranslationPostprocessor;
};


export type SqlServerQueryTranslationPostprocessor = SqlServerQueryTranslationPostprocessor$instance;

export interface SqlServerQueryTranslationPostprocessorFactory$instance {
    create(queryCompilationContext: QueryCompilationContext): QueryTranslationPostprocessor;
}


export const SqlServerQueryTranslationPostprocessorFactory: {
    new(dependencies: QueryTranslationPostprocessorDependencies, relationalDependencies: RelationalQueryTranslationPostprocessorDependencies): SqlServerQueryTranslationPostprocessorFactory;
};


export type SqlServerQueryTranslationPostprocessorFactory = SqlServerQueryTranslationPostprocessorFactory$instance;

export interface SqlServerSqlExpressionFactory$instance extends SqlExpressionFactory {
    applyTypeMapping(sqlExpression: SqlExpression, typeMapping: RelationalTypeMapping): SqlExpression | undefined;
}


export const SqlServerSqlExpressionFactory: {
    new(dependencies: SqlExpressionFactoryDependencies): SqlServerSqlExpressionFactory;
};


export type SqlServerSqlExpressionFactory = SqlServerSqlExpressionFactory$instance;

export interface SqlServerSqlNullabilityProcessor$instance extends SqlNullabilityProcessor {
    process(queryExpression: Expression, parametersDecorator: ParametersCacheDecorator): Expression;
}


export const SqlServerSqlNullabilityProcessor: {
    new(dependencies: RelationalParameterBasedSqlProcessorDependencies, parameters: RelationalParameterBasedSqlProcessorParameters, sqlServerSingletonOptions: ISqlServerSingletonOptions): SqlServerSqlNullabilityProcessor;
    readonly openJsonParameterTableName: string;
};


export type SqlServerSqlNullabilityProcessor = SqlServerSqlNullabilityProcessor$instance;

export interface SqlServerSqlTranslatingExpressionVisitor$instance extends RelationalSqlTranslatingExpressionVisitor {
    generateGreatest(expressions: IReadOnlyList<SqlExpression>, resultType: Type): SqlExpression | undefined;
    generateLeast(expressions: IReadOnlyList<SqlExpression>, resultType: Type): SqlExpression | undefined;
}


export const SqlServerSqlTranslatingExpressionVisitor: {
    new(dependencies: RelationalSqlTranslatingExpressionVisitorDependencies, queryCompilationContext: SqlServerQueryCompilationContext, queryableMethodTranslatingExpressionVisitor: QueryableMethodTranslatingExpressionVisitor, sqlServerSingletonOptions: ISqlServerSingletonOptions): SqlServerSqlTranslatingExpressionVisitor;
    constructLikePatternParameter(queryContext: QueryContext, baseParameterName: string, methodType: SqlServerSqlTranslatingExpressionVisitor_StartsEndsWithContains): string | undefined;
};


export type SqlServerSqlTranslatingExpressionVisitor = SqlServerSqlTranslatingExpressionVisitor$instance;

export interface SqlServerSqlTranslatingExpressionVisitorFactory$instance {
    create(queryCompilationContext: QueryCompilationContext, queryableMethodTranslatingExpressionVisitor: QueryableMethodTranslatingExpressionVisitor): RelationalSqlTranslatingExpressionVisitor;
}


export const SqlServerSqlTranslatingExpressionVisitorFactory: {
    new(dependencies: RelationalSqlTranslatingExpressionVisitorDependencies, sqlServerSingletonOptions: ISqlServerSingletonOptions): SqlServerSqlTranslatingExpressionVisitorFactory;
};


export type SqlServerSqlTranslatingExpressionVisitorFactory = SqlServerSqlTranslatingExpressionVisitorFactory$instance;

export interface SqlServerSqlTreePruner$instance extends SqlTreePruner {
}


export const SqlServerSqlTreePruner: {
    new(): SqlServerSqlTreePruner;
};


export type SqlServerSqlTreePruner = SqlServerSqlTreePruner$instance;

export interface SqlServerStatisticsAggregateMethodTranslator$instance {
    translate(method: MethodInfo, source: EnumerableExpression, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger<DbLoggerCategory$Query>): SqlExpression | undefined;
}


export const SqlServerStatisticsAggregateMethodTranslator: {
    new(sqlExpressionFactory: ISqlExpressionFactory, typeMappingSource: IRelationalTypeMappingSource): SqlServerStatisticsAggregateMethodTranslator;
};


export type SqlServerStatisticsAggregateMethodTranslator = SqlServerStatisticsAggregateMethodTranslator$instance;

export interface SqlServerStringAggregateMethodTranslator$instance {
    translate(method: MethodInfo, source: EnumerableExpression, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger<DbLoggerCategory$Query>): SqlExpression | undefined;
}


export const SqlServerStringAggregateMethodTranslator: {
    new(sqlExpressionFactory: ISqlExpressionFactory, typeMappingSource: IRelationalTypeMappingSource): SqlServerStringAggregateMethodTranslator;
};


export type SqlServerStringAggregateMethodTranslator = SqlServerStringAggregateMethodTranslator$instance;

export interface SqlServerStringMemberTranslator$instance {
    translate(instance: SqlExpression, member: MemberInfo, returnType: Type, logger: IDiagnosticsLogger<DbLoggerCategory$Query>): SqlExpression | undefined;
}


export const SqlServerStringMemberTranslator: {
    new(sqlExpressionFactory: ISqlExpressionFactory): SqlServerStringMemberTranslator;
};


export type SqlServerStringMemberTranslator = SqlServerStringMemberTranslator$instance;

export interface SqlServerStringMethodTranslator$instance {
    translate(instance: SqlExpression, method: MethodInfo, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger<DbLoggerCategory$Query>): SqlExpression | undefined;
}


export const SqlServerStringMethodTranslator: {
    new(sqlExpressionFactory: ISqlExpressionFactory, sqlServerSingletonOptions: ISqlServerSingletonOptions): SqlServerStringMethodTranslator;
};


export type SqlServerStringMethodTranslator = SqlServerStringMethodTranslator$instance;

export interface SqlServerTimeOnlyMemberTranslator$instance {
    translate(instance: SqlExpression, member: MemberInfo, returnType: Type, logger: IDiagnosticsLogger<DbLoggerCategory$Query>): SqlExpression | undefined;
}


export const SqlServerTimeOnlyMemberTranslator: {
    new(sqlExpressionFactory: ISqlExpressionFactory): SqlServerTimeOnlyMemberTranslator;
};


export type SqlServerTimeOnlyMemberTranslator = SqlServerTimeOnlyMemberTranslator$instance;

export interface SqlServerTimeOnlyMethodTranslator$instance {
    translate(instance: SqlExpression, method: MethodInfo, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger<DbLoggerCategory$Query>): SqlExpression | undefined;
}


export const SqlServerTimeOnlyMethodTranslator: {
    new(sqlExpressionFactory: ISqlExpressionFactory): SqlServerTimeOnlyMethodTranslator;
};


export type SqlServerTimeOnlyMethodTranslator = SqlServerTimeOnlyMethodTranslator$instance;

export interface SqlServerTimeSpanMemberTranslator$instance {
    translate(instance: SqlExpression, member: MemberInfo, returnType: Type, logger: IDiagnosticsLogger<DbLoggerCategory$Query>): SqlExpression | undefined;
}


export const SqlServerTimeSpanMemberTranslator: {
    new(sqlExpressionFactory: ISqlExpressionFactory): SqlServerTimeSpanMemberTranslator;
};


export type SqlServerTimeSpanMemberTranslator = SqlServerTimeSpanMemberTranslator$instance;

export interface SqlServerTypeMappingPostprocessor$instance extends RelationalTypeMappingPostprocessor {
}


export const SqlServerTypeMappingPostprocessor: {
    new(dependencies: QueryTranslationPostprocessorDependencies, relationalDependencies: RelationalQueryTranslationPostprocessorDependencies, queryCompilationContext: RelationalQueryCompilationContext): SqlServerTypeMappingPostprocessor;
};


export type SqlServerTypeMappingPostprocessor = SqlServerTypeMappingPostprocessor$instance;

export interface SqlServerVectorTranslator$instance {
    translate(instance: SqlExpression, method: MethodInfo, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger<DbLoggerCategory$Query>): SqlExpression | undefined;
    translate(instance: SqlExpression, member: MemberInfo, returnType: Type, logger: IDiagnosticsLogger<DbLoggerCategory$Query>): SqlExpression | undefined;
}


export const SqlServerVectorTranslator: {
    new(sqlExpressionFactory: ISqlExpressionFactory, typeMappingSource: IRelationalTypeMappingSource): SqlServerVectorTranslator;
};


export type SqlServerVectorTranslator = SqlServerVectorTranslator$instance;

export interface SqlServerZeroLimitConverter$instance extends ExpressionVisitor {
    process(queryExpression: Expression, parametersDecorator: ParametersCacheDecorator): Expression;
}


export const SqlServerZeroLimitConverter: {
    new(sqlExpressionFactory: ISqlExpressionFactory): SqlServerZeroLimitConverter;
};


export type SqlServerZeroLimitConverter = SqlServerZeroLimitConverter$instance;

export interface TemporalAllQueryRootExpression$instance extends TemporalQueryRootExpression {
    detachQueryProvider(): Expression;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    updateEntityType(entityType: IEntityType): EntityQueryRootExpression;
}


export const TemporalAllQueryRootExpression: {
    new(entityType: IEntityType): TemporalAllQueryRootExpression;
    new(queryProvider: IAsyncQueryProvider, entityType: IEntityType): TemporalAllQueryRootExpression;
};


export type TemporalAllQueryRootExpression = TemporalAllQueryRootExpression$instance;

export interface TemporalAsOfQueryRootExpression$instance extends TemporalQueryRootExpression {
    readonly pointInTime: DateTime;
    detachQueryProvider(): Expression;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    updateEntityType(entityType: IEntityType): EntityQueryRootExpression;
}


export const TemporalAsOfQueryRootExpression: {
    new(entityType: IEntityType, pointInTime: DateTime): TemporalAsOfQueryRootExpression;
    new(queryProvider: IAsyncQueryProvider, entityType: IEntityType, pointInTime: DateTime): TemporalAsOfQueryRootExpression;
};


export type TemporalAsOfQueryRootExpression = TemporalAsOfQueryRootExpression$instance;

export interface TemporalBetweenQueryRootExpression$instance extends TemporalRangeQueryRootExpression {
    detachQueryProvider(): Expression;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    updateEntityType(entityType: IEntityType): EntityQueryRootExpression;
}


export const TemporalBetweenQueryRootExpression: {
    new(entityType: IEntityType, from: DateTime, to: DateTime): TemporalBetweenQueryRootExpression;
    new(queryProvider: IAsyncQueryProvider, entityType: IEntityType, from: DateTime, to: DateTime): TemporalBetweenQueryRootExpression;
};


export type TemporalBetweenQueryRootExpression = TemporalBetweenQueryRootExpression$instance;

export interface TemporalContainedInQueryRootExpression$instance extends TemporalRangeQueryRootExpression {
    detachQueryProvider(): Expression;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    updateEntityType(entityType: IEntityType): EntityQueryRootExpression;
}


export const TemporalContainedInQueryRootExpression: {
    new(entityType: IEntityType, from: DateTime, to: DateTime): TemporalContainedInQueryRootExpression;
    new(queryProvider: IAsyncQueryProvider, entityType: IEntityType, from: DateTime, to: DateTime): TemporalContainedInQueryRootExpression;
};


export type TemporalContainedInQueryRootExpression = TemporalContainedInQueryRootExpression$instance;

export interface TemporalFromToQueryRootExpression$instance extends TemporalRangeQueryRootExpression {
    detachQueryProvider(): Expression;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    updateEntityType(entityType: IEntityType): EntityQueryRootExpression;
}


export const TemporalFromToQueryRootExpression: {
    new(entityType: IEntityType, from: DateTime, to: DateTime): TemporalFromToQueryRootExpression;
    new(queryProvider: IAsyncQueryProvider, entityType: IEntityType, from: DateTime, to: DateTime): TemporalFromToQueryRootExpression;
};


export type TemporalFromToQueryRootExpression = TemporalFromToQueryRootExpression$instance;

export interface TemporalQueryRootExpression$instance extends EntityQueryRootExpression {
}


export const TemporalQueryRootExpression: {
};


export type TemporalQueryRootExpression = TemporalQueryRootExpression$instance;

export interface TemporalRangeQueryRootExpression$instance extends TemporalQueryRootExpression {
    readonly from: DateTime;
    readonly to: DateTime;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const TemporalRangeQueryRootExpression: {
};


export type TemporalRangeQueryRootExpression = TemporalRangeQueryRootExpression$instance;

export abstract class SqlServerExpression$instance {
    static aggregateFunction(sqlExpressionFactory: ISqlExpressionFactory, name: string, arguments: IEnumerable<SqlExpression>, enumerableExpression: EnumerableExpression, enumerableArgumentIndex: int, nullable: boolean, argumentsPropagateNullability: IEnumerable<System_Internal.Boolean>, returnType: Type, typeMapping?: RelationalTypeMapping): SqlFunctionExpression;
    static aggregateFunctionWithOrdering(sqlExpressionFactory: ISqlExpressionFactory, name: string, arguments: IEnumerable<SqlExpression>, enumerableExpression: EnumerableExpression, enumerableArgumentIndex: int, nullable: boolean, argumentsPropagateNullability: IEnumerable<System_Internal.Boolean>, returnType: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
}


export type SqlServerExpression = SqlServerExpression$instance;

